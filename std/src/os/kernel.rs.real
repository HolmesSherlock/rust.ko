/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __IncompleteArrayField<T> { }
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __llvm__: ::std::os::raw::c_uint = 1;
pub const __clang__: ::std::os::raw::c_uint = 1;
pub const __clang_major__: ::std::os::raw::c_uint = 3;
pub const __clang_minor__: ::std::os::raw::c_uint = 9;
pub const __clang_patchlevel__: ::std::os::raw::c_uint = 0;
pub const __clang_version__: &'static [u8; 31usize] =
    b"3.9.0 (tags/RELEASE_390/final)\x00";
pub const __GNUC_MINOR__: ::std::os::raw::c_uint = 2;
pub const __GNUC_PATCHLEVEL__: ::std::os::raw::c_uint = 1;
pub const __GNUC__: ::std::os::raw::c_uint = 4;
pub const __GXX_ABI_VERSION: ::std::os::raw::c_uint = 1002;
pub const __ATOMIC_RELAXED: ::std::os::raw::c_uint = 0;
pub const __ATOMIC_CONSUME: ::std::os::raw::c_uint = 1;
pub const __ATOMIC_ACQUIRE: ::std::os::raw::c_uint = 2;
pub const __ATOMIC_RELEASE: ::std::os::raw::c_uint = 3;
pub const __ATOMIC_ACQ_REL: ::std::os::raw::c_uint = 4;
pub const __ATOMIC_SEQ_CST: ::std::os::raw::c_uint = 5;
pub const __PRAGMA_REDEFINE_EXTNAME: ::std::os::raw::c_uint = 1;
pub const __VERSION__: &'static [u8; 54usize] =
    b"4.2.1 Compatible Clang 3.9.0 (tags/RELEASE_390/final)\x00";
pub const __CONSTANT_CFSTRINGS__: ::std::os::raw::c_uint = 1;
pub const __OPTIMIZE__: ::std::os::raw::c_uint = 1;
pub const __ORDER_LITTLE_ENDIAN__: ::std::os::raw::c_uint = 1234;
pub const __ORDER_BIG_ENDIAN__: ::std::os::raw::c_uint = 4321;
pub const __ORDER_PDP_ENDIAN__: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER__: ::std::os::raw::c_uint = 1234;
pub const __LITTLE_ENDIAN__: ::std::os::raw::c_uint = 1;
pub const _LP64: ::std::os::raw::c_uint = 1;
pub const __LP64__: ::std::os::raw::c_uint = 1;
pub const __CHAR_BIT__: ::std::os::raw::c_uint = 8;
pub const __SCHAR_MAX__: ::std::os::raw::c_uint = 127;
pub const __SHRT_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __LONG_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_LONG_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __WCHAR_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INTMAX_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_MAX__: ::std::os::raw::c_int = -1;
pub const __UINTMAX_MAX__: ::std::os::raw::c_int = -1;
pub const __PTRDIFF_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __INTPTR_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __UINTPTR_MAX__: ::std::os::raw::c_int = -1;
pub const __SIZEOF_DOUBLE__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_FLOAT__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_INT__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_LONG__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_LONG_DOUBLE__: ::std::os::raw::c_uint = 16;
pub const __SIZEOF_LONG_LONG__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_POINTER__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_SHORT__: ::std::os::raw::c_uint = 2;
pub const __SIZEOF_PTRDIFF_T__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_SIZE_T__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_WCHAR_T__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_WINT_T__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_INT128__: ::std::os::raw::c_uint = 16;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __INTMAX_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __PTRDIFF_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __INTPTR_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __SIZE_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __WCHAR_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __WINT_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __SIG_ATOMIC_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __SIG_ATOMIC_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __UINTMAX_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __UINTPTR_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __FLT_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __FLT_DIG__: ::std::os::raw::c_uint = 6;
pub const __FLT_DECIMAL_DIG__: ::std::os::raw::c_uint = 9;
pub const __FLT_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __FLT_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __FLT_MANT_DIG__: ::std::os::raw::c_uint = 24;
pub const __FLT_MAX_10_EXP__: ::std::os::raw::c_uint = 38;
pub const __FLT_MAX_EXP__: ::std::os::raw::c_uint = 128;
pub const __FLT_MIN_10_EXP__: ::std::os::raw::c_int = -37;
pub const __FLT_MIN_EXP__: ::std::os::raw::c_int = -125;
pub const __DBL_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __DBL_DIG__: ::std::os::raw::c_uint = 15;
pub const __DBL_DECIMAL_DIG__: ::std::os::raw::c_uint = 17;
pub const __DBL_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __DBL_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __DBL_MANT_DIG__: ::std::os::raw::c_uint = 53;
pub const __DBL_MAX_10_EXP__: ::std::os::raw::c_uint = 308;
pub const __DBL_MAX_EXP__: ::std::os::raw::c_uint = 1024;
pub const __DBL_MIN_10_EXP__: ::std::os::raw::c_int = -307;
pub const __DBL_MIN_EXP__: ::std::os::raw::c_int = -1021;
pub const __LDBL_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __LDBL_DIG__: ::std::os::raw::c_uint = 18;
pub const __LDBL_DECIMAL_DIG__: ::std::os::raw::c_uint = 21;
pub const __LDBL_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __LDBL_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __LDBL_MANT_DIG__: ::std::os::raw::c_uint = 64;
pub const __LDBL_MAX_10_EXP__: ::std::os::raw::c_uint = 4932;
pub const __LDBL_MAX_EXP__: ::std::os::raw::c_uint = 16384;
pub const __LDBL_MIN_10_EXP__: ::std::os::raw::c_int = -4931;
pub const __LDBL_MIN_EXP__: ::std::os::raw::c_int = -16381;
pub const __POINTER_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __BIGGEST_ALIGNMENT__: ::std::os::raw::c_uint = 16;
pub const __WINT_UNSIGNED__: ::std::os::raw::c_uint = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __INT64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __UINT8_MAX__: ::std::os::raw::c_uint = 255;
pub const __INT8_MAX__: ::std::os::raw::c_uint = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __UINT16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __INT16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __UINT32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __INT32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __UINT64_MAX__: ::std::os::raw::c_int = -1;
pub const __INT64_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __INT_LEAST8_MAX__: ::std::os::raw::c_uint = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __UINT_LEAST8_MAX__: ::std::os::raw::c_uint = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __INT_LEAST16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __UINT_LEAST16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __INT_LEAST32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __UINT_LEAST32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __INT_LEAST64_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINT_LEAST64_MAX__: ::std::os::raw::c_int = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __INT_FAST8_MAX__: ::std::os::raw::c_uint = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __UINT_FAST8_MAX__: ::std::os::raw::c_uint = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __INT_FAST16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __UINT_FAST16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __INT_FAST32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __UINT_FAST32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __INT_FAST64_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINT_FAST64_MAX__: ::std::os::raw::c_int = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __FINITE_MATH_ONLY__: ::std::os::raw::c_uint = 0;
pub const __GNUC_GNU_INLINE__: ::std::os::raw::c_uint = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: ::std::os::raw::c_uint = 1;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __FLT_EVAL_METHOD__: ::std::os::raw::c_uint = 2;
pub const __FLT_RADIX__: ::std::os::raw::c_uint = 2;
pub const __DECIMAL_DIG__: ::std::os::raw::c_uint = 21;
pub const __SSP__: ::std::os::raw::c_uint = 1;
pub const __amd64__: ::std::os::raw::c_uint = 1;
pub const __amd64: ::std::os::raw::c_uint = 1;
pub const __x86_64: ::std::os::raw::c_uint = 1;
pub const __x86_64__: ::std::os::raw::c_uint = 1;
pub const __k8: ::std::os::raw::c_uint = 1;
pub const __k8__: ::std::os::raw::c_uint = 1;
pub const __tune_k8__: ::std::os::raw::c_uint = 1;
pub const __NO_MATH_INLINES: ::std::os::raw::c_uint = 1;
pub const __FXSR__: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: ::std::os::raw::c_uint = 1;
pub const unix: ::std::os::raw::c_uint = 1;
pub const __unix: ::std::os::raw::c_uint = 1;
pub const __unix__: ::std::os::raw::c_uint = 1;
pub const linux: ::std::os::raw::c_uint = 1;
pub const __linux: ::std::os::raw::c_uint = 1;
pub const __linux__: ::std::os::raw::c_uint = 1;
pub const __gnu_linux__: ::std::os::raw::c_uint = 1;
pub const __ELF__: ::std::os::raw::c_uint = 1;
pub const __FLOAT128__: ::std::os::raw::c_uint = 1;
pub const __STDC__: ::std::os::raw::c_uint = 1;
pub const __STDC_HOSTED__: ::std::os::raw::c_uint = 1;
pub const __STDC_UTF_16__: ::std::os::raw::c_uint = 1;
pub const __STDC_UTF_32__: ::std::os::raw::c_uint = 1;
pub const __KERNEL__: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_X32_ABI: ::std::os::raw::c_uint = 1;
pub const CONFIG_AS_FXSAVEQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_AS_SSSE3: ::std::os::raw::c_uint = 1;
pub const CONFIG_AS_CRC32: ::std::os::raw::c_uint = 1;
pub const CONFIG_AS_AVX: ::std::os::raw::c_uint = 1;
pub const CONFIG_AS_AVX2: ::std::os::raw::c_uint = 1;
pub const MODULE: ::std::os::raw::c_uint = 1;
pub const CC_USING_FENTRY: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_MATCH_AH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_861_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RING_BUFFER: ::std::os::raw::c_uint = 1;
pub const CONFIG_UWB_HWA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8804_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_H323_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_ARCH_SECCOMP_FILTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_SECURITY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_PROC_FS: ::std::os::raw::c_uint = 1;
pub const CONFIG_VFIO_PCI_MMAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_DMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_TWL6040_CORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_IDLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCP_MD5SIG: ::std::os::raw::c_uint = 1;
pub const CONFIG_KERNEL_GZIP: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_GT683R_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MICROCODE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_ENI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_EM28XX_V4L2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_HASH_IPMARK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_ADV7511_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_INEXIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTLBTCOEXIST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATMAN_ADV_NC: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_NAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DW_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_WM831X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_WM9705: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_KEYBOARD: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_BDC_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KPROBE_EVENT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ABITUGURU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_SUPPORTS_INT128: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_TARGET_SYNPROXY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMORY_ISOLATION: ::std::os::raw::c_uint = 1;
pub const CONFIG_SLUB_CPU_PARTIAL: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_C67X00_HCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RFS_ACCEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_TEST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TI_DAC7512_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_TARGET_REDIRECT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIO_ALTERA_PS2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_GMA500_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRC32: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_BOARDINFO: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH9K_HTC_DEBUGFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_DMI_SYSFS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPEAKUP_SYNTH_LTLK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_PROTO_SCTP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CROS_EC_PROTO: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ALI_M5632: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_IT8761E_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_SNAPSHOT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_WM831X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_WM831X_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAIF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PNFS_FLEXFILE_LAYOUT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_JVC_DECODER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_MCE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_QLOGIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_NCM: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_NOUVEAU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FSCACHE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_USBDUX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARPORT_NOT_PC: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CPU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_ISL6405_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43_BCMA_PIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7192_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_ELAN_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_MAX1668_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_AMD8111_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SUNRPC_SWAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TILEBLITTING: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCM_QLA2XXX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_MCE_KBD_DECODER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_RT5033_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HSR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IXGBE_DCB: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_FREQ_GOV_CONSERVATIVE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECCOMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_HIGH_RES_TIMERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_AXNET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMMON_CLK_WM831X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_WM8739_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_CROS_EC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG: ::std::os::raw::c_uint = 1024;
pub const CONFIG_BLK_DEV_DM: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_88PM80X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_RSXX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_R3964_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PWM_TWL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_ECC_BCH: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2800USB_RT3573: ::std::os::raw::c_uint = 1;
pub const CONFIG_VLAN_8021Q_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_MULTIPLE_TABLES: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT: ::std::os::raw::c_uint =
    1;
pub const CONFIG_VFIO_PCI_VGA: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_BGRT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LTC4260_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UEVENT_HELPER: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_DOM0: ::std::os::raw::c_uint = 1;
pub const CONFIG_FIRMWARE_MEMMAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SSB_SDIOHOST: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_RFCOMM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FIX_EARLYCON_MEM: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_TRIGGER_HEARTBEAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEV_APPLETALK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_HX8353D_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_LP8727_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_INITIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_STK8BA50_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TDA1004X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XZ_DEC_IA64: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_DA9211_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_RETU_PWRBUTTON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_ELAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_ADI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_BCM3510_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INOTIFY_USER: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_RT286_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I7300_IDLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_NETWORK_XFRM: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_NETBIOS_NS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HDMI: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_DH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_LOGGING: ::std::os::raw::c_uint = 1;
pub const CONFIG_SX9500_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_CYBER2000_DDC: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_T_FILTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETWORK_FILESYSTEMS: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_IFORCE_232: ::std::os::raw::c_uint = 1;
pub const CONFIG_KVM_INTEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ZRAM_LZ4_COMPRESS: ::std::os::raw::c_uint = 1;
pub const CONFIG_ASUS_LAPTOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_MD4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCMA_HOST_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7298_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_AHCI_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IMA_DEFAULT_HASH_SHA1: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SI470X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_THERMAL_GOV_BANG_BANG: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_MINIMUM_CPU_FAMILY: ::std::os::raw::c_uint = 64;
pub const CONFIG_AD7923_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_BFA_FC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_FREQ_GOV_ONDEMAND: ::std::os::raw::c_uint = 1;
pub const CONFIG_KDB_DEFAULT_ENABLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AMD_IOMMU_STATS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM95245_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_JL2005BCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_MC13XXX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CM36651_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXT4_ENCRYPTION_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AMD_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX18_ALSA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIBFUSB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GLOB: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_CS42L73_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PLX_HERMES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARAVIRT_SPINLOCKS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CGROUP_DEVICE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WL12XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_TSC: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPP_SYNC_TTY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_SUSPEND_POSSIBLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_PLANTRONICS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_TPS65090: ::std::os::raw::c_uint = 1;
pub const CONFIG_NCPFS_PACKET_SIGNING: ::std::os::raw::c_uint = 1;
pub const CONFIG_DA9055_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMPAT_NETLINK_MESSAGES: ::std::os::raw::c_uint = 1;
pub const CONFIG_INLINE_WRITE_UNLOCK_IRQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_CHAIN_NAT_IPV6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RC_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_G_SERIAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CGROUP_WRITEBACK: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_TPA6130A2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC80211_STA_HASH_MAX_SIZE: ::std::os::raw::c_uint = 0;
pub const CONFIG_LEDS_PCA955X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_MAC_TURKISH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_NQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_DRXD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LTC4245_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SPEEDLINK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPEAKUP_SYNTH_APOLLO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HIBERNATION: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_NBD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PNPACPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7280_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_NAVMAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_SPACEORB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_I5400_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCP_CONG_HTCP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXT4_FS_POSIX_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_RP2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_DEBUG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_I915_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BINFMT_MISC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_AD7314_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VME_CA91CX42_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_HELPER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MT6397_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SSB_POSSIBLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HPET_MMAP_DEFAULT: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_V4_2: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_T_NAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SAA7134_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_SIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_EEM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_W83792D_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_ZORAN_BUZ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMU_NOTIFIER: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYSV68_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_RADIO_SHARK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ASYMMETRIC_KEY_TYPE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VFIO_VIRQFD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_9P_RDMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_RADEON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_STATISTIC_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_COMEDI_NI_PCIMIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_MUX_PINCTRL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADDI_APCI_1032_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_855_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_ILI9486_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_CHAIN_ROUTE_IPV4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_CMDLINE_PARTS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TMP006_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ESI_DONGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_YAMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SAA7127_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_ISMT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UHID_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETCONSOLE_DYNAMIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_I5100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_EC100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_NAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_EDGEPORT_TI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SIGNATURE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_PCF50633_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HDLC_RAW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43LEGACY_LEDS: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_SAFE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_NCI_UART_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_CROS_EC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_NF_EBTABLES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_LATCH_ADDR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_LG2160_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_AMD76XROM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_OHCI_LITTLE_ENDIAN: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_FIFO: ::std::os::raw::c_uint = 1;
pub const CONFIG_REISERFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TWL4030_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_NV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FSNOTIFY: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_RMD128_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_MAX8997_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_LOOP_MIN_COUNT: ::std::os::raw::c_uint = 8;
pub const CONFIG_STP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SQ905_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_TPS65910: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_CADENCE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_AU8522_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET6_TUNNEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MAX8925_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_RAPL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIA_FIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_DC395x_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_M88RS2000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_SIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_STACK_TRACER: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_ATTACH: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_NM256_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_MANAGER_DISABLE_TESTS: ::std::os::raw::c_uint = 1;
pub const CONFIG_HIDRAW: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_FQ_CODEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIL6210_ISR_COR: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADM1025_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KSDAZZLE_DONGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KERNEL_LZMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_PRODIKEYS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BMA180_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2X00_LIB_LEDS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_PTP_CLASSIFY: ::std::os::raw::c_uint = 1;
pub const CONFIG_UNIX_DIAG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VCNL4000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_SED_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_SMP_IDLE_THREAD: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_CYAPA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_QUALCOMM: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_DS3000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_S1D13XXX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_SST25L_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_SUPPORTS_NUMA_BALANCING: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_LP3971_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_FLAKEY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_COPY_THREAD_TLS: ::std::os::raw::c_uint = 1;
pub const CONFIG_VME_USER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_OPTIDMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MACVTAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DYNAMIC_DEBUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_REGULATOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHELSIO_T4VF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_MEMORY_PRESENT: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_FTDI_SIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXTCON_RT8973A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_EZCHIP: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_REDIRECT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_COMPAT_XENFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_SCSI_BACKEND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_TIOCMD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_DIGITAL_TV_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_8139CP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_8250_RSA: ::std::os::raw::c_uint = 1;
pub const CONFIG_FIB_RULES: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_ACRUX_FF: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CRCT10DIF: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_SLAVE_DS2408_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_OBEX: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_MCP795_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_FIREDTV_INPUT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ES1968_INPUT: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_NFCT: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_EMS_FF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADDI_APCI_16XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VLAN_8021Q_GVRP: ::std::os::raw::c_uint = 1;
pub const CONFIG_IWLWIFI_DEBUGFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_HASH_NETIFACE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_MANGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_PLATRAM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_SI2157_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_CONSTANTS: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_IRQ_TIME_ACCOUNTING: ::std::os::raw::c_uint = 1;
pub const CONFIG_CFAG12864B_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_MRVL_SDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_REALM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIBPA10X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEGARAID_NEWGEN: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_TXT: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_CROS_EC_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SQUASHFS_XATTR: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_RR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_INTEL_CHT_BSW_MAX98090_TI_MACH_MODULE:
          ::std::os::raw::c_uint =
    1;
pub const CONFIG_IPV6: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_QUALCOMM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TEST_LKM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAX1027_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_9P_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_TPS62360_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_AEAD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GADGET_TARGET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_HECUBA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AUDIT_ARCH: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMPAT: ::std::os::raw::c_uint = 1;
pub const CONFIG_POWERCAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_BQL: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADJD_S311_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_MOUSEDEV_PSAUX: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KERNEL_BZIP2: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADDI_APCI_3501_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEFAULT_TCP_CONG: &'static [u8; 6usize] = b"cubic\x00";
pub const CONFIG_MCP4725_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UEVENT_HELPER_PATH: &'static [u8; 1usize] = b"\x00";
pub const CONFIG_USB_UAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NTB_NETDEV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEVTMPFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CLS_FLOW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PROCESSOR_SELECT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_MAX8688_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_PC87427_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_MAX77693_HAPTIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SM_FTL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PNFS_FILE_LAYOUT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HSU_DMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_IPVTI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I82092_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_PMCRAID_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_NXP_NCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_ISL6423_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_S3_DDC: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STORAGE_USBAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REISERFS_FS_POSIX_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_USER_MEM: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_MAX7301_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_88PM80X_ONKEY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_APPLE_GMUX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_PROTO_GRE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_YENTA_RICOH: ::std::os::raw::c_uint = 1;
pub const CONFIG_SUNRPC_BACKCHANNEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_ISO8859_7_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UNISYS_VISORNIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_PCBC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_TARGET_REJECT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UPROBES: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_FRITZPCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_SHARP_DECODER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_APPLEIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PCL812_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ASYNC_MEMCPY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_MAX8998_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADIS16480_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_POWERNOW_K8: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_SPARSEMEM_ENABLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_V4L_TEST_DRIVERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SC1200_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_REDIRECT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DCDBAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS1305_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAIF_SPI_SLAVE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_NEC_DECODER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOTPLUG_CPU: ::std::os::raw::c_uint = 1;
pub const CONFIG_PERCPU_TEST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_MOS7840_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_MAC_CYRILLIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SL811_HCD_ISO: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_SLEEP_DEBUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_MAESTRO3_INPUT: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_PCI_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_WLAN: ::std::os::raw::c_uint = 1;
pub const CONFIG_AFFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADDI_APCI_1516_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_FIRESTREAM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NAMESPACES: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_SLAVE_DS2423_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_L2TP_DEBUGFS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_CMPXCHG_DOUBLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NSC_FIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_ABX80X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_INT51X1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION_MODULE:
          ::std::os::raw::c_uint =
    1;
pub const CONFIG_KGDB_SERIAL_CONSOLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_ATP867X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SFI: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_ARCH_HUGE_VMAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_FM10K_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DW_DMAC_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IA32_EMULATION: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_SIGMADSP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY: ::std::os::raw::c_uint =
    1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA49W: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_CONTEC_PCI_DIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_BSG: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_WM8350_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ENIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_ISCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_MAX6697_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_SERVERWORKS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CONNECTOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DAS16M1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_USB_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_TWL4030_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_PM8941_WLED_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_RATEEST_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_PCIEAER: ::std::os::raw::c_uint = 1;
pub const CONFIG_EPIC100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCTP_COOKIE_HMAC_SHA1: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_ARPREPLY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_APPLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43LEGACY_DMA_AND_PIO_MODE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEM_SOFT_DIRTY: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KVM_DEBUG_FS: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEGRITY: ::std::os::raw::c_uint = 1;
pub const CONFIG_MPL115_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_MAX_ADAPTERS: ::std::os::raw::c_uint = 8;
pub const CONFIG_SENSORS_SIS5595_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CW1200_WLAN_SDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_MULTIPATH_QL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEGACY_PTYS: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIBERTAS_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_EMS_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XFRM_IPCOMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DRBG_MENU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_RNG2: ::std::os::raw::c_uint = 1;
pub const CONFIG_UIO_CIF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_PWC_INPUT_EVDEV: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUSION_FC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_NETLINK_QUEUE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_ACT_CSUM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTLLIB_CRYPTO_CCMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CEPH_LIB_USE_DNS_RESOLVER: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_AB3100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_THERMAL_WRITABLE_TRIPS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_MPT3SAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFTL_RW: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_MC13XXX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MSDOS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ISL29028_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DT2811_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_U_SERIAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_VGA16_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_FLASHPOINT: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CLS_CGROUP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_MAX_DOMAIN_MEMORY: ::std::os::raw::c_uint = 500;
pub const CONFIG_TUN: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_ES8328_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_FO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SUNPLUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_AUDIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DAS6402_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_IDT77252_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_AU8522_V4L_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD9832_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_KFIFO_BUF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ENCLOSURE_SERVICES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPV6_PIMSM_V2: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADS1015_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_DVBSKY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIZNET_BUS_ANY: ::std::os::raw::c_uint = 1;
pub const CONFIG_BNX2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_VX222_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CFG80211_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CHACHA20POLY1305_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SSB_BLOCKIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_BLOCK_RO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_DA9063: ::std::os::raw::c_uint = 1;
pub const CONFIG_EQUALIZER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_HX8347D_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_JR3_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_AU8810_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_LYNXPOINT: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_HASH_NETNET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_1250_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_6527_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_CRYPT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REED_SOLOMON_ENC8: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_8250: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_ISL12022_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_TCPPROBE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NCP_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_GNTDEV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XZ_DEC_TEST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_W83793_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43LEGACY_PIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_LZO_DECOMPRESS: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_EHCI_ROOT_HUB_TT: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIBERTAS_THINFIRM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_PROTO_AH: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXOFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IOMMU_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_BELKIN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_IR_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ROMFS_BACKED_BY_BLOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_VFIO_IOMMU_TYPE1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_STV0367_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_STMMAC_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_TRIGGER_CAMERA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_TTY_FAX: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_862_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFSD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DRV_AVMB1_C4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_TSL2550_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ITG3200_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMPAT_BINFMT_ELF: ::std::os::raw::c_uint = 1;
pub const CONFIG_VFIO_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PWM_LPSS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_DIRECT_GBPAGES: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_IVTV_ALSA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_MPIIX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LOCK_TORTURE_TEST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_OPTION_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_ACRUX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RD_LZMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SE401_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SALSA20_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_SIL680_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_IPMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_MAX8998_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_SDHCI_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SPEEDTOUCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_XILINX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_88PM8607_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ALIM7101_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_PCI_SLOT: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_WAKELOCKS_GC: ::std::os::raw::c_uint = 1;
pub const CONFIG_MODULES_USE_ELF_RELA: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD5686_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_BCD2000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BTREE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_HMAC: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_ADXL34X_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ETHERNET: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_CMD640_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_CODEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFFS2_LZO: ::std::os::raw::c_uint = 1;
pub const CONFIG_FRAMEBUFFER_CONSOLE_ROTATION: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_BMA150_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_JEILINJ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCHED_OMIT_FRAME_POINTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_LOGITECH_HIDPP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RETU_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRANCH_PROFILE_NONE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_SCAN_ASYNC: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_DW_MMIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRC_ITU_T_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HRTIMER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_DMA_CONTIGUOUS: ::std::os::raw::c_uint = 1;
pub const CONFIG_ALI_FIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DQL: ::std::os::raw::c_uint = 1;
pub const CONFIG_RAPIDIO_DISC_TIMEOUT: ::std::os::raw::c_uint = 30;
pub const CONFIG_VXLAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARPORT_PC_PCMCIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FRAMEBUFFER_CONSOLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_DCCPPROBE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_PCM512x_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_ZERO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_DIB8000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_SUPPORTS_MEMORY_FAILURE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SEQUENCER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCP_CONG_LP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SONY_FF: ::std::os::raw::c_uint = 1;
pub const CONFIG_PINCTRL_BAYTRAIL: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_GP2A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD5064_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GAMEPORT_EMU10K1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WL1251_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_BEBOB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COREDUMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_FOU_IP_TUNNELS: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_GL620A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MICREL_KS8995MA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_LGDT3306A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADDI_APCI_1500_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOVABLE_NODE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_OPL3_LIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_ARPTABLES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_SKY81452_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_GP8PSK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_GENERIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4_MODULE: ::std::os::raw::c_uint
          =
    1;
pub const CONFIG_HID_CHERRY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PC87413_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_IMX_AUDMUX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFFS2_COMPRESSION_OPTIONS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CM3323_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_MAX17040_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MKISS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USE_PERCPU_NUMA_NODE_ID: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SUNPLUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_MAX77843_HAPTIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_VMWGFX_FBCON: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_ADXL34X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KSZ884X_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_PICOLCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCMA_POSSIBLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_RNDIS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_LOG_IPV4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_SFB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUSION_CTL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TULIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SM750_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AF_RXRPC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CIFS_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_ZRAM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_SELFBALLOONING: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CAST5_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VGA_ARB: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_INTEL_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_CORETEMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_FIT2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_TABLES_ARP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_CARMINE_DRAM_EVAL: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_NVIDIA_BACKLIGHT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WL_TI: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_TPS51632_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FIREWIRE_SBP2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_MAX77693: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_TOMOYO_POLICY_LOADER: &'static [u8; 18usize] =
    b"/sbin/tomoyo-init\x00";
pub const CONFIG_NET_IPGRE_DEMUX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_MULTIQ3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_XC5000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_POLL_CONTROLLER: ::std::os::raw::c_uint = 1;
pub const CONFIG_PRINTK: ::std::os::raw::c_uint = 1;
pub const CONFIG_NCPFS_EXTRAS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPEAKUP_SYNTH_BNS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA28X: ::std::os::raw::c_uint = 1;
pub const CONFIG_6LOWPAN_NHC_ROUTING_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SFC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PHANTOM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HTC_I2CPLD: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_8250_FINTEK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BMC150_ACCEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FORCEDETH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DAS08_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SYS_FILLRECT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TIMERFD: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_THRUSTMASTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_MCRYPTD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_RAM_DAX: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_DYNAMIC_MINORS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_MAX16065_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_I5K_AMB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DNS_RESOLVER: ::std::os::raw::c_uint = 1;
pub const CONFIG_ITCO_VENDOR_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_TRACEPOINTS: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43_PHY_LP: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_CFI_I2: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_AUTHENC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AT803X_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_SP8870_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I6300ESB_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_ML_IOH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_YENTA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GPIO_VBUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_MASTER_DS2482_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_SERIAL2002_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_SIDEWINDER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_SKD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_EMATCH_STACK: ::std::os::raw::c_uint = 32;
pub const CONFIG_CARL9170_LEDS: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_V4L2_SUBDEV_API: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATL1E_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STORAGE_ENE_UB6250_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_DDBRIDGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_MAC_CENTEURO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRCMFMAC_SDIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_IRDA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BOUNCE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_DA903X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DWMAC_GENERIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RDS_RDMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NUMA_BALANCING: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_DESIGNWARE_BAYTRAIL: ::std::os::raw::c_uint = 1;
pub const CONFIG_THINKPAD_ACPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_P54_COMMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_APPARMOR_HASH: ::std::os::raw::c_uint = 1;
pub const CONFIG_SHMEM: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_PPP: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MIGRATION: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_ARCH_JUMP_LABEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_PCA9532_GPIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_C6XDIGIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_BLOCK_MINORS: ::std::os::raw::c_uint = 8;
pub const CONFIG_IIO_SSP_SENSORS_COMMONS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_HSO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_PRIMAX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DECOMPRESS_LZMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI_IOV: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_IIO_HWMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KVM_EVENTFD: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8776_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_VIPERBOARD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEVTMPFS_MOUNT: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_DEVFREQ_EVENT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_DSP_LOADER: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_AMC6821_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_SI476X_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_IPHETH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_TI_AM335X_TSC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_850_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_CX22700_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DNOTIFY: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DAS800_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CTS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_LM8333_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_TELES_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_USB_PODHD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDD: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_UMT_010_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SUNGEM_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_DB9_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IMA_TRUSTED_KEYRING: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_R9701_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_UFSHCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_MOUSEDEV: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_NET_UTILS: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_RADEON_BACKLIGHT: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIBERTAS_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ISP1362_HCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MC13XXX_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_WM831X_ON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATA: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_SUNKBD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_CS42XX8_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_PALMAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_TPS40422_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_MAX730X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_WM8994_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_3C589_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_WM9712: ::std::os::raw::c_uint = 1;
pub const CONFIG_CEPH_LIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REMOTEPROC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_LP3943_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_ELSA_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_MF6X4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ND_BTT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_MCE_LOG: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_437: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_ARCH_SOFT_DIRTY: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_IDS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HYPERV_KEYBOARD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_DA9052_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NATSEMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MCS_FIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_PROC_KCORE_TEXT: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CLS_U32_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MISDN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXPORTFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_UBI_WL_THRESHOLD: ::std::os::raw::c_uint = 4096;
pub const CONFIG_FB_TFT_WATTEROTT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_MAX8907_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD525X_DPOT_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_RICOH_MMC: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SENSOR_HUB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_MIXER_OSS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_PENMOUNT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_MATCH_MH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_EXTHDR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_INGRESS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_OSD_INITIATOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_ZORAN_DC30_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_S921_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_OSD_DPRINT_SENSE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MSI_WMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IT87_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LRU_CACHE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_CXGB3_ISCSI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_LP3972_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_DARLA24_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_MAX1619_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPW2200_MONITOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_AF9013_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_SYM53C500_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OLD_SIGSUSPEND3: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_DTV5100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCHEDSTATS: ::std::os::raw::c_uint = 1;
pub const CONFIG_IBMASR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_MOUSE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTLWIFI_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_ISER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SYS_IMAGEBLIT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_TVEEPROM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPS_CLIENT_PARPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEFXX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_HAS_SG_CHAIN: ::std::os::raw::c_uint = 1;
pub const CONFIG_SUNRPC_GSS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_TYPHOON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TIGON3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MA600_DONGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_THUNDERBOLT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CAST5_AVX_X86_64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM90_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETCONSOLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_INTF_SYSFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_BQ24257_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_SDHCI_ACPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCMA_DRIVER_GPIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_SPDIF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_RS5C372_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_EMATCH_U32_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_TOUCHWIN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_FREQ_GOV_COMMON: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_INITRD: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_EMI62_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43_PHY_N: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_IPS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_MCE_AMD: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_BUFIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_ALGOPCA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_GS_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_ATH3K_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_TRIGGER_TIMER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MCB_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_VIRTIO_GPU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMMON_CLK_PALMAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_M48T59_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8510_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2800_LIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXTCON_ADC_JACK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_X2APIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_TLV320AIC3X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_VESA: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEFAULT_SECURITY_APPARMOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_DEBUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_BLOWFISH_COMMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_RAREMONO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_INTEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_WM831X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_TPS65090_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUSION_LAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IXGBE_VXLAN: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_DW2102_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DRBG_HASH: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_PCMCIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_SANE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIO_PARKBD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_PCF857X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_OSSEMUL: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_ARCH_CLOCKSOURCE_DATA: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_SAHARA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOIM3232_DONGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IBM_RTL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_BPF_JIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_MOS7720_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XILLYBUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PREEMPT_NOTIFIERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_PVHVM: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_ARC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CT_PROTO_DCCP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ZLIB_INFLATE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_FUNCTIONFS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_V3020_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_AVM_A1_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TUA6100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_SHTC1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KVM_ASYNC_PF: ::std::os::raw::c_uint = 1;
pub const CONFIG_BMP280_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRC_T10DIF: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIBTUART_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7746_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMA8452_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_THERMAL_GOV_FAIR_SHARE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ENCRYPTED_KEYS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_QT1010_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_DYNAMIC_MINORS: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCH_CONST_T: ::std::os::raw::c_uint = 4;
pub const CONFIG_GPIO_WM831X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SSB_PCIHOST_POSSIBLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LCD_LMS283GF05_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HWMON: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD5791_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_GTT: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_PCF85063_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_DLINK: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_TWOFISH_COMMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DLCI_MAX: ::std::os::raw::c_uint = 8;
pub const CONFIG_AUDITSYSCALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIUART_3WIRE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_PHY: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_ACPI_CPUFREQ_CPB: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_ISO8859_2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_DA9052_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM63_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_PNP: ::std::os::raw::c_uint = 1;
pub const CONFIG_RC_DEVICES: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CRC32_PCLMUL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_VIDEO_CLASS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CLKBLD_I8253: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_NICSTAR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_ATY_GX: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_INTF_PROC: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_PICOLCD_FB: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_TI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCMGENET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_CBQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_VP27SMPX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_CLK: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_F_HID: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_USE_BUILTIN_BSWAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_DWC2_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_MOS7715_PARPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SERPENT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_SI2168_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_IDLE_GOV_MENU: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_EHSET_TEST_FIXTURE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_TINYLCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_FAN: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_FM801_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_PS2_SENTELIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_HYSDN_CAPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_FLEX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_MAX8925_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_MATROX_MYSTIQUE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CS5345_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_APPARMOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_DP83867_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_STACKTRACE_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_B44_PCI_AUTOSELECT: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_AF9035_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_AMPLC_PCI224_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_TIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_MAX3100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_LP8788_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_EMC1403_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RESET_CONTROLLER: ::std::os::raw::c_uint = 1;
pub const CONFIG_BNA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OUTPUT_FORMAT: &'static [u8; 13usize] = b"elf64-x86-64\x00";
pub const CONFIG_VIDEO_M52790_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_SYM53C8XX_2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_CXGB4_ISCSI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_HX8340BN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_SHT15_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_UHCI_HCD: ::std::os::raw::c_uint = 1;
pub const CONFIG_NVRAM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ISP1760_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_BQ24735_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LOCKD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_INTEL_SS4200_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_KMS_FB_HELPER: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CHIPIDEA_UDC: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_FIREDTV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_S5H1411_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CT_NETLINK_TIMEOUT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS3234_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOUND_OSS_CORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AIC79XX_REG_PRETTY_PRINT: ::std::os::raw::c_uint = 1;
pub const CONFIG_HFSPLUS_FS_POSIX_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2800USB_RT35XX: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SAVAGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIBERTAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HPET_MMAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_NTB_PINGPONG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_TV8532_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IO_DELAY_0XED: ::std::os::raw::c_uint = 1;
pub const CONFIG_LTE_GDM724X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_VMWGFX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_MICROCHIP: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFFS2_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_STE10XP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_REJECT_IPV6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SAITEK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8750_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_MT6397_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CASSINI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_WHCI_HCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_DH_ALUA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEXEC_VERIFY_SIG: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTRR: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_G_NCM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADIS16203_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_MC13XXX_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_RFCOMM_TTY: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIBFCOE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_UDP_TUNNEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEGRITY_SIGNATURE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_MAX8997_HAPTIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RPCSEC_GSS_KRB5_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_EATA_LINKED_COMMANDS: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEOBUF_VMALLOC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_LP8788_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_CFI_UTIL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NO_HZ_IDLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ISP1761_UDC: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_CS4271_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_MAC_ROMANIAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_LX6464ES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_ADAPTEC: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_PCF8591_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_STV0299_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPW2200_RADIOTAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SSB_B43_PCI_BRIDGE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACER_WMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KXSD9_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_TWL4030_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_AN2720: ::std::os::raw::c_uint = 1;
pub const CONFIG_F2FS_STAT_FS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_UCD9200_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING: ::std::os::raw::c_uint = 1;
pub const CONFIG_MLX4_DEBUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_BSD_PROCESS_ACCT: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_STRING_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SSB_DRIVER_PCICORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_TABLET: ::std::os::raw::c_uint = 1;
pub const CONFIG_88EU_AP_MODE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SENSOR_IIO_TRIGGER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SST_MFLD_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_MAX2165_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_N_HDLC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_CFI_INTELEXT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DRBG_HMAC: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_LANAI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LLC2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_WINBOND_CIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HPET_EMULATE_RTC: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_SERIAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_MPPARSE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_SILAN: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_UCD9000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_OXYGEN_LIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DLM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_ARC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_STK8312_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_CC770_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_BPF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_GOTOP: ::std::os::raw::c_uint = 1;
pub const CONFIG_EEEPC_LAPTOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_6LOWPAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STORAGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAG3110_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HMC6352_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_BROADCOM: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_FSL_LPUART_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PERCPU_RWSEM: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_PCTV452E_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_VES1820_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_CPU_AUTOPROBE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BAYCOM_SER_HDX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SEED_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCHED_MC: ::std::os::raw::c_uint = 1;
pub const CONFIG_DELL_RBU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ALTERA_MBOX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_SAS_ATA: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7266_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_LABPC_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_DS2782_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_FREQ_GOV_PERFORMANCE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_LIRC_CODEC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_ICH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EFI: ::std::os::raw::c_uint = 1;
pub const CONFIG_RATIONAL: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_MUX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DONGLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_MV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TS2020_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AGP_AMD64: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_SETUP_PER_CPU_AREA: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_ISP1704_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYSTEM_TRUSTED_KEYRING: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_QM1D1C0042_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WATCHDOG_CORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_FSL_SPDIF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_SIMPLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_EARLY_IOREMAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TUNER_DIB0090_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI_XEN: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_RTSX_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_USB_AUDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LCD_AMS369FG06_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IEEE802154_ATUSB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCNET_CAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_ZORAN_ZR36060_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX231XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_WILINK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPEAKUP_SYNTH_TXPRT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X25_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SENSOR_INCLINOMETER_3D_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_TCP_CONG_YEAH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_IEEE802154_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DA9063_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SENSOR_CUSTOM_SENSOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_QLA_FC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TELCLOCK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I40EVF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_AMPLC_PC263_ISA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IO_DELAY_TYPE_0XED: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_UNIOXX5_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_IDE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_LC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_DWC3_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_APPLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SERPENT_AVX2_X86_64_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_MEDIA_TUNER_TDA827X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VMXNET3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INIT_ENV_ARG_LIMIT: ::std::os::raw::c_uint = 32;
pub const CONFIG_SND_RAWMIDI_SEQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_ARP_MANGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_WUSB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_TPS65218_PWRBUTTON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_SSD1306_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_P54_LEDS: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_88PM860X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_MAX34440_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_G760A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RDS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AK09911_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_ATBM8830_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_EFAR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOLTEK_FF: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_MPU3050_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EEPROM_93XX46_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DYNA_PCI10XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATL2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USER_NS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_USER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_PPTP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_SUP_INTEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCP_CONG_CDG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_ZL10036_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX231XX_ALSA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_DA9150_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HFSPLUS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TMPFS_POSIX_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADM9240_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEBUG_SET_MODULE_RONX: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CAFE_CCIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_USB_UA101_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_APEI_PCIEAER: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETLINK_DIAG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_KS0108_PORT: ::std::os::raw::c_uint = 888;
pub const CONFIG_SCSI_AIC7XXX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CONTEXT_SWITCH_TRACER: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC80211_HAS_RC: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATMAN_ADV_BLA: ::std::os::raw::c_uint = 1;
pub const CONFIG_KDB_KEYBOARD: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_SSM2602_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LOGIWHEELS_FF: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_INA209_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SL811_HCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OCFS2_FS_O2CB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MDIO_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CAST6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_6LOWPAN_NHC_UDP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_EMATCH_META_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I7300_IDLE_IOAT_CHANNEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_AUO_K1901_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KS8842_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_IPR_DUMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_MASTER_DS1WM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I40E_DCB: ::std::os::raw::c_uint = 1;
pub const CONFIG_PANTHERLORD_FF: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_DIOLAN_U2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_CS46XX_NEW_DSP: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAIF_HSI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_RIVA_BACKLIGHT: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_ISA_DMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_PN544_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_MAX8903_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_LCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMCG: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCS3414_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_MENF21BMC_HWMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_SYSTOHC_DEVICE: &'static [u8; 5usize] = b"rtc0\x00";
pub const CONFIG_SENSORS_DS620_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EVM_EXTRA_SMACK_XATTRS: ::std::os::raw::c_uint = 1;
pub const CONFIG_V4L_MEM2MEM_DRIVERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_BMP085_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_SPEEDSTEP_CENTRINO: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_TPS65912_SPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_HASH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_IRC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NOUVEAU_DEBUG_DEFAULT: ::std::os::raw::c_uint = 3;
pub const CONFIG_SENSORS_GPIO_FAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_AAT2870_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_NS87410_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_SPECTRUM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_L2TP_IP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RADIO_SI476X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_REDBOOT_PARTS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE: ::std::os::raw::c_uint = 0;
pub const CONFIG_MTD_UBI_FASTMAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_TLV320AIC23_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STV06XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPP_DEFLATE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USELIB: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_DA903X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VGA_SWITCHEROO: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ISP1301_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_DA9052_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IRQ_REMAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_PT3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TEXTSEARCH_KMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA28XA: ::std::os::raw::c_uint = 1;
pub const CONFIG_FMC_WRITE_EEPROM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_AMPLC_PC263_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_MAESTRO3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_SLAVE_SMEM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VT: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_NET1080_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_STK3310_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_F71805F_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SUNRPC_DEBUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CLASSIFY_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_HID_TIVO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_ICADE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI_ATS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MISDN_IPAC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_KTTI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_F2FS_FS_SECURITY: ::std::os::raw::c_uint = 1;
pub const CONFIG_MACB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_CODEC_CIRRUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGMAP_SPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_UNISYSSPAR: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_BREDR: ::std::os::raw::c_uint = 1;
pub const CONFIG_DMA_ACPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_HEXIUM_GEMINI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXTCON_SM5502_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CB710_DEBUG_ASSUMPTIONS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPLIT_PTLOCK_CPUS: ::std::os::raw::c_uint = 4;
pub const CONFIG_USB_R8A66597_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_DRV2665_HAPTICS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_E752X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MSPRO_BLOCK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TUNER_ITD1000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_POWER_SUPPLY: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_PERSISTENT_DATA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_VIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DAVICOM_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_UFSHCD_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCTP_COOKIE_HMAC_MD5: ::std::os::raw::c_uint = 1;
pub const CONFIG_CIFS_XATTR: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEXEC_JUMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADM1275_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_DMAENGINE_PCM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_PCA_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_NFQUEUE_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_SECURITY_SELINUX_BOOTPARAM: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_8DEV_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_INPUT_BEEP: ::std::os::raw::c_uint = 1;
pub const CONFIG_WEXT_CORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_DESIGNWARE_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_MR97310A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RANDOMIZE_BASE_MAX_OFFSET: ::std::os::raw::c_uint =
    1073741824;
pub const CONFIG_DVB_HOPPER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_IRQ_CHIP: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_THERMAL_REL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETLABEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_WM8775_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CALGARY_IOMMU: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_TIMEOUT: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_SCH311X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_PCAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_PALMAS_PWRBUTTON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_V4L2_FLASH_LED_CLASS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_ARIZONA: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_COBALT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_HASH_IPPORTNET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CDROM_PKTCDVD_BUFFERS: ::std::os::raw::c_uint = 8;
pub const CONFIG_SCHED_AUTOGROUP: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PCL730_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_TPS65912_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_SPIDEV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_CAMERA_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_PRISM2_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADM8211_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_WM8997: ::std::os::raw::c_uint = 1;
pub const CONFIG_HWPOISON_INJECT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NTB_TOOL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_ILI9325_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8188EE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_SECMARK_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_HID_MAGICMOUSE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_COUNTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_AK4554_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_TDA9840_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET_UDP_DIAG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_SDR_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_ACM: ::std::os::raw::c_uint = 1;
pub const CONFIG_RAPIDIO_ENUM_BASIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_SAVE_RESTORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_ETURBO: ::std::os::raw::c_uint = 1;
pub const CONFIG_DELL_LAPTOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPPOE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CRCT10DIF_PCLMUL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WL1251_SDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI_REALLOC_ENABLE_AUTO: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_INTEL_PSTATE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_LAYLA24_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ZONE_DMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX25821_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SPCA508_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_LEGOTOWER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_IPV6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_ROBOTFUZZ_OSIF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_DATAFLASH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_DRX39XYJ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_MB862XX_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_QLCNIC_HWMON: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIRC_SIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_I2C_OPREGION: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_TELESPCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DIVERSION_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_DIBUSB_MC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_CBUS_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_VP702X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_CC770_ISA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_OWNER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_WM8994_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_SIS5595_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SUN_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_TARGET_ECN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_GINA24_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_NXP_NCI_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MD_FAULTY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYN_COOKIES: ::std::os::raw::c_uint = 1;
pub const CONFIG_REED_SOLOMON_DEC8: ::std::os::raw::c_uint = 1;
pub const CONFIG_IRQ_WORK: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH9K_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI_MSI: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_ADVANCED_ROUTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_MISDN_NETJET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCNET_COM20020_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_CB_PCIDDA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_USBVISION_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SYS_COPYAREA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_64_SMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_EHCI_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_CYPRESS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CLEANCACHE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_BITBANG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_MT2063_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STORAGE_ALAUDA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_FUJITSU: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_GRIP_MP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPARSEMEM_EXTREME: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_SLAVE_DS2406_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B44_PCICORE_AUTOSELECT: ::std::os::raw::c_uint = 1;
pub const CONFIG_IWLWIFI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AB3100_OTP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_COMMON: ::std::os::raw::c_uint = 1;
pub const CONFIG_CYPRESS_FIRMWARE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADM1031_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TASK_XACCT: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCNET_1051_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_TDA18271_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_BITMAP_PORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_IPTABLES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LZ4_COMPRESS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KVM_VFIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_AB3100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_HSIC_USB3503_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_PCC_CPUFREQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_QFMT_V1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_IX2505V_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_ZYTRONIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_TEKRAM_DONGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_HORIZON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SONICVIBES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FIXED_PHY: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHELSIO_T4_FCOE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_SP2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_ACPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_MAX8998: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_DEFCONFIG: &'static [u8; 34usize] =
    b"arch/x86/configs/x86_64_defconfig\x00";
pub const CONFIG_SENSORS_TMP103_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_MAC_GAELIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_FREQ_GOV_USERSPACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FTRACE_SYSCALLS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_CA0106_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_VIA_CAMERA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LOG_CPU_MAX_BUF_SHIFT: ::std::os::raw::c_uint = 12;
pub const CONFIG_SOC_CAMERA_RJ54N1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SAA6752HS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DIVAS_MAINT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC80211_RC_MINSTREL_VHT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_BLK_DEV_DM_BUILTIN: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA18X: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_FL512_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_IPW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_PIIX4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_I7300_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_HCD_SSB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_SOC_DTS_THERMAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCNET_COM20020_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET_IPCOMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_FSCHMD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VGA_ARB_MAX_GPUS: ::std::os::raw::c_uint = 16;
pub const CONFIG_DVB_USB_DIB0700_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_FUJITSU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MCP2120_DONGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_BLKDEV_BACKEND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_PINCONF: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_NICCY: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_PEAK_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FMC_TRIVIAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIBLUECARD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_X25: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFFS2_FS_XATTR: ::std::os::raw::c_uint = 1;
pub const CONFIG_XILLYBUS_PCIE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EVENT_TRACING: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_INTEL_LPSS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ENS1370_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CADENCE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7476_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ASYNC_PQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_KEYTOUCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_CYPRESS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_N_GSM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_LIMIT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_KMS_HELPER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_IPOCTAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPW2200_PROMISCUOUS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MLX4_EN_VXLAN: ::std::os::raw::c_uint = 1;
pub const CONFIG_TRACE_SINK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OCFS2_FS_USERSPACE_CLUSTER_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB: ::std::os::raw::c_uint = 1;
pub const CONFIG_HYSDN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADL_PCI9111_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATA_OVER_ETH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_PLUSB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SAA711X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8192C_COMMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_PWM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_WM831X_SPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM95234_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEN_A21_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PREEMPT_VOLUNTARY: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_BUDGET_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_ISO8859_1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_WM8400: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_INTEL_VR_NOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_WORKQUEUE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_WDT87XX_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MACINTOSH_DRIVERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADE7754_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ALX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CIFS_FSCACHE: ::std::os::raw::c_uint = 1;
pub const CONFIG_R8169_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_BH1780_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCP_CONG_HYBLA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI_STUB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DRBG_CTR: ::std::os::raw::c_uint = 1;
pub const CONFIG_NCPFS_NFS_NS: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_I2C_NXP_TDA998X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_KENSINGTON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_GENERIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_EHCI_HCD: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_DS2760_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TEXTSEARCH_BM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_HMC5843_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_BQ25890_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CIFS_SMB2: ::std::os::raw::c_uint = 1;
pub const CONFIG_8139TOO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFS_SECURITY: ::std::os::raw::c_uint = 1;
pub const CONFIG_AFS_FSCACHE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_PDAUDIOCF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_MAC_INUIT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIUART_LL: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_ZYDACRON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_LP8755_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPP_MPPE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_CALC_BITTIMING: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SENSOR_ACCEL_3D_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DE2104X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMORY_HOTPLUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_SEDLBAUER_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_PCM_OSS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_B2C2_FLEXCOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_SR9700_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOTPLUG_PCI_ACPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_ZPODD: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_IRDA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RFKILL: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_TVP5150_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_FC0012_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETDEVICES: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_KEY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SMS_SIANO_MDTV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_CONTEXT_TRACKING: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_TARGET_HL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IOSCHED_DEADLINE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DLCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_IDT77252_USE_SUNI: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_OPL3_LIB_SEQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CGROUP_FREEZER: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_UPD64083_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_ALTERA_JTAGUART_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EVENTFD: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DEV_PADLOCK_SHA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_MT9T112_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_DESIGNWARE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_CK804XROM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_PD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8192CE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WAN: ::std::os::raw::c_uint = 1;
pub const CONFIG_VLAN_8021Q_MVRP: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8821AE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FS_POSIX_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPV6_SIT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_TPS65912_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XFRM: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_K8TEMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEFCONFIG_LIST: &'static [u8; 36usize] =
    b"/lib/modules/$UNAME_RELEASE/.config\x00";
pub const CONFIG_ASYNC_TX_DMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DAS16_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAIF_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_HAS_PMEM_API: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_UAC2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KPROBES_ON_FTRACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_HASH_IP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_YENTA_TOSHIBA: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_MR800_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_AS5011_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AIRO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NETtel_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_VX855_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_8250_CONSOLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_OV6650_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPV6_MULTIPLE_TABLES: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ANNOUNCE_NEW_DEVICES: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_WHITEHEAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CLS_ROUTE4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JUMP_LABEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_FMVJ18X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_QT1070_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_KEMPLD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET2272_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OVERLAY_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_HASH_NETPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCG_INFINEON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH9K_HTC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_DH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8753_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRCMFMAC_PROTO_MSGBUF: ::std::os::raw::c_uint = 1;
pub const CONFIG_AX25_DAMA_SLAVE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD5380_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2800PCI_RT3290: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_MEM2MEM_DEINTERLACE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RADIO_WL128X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_TARGET_MASQUERADE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AIC79XX_RESET_DELAY_MS: ::std::os::raw::c_uint = 5000;
pub const CONFIG_ARCNET_COM20020_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TORTURE_TEST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_AAT2870_CORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_SELINUX_DISABLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_BROADCAST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_LZ4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ECRYPT_FS: ::std::os::raw::c_uint = 1;
pub const CONFIG_PROC_PAGE_MONITOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_ECM: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_MAX8907_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_8250_EXTENDED: ::std::os::raw::c_uint = 1;
pub const CONFIG_GAMEPORT_FM801_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KS959_DONGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_MAGELLAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7887_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7780_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FTL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IGB_HWMON: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_BCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_CACHE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_R820T_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_SPI_NOR_USE_4K_SECTORS: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPMI_DEVICE_INTERFACE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BPF: ::std::os::raw::c_uint = 1;
pub const CONFIG_9P_FS_POSIX_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_KINGSUN_DONGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_PROTO_DCCP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SH_VEU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADM1021_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK: ::std::os::raw::c_uint
          =
    1;
pub const CONFIG_C2PORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EVM_ATTR_FSUUID: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_DELAY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_CMOV: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_CH341_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SENSOR_IIO_COMMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_FTDI_ELAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_HOTPLUG_CPU: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_ZORAN_AVS6EYES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_TRACE_RTC: ::std::os::raw::c_uint = 1;
pub const CONFIG_RD_LZO: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADDI_APCI_1564_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_FRIIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFFS2_FS_SECURITY: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_G_NOKIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_HASH_IPPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAIF_TTY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_SHT21_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_IOWARRIOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDSP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_DA9052_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIO_CT82C710_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OPENVSWITCH_GENEVE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USBPCWATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MODULE_SIG_ALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_EZUSB_FX2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_USB_TONEPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIMAX_I2400M_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_USB_USX2Y_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_SPI_ATTRS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_EPATC8: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_CYBER2000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCMA_DRIVER_GMAC_CMN: ::std::os::raw::c_uint = 1;
pub const CONFIG_GREENASIA_FF: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_HPSA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MICROCODE_AMD: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPEAKUP_SYNTH_ACNTSA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RAPIDIO_TSI721_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_KORG1212_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_VIA_CPUTEMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_SECMARK: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DRV_GIGASET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GP2AP020A00F_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHELSIO_T3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_OV7640_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MICROCODE_INTEL_EARLY: ::std::os::raw::c_uint = 1;
pub const CONFIG_INSTRUCTION_DECODER: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SHA512: ::std::os::raw::c_uint = 1;
pub const CONFIG_PHONET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MWIFIEX_PCIE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_C_CAN_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TRUSTED_KEYS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_AC97_BUS: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_MGA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_CLASS_DEVICE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43_HWRNG: ::std::os::raw::c_uint = 1;
pub const CONFIG_VHOST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_M5602_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2X00_LIB_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_EXAR: ::std::os::raw::c_uint = 1;
pub const CONFIG_UIO_MF624_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WM8350_POWER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_DLN2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_CMA3000_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_NULL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_AF9005_REMOTE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43_PHY_G: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_SEEQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_DEFRAG_IPV4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USER_RETURN_NOTIFIER: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_IOMMU_FLOPPY_WA: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_IDMOUSE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SELECT_MEMORY_MODEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64_MODULE:
          ::std::os::raw::c_uint =
    1;
pub const CONFIG_MISDN_INFINEON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET_XFRM_MODE_BEET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_LCPOWER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIRTIO_CONSOLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_ELAN_I2C_SMBUS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_MRVL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_APEI_EINJ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PERSISTENT_KEYRINGS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_ACT_CONNMARK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ES1938_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_DEBUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_TW9906_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_BUDGET_AV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPV6_ROUTE_INFO: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_WM8350_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_ADVANCED: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DEFLATE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_STRNLEN_USER: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_WM8350: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_APPLEDISPLAY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KLSI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_TCPMSS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DA9063_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IGB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_CFI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PGTABLE_MAPPING: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_USBDUXSIGMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_IPCOMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPV6_ROUTER_PREF: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFFS2_FS_DEBUG: ::std::os::raw::c_uint = 0;
pub const CONFIG_BT_HCIBTSDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_QXL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SLIP_COMPRESSED: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_JITTERENTROPY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_STE_MODEM_RPROC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NTB_INTEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_VX_LIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_MPOA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_L2TP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_ARIZONA_HAPTICS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_SWITCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ROCKETPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_GCM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_INDIGOIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NE2K_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_SYNAPTICS_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCTPPROBE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_NETLINK_LOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PWM_LPSS_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PINCTRL_CHERRYVIEW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_ISO8859_14_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_PHRAM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAGIC_SYSRQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_88PM860X: ::std::os::raw::c_uint = 1;
pub const CONFIG_CROS_EC_CHARDEV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_F_FS: ::std::os::raw::c_uint = 1;
pub const CONFIG_E100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_TPS6586X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_THERMAL_EMULATION: ::std::os::raw::c_uint = 1;
pub const CONFIG_DMI: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPV6_SIT_6RD: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIL6210_TRACING: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARPORT_SERIAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_DICE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PNFS_BLOCK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_RDC: ::std::os::raw::c_uint = 1;
pub const CONFIG_MACHZ_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PGTABLE_LEVELS: ::std::os::raw::c_uint = 4;
pub const CONFIG_MFD_CROS_EC_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPUSETS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_MARK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_MATROX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_PVRUSB2_SYSFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUNCTION_PROFILER: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC80211_RC_DEFAULT_MINSTREL: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPARSE_IRQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_AMPLC_PC236_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_LGS8GXX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DGNC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP_MODULE:
          ::std::os::raw::c_uint =
    1;
pub const CONFIG_SND_SOC_INTEL_BYT_MAX98090_MACH_MODULE:
          ::std::os::raw::c_uint =
    1;
pub const CONFIG_INPUT_IDEAPAD_SLIDEBAR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SSFDC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_MANGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TIFM_7XX1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_MASS_STORAGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_PICOLCD_LEDS: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_CB_DAS16_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS1286_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FCOE_FNIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_SMARTCONNECT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH10K_DEBUGFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCM_KONA_USB2_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOXA_INTELLIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_MCS5000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_VES1X93_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_ILI9341_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_UDL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITYFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIBERTAS_MESH: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_S5M_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RCU_STALL_COMMON: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_PCIDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_DEBUGFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_SUP_AMD: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_SIRF_AUDIO_CODEC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET6_XFRM_MODE_TUNNEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_INTEL_QUARK_I2C_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_VLAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCIEPORTBUS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_SUPPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_F75375S_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEBUG_BUGVERBOSE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_CUSTOM_DSDT_FILE: &'static [u8; 1usize] = b"\x00";
pub const CONFIG_NCPFS_OS2_NS: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_FILTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_ZEROPLUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REED_SOLOMON_DEC16: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_MC13783_ADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_SX4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC802154_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IBM_ASM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_OV772X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_LENGTH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_PKTTYPE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SENSOR_GYRO_3D_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_8255_SA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MODULES_TREE_LOOKUP: ::std::os::raw::c_uint = 1;
pub const CONFIG_FAT_FS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_CODEC_CA0132_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FCOE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_SJA1000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AUFS_BDEV_LOOP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_INTEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TEXTSEARCH_FSM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MISDN_DSP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM75_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PANEL_PROFILE: ::std::os::raw::c_uint = 5;
pub const CONFIG_INFINIBAND_CXGB4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LSI_ET1011C_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_SEDLBAUER: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_RAW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPEAKUP_SYNTH_SOFT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_EC168_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ZD1201_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS1742_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET_TUNNEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_INTERNODE_CACHE_SHIFT: ::std::os::raw::c_uint = 6;
pub const CONFIG_CRYPTO_SERPENT_SSE2_X86_64_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_NF_LOG_ARP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DEV_PADLOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_PMBUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EEPROM_93CX6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_WM8350_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_9P_VIRTIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PINCONF: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_DA9052_SPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_CHECK_BIOS_CORRUPTION: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_BLOCK_BOUNCE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MLX4_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK: ::std::os::raw::c_int = -1;
pub const CONFIG_SND_MIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_STK1160_AC97: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS: ::std::os::raw::c_uint = 1;
pub const CONFIG_ROMFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IOSCHED_CFQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_OID_REGISTRY: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_88PM805_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PHY_PXA_28NM_HSIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_DTT200U_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CIFS_UPCALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_THUNDER_NIC_PF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RWSEM_XCHGADD_ALGORITHM: ::std::os::raw::c_uint = 1;
pub const CONFIG_RADIO_TEA575X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DSCC4_PCISYNC: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_EPIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIB80211_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_CORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KERNEL_XZ: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_AMPLC_PC236_ISA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CXACRU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_GMA3600: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_PKG_TEMP_THERMAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RAID_ATTRS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RFKILL_LEDS: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIBTUSB_BCM: ::std::os::raw::c_uint = 1;
pub const CONFIG_CONSOLE_TRANSLATIONS: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_CMD64X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_CFI_STAA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_SUPPORTS_ATOMIC_RMW: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCG_CRB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PUBLIC_KEY_ALGO_RSA: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_AD5398_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_STOP_MACHINE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_UVC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RAID6_PQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SBC_FITPC2_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HW_RANDOM_TIMERIOMEM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_IPGRE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADT7316_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIBERTAS_SDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DEV_QAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUSION: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTDRAM_TOTAL_SIZE: ::std::os::raw::c_uint = 4096;
pub const CONFIG_VIDEO_TEA6420_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SWIOTLB_XEN: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_IP6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_SNMP_BASIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_LOAD_CIS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_EARLYCON: ::std::os::raw::c_uint = 1;
pub const CONFIG_CLS_U32_MARK: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_CX24120_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ICE1712_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_MAX8925_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_AKCIPHER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIBERTAS_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_ACARD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_SIGMADSP_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_TRIGGER_BACKLIGHT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_ZORAN_LML33_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_FREQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_OHCI_HCD: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIA_RHINE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOSTAP_FIRMWARE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VHOST_RING_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_MIRROR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_BLOWFISH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DUMMY_CONSOLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AIC7XXX_DEBUG_MASK: ::std::os::raw::c_uint = 0;
pub const CONFIG_SCSI_GDTH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DAS08_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_ASCII_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RFKILL_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_DA9055_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_G_PRINTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_GRIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BAYCOM_SER_FDX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_ALTERA_CI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_REJECT_IPV4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_M41T94_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP1000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD_SIGMA_DELTA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIMAX_DEBUG_LEVEL: ::std::os::raw::c_uint = 8;
pub const CONFIG_SND_SOC_FSL_SSI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BPF_EVENTS: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_HEXIUM_ORION_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_MEI_ME_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_QIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_6LOWPAN_NHC_MOBILITY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_RIO500_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LAPBETHER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SI4713_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_SVW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TRACE_IRQFLAGS_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD5360_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IEEE802154_MRF24J40_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_SYSCON: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_PHYSMAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MS5611_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_V3_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_HDLC_X25_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFTL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GAMEPORT_L4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADT7462_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DETECT_HUNG_TASK: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_FRIQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MAX14577_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_NCT7802_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_MCP251X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CCM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCP_CONG_ADVANCED: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CLS_RSVP6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_HISI504_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_CDC_SUBSET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7152_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_RTL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMA9551_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KVM_GUEST: ::std::os::raw::c_uint = 1;
pub const CONFIG_GS_FPGABOOT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QFMT_V2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_S2255_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET_DCCP_DIAG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_DA9063_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCNET_COM90xxIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNMARK_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_ATH9K_HW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_CGROUP: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_MCT_U232_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UIO_PDRV_GENIRQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIBT3C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_TRIGGERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_FOU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIMAX_I2400M_DEBUG_LEVEL: ::std::os::raw::c_uint = 8;
pub const CONFIG_CRYPTO_RNG: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_GARMIN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_MASTER_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RAW_DRIVER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_ESB2ROM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XFS_QUOTA: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ISA_DRIVERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_COBRA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VME_PIO2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH10K_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_SMACK: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_ATM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WINBOND_840_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_3W_9XXX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_KS0127_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MVMDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_USB: ::std::os::raw::c_uint = 1;
pub const CONFIG_LOGIG940_FF: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEOBUF2_MEMOPS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RD_GZIP: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_E2I: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_HAS_CPU_RELAX: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_REGS_AND_STACK_ACCESS_API: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCMA_HOST_PCI_POSSIBLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_TFA9879_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LTC4261_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_SDRICOH_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MISDN_W6692_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIRC_BT829_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_THRUSTMASTER_FF: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_DELL_NETBOOKS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TREE_RCU: ::std::os::raw::c_uint = 1;
pub const CONFIG_PWM_SYSFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_FBTFT_DEVICE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_TI: ::std::os::raw::c_uint = 1;
pub const CONFIG_ALLOW_DEV_COREDUMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_MUX_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SWIOTLB: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_USB_CAIAQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STORAGE_CYPRESS_ATACB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXT4_FS_SECURITY: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPEAKUP_SYNTH_DUMMY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_APPARMOR_HASH_DEFAULT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_MVUMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_TEAM_MODE_ACTIVEBACKUP_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_9P_FS_SECURITY: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_MT9M111_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_XMP_DECODER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN: ::std::os::raw::c_uint = 1;
pub const CONFIG_BEFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ALI5451_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI_MSI_IRQ_DOMAIN: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_USER_MAD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_ROCCAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_HP: ::std::os::raw::c_uint = 1;
pub const CONFIG_F71808E_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET_XFRM_MODE_TRANSPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_MD5: ::std::os::raw::c_uint = 1;
pub const CONFIG_IMA_DEFAULT_TEMPLATE: &'static [u8; 7usize] = b"ima-ng\x00";
pub const CONFIG_VIDEO_CS53L32A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_REDRAT3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_VICAM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_AD7879_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_HERMES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TRANSPARENT_HUGEPAGE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_SS_LB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISCSI_TCP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATA_ACPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFSD_V3: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_ALI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_EXTENDED_PLATFORM: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_MPP: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_JANZ_TTL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE: ::std::os::raw::c_uint = 0;
pub const CONFIG_USB_CHIPIDEA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_WL1273_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2800USB_RT53XX: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_ARCH_KMEMCHECK: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ECHO3G_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_FC0011_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_PROCESSOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_SCRUB_PAGES: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TDA10023_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_TEA5767_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATMAN_ADV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DRV_AVMB1_AVM_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_REDIR_IPV6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KVM: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_FIREWIRE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEOBUF_DVB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PCMDA12_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCCARD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_OV519_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BMP085_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_LOG_WRITES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BINFMT_ELF: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_RX4581_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CLS_FLOWER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_PROC_FS: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_PG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_HID_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MD_RAID456_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_PCF50633_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_TRIGGER: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_AUO_K190X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_IFORCE_USB: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCHED_TRACER: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTS5208_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DSCC4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CICADA_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UDF_NLS: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_STINGER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_PERF_REGS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CIFS_DEBUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KVM_MSI: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_ANALOG_TV_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_PIMSM_V1: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCACHE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET6_AH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT: ::std::os::raw::c_uint =
    1;
pub const CONFIG_SENSORS_MAX197_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TARGET_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AUFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_XINMO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VLSI_FIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_V4_SECURITY_LABEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX88_ALSA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_ALTEON: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_GL518SM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_MON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_CB_PCIMDAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VGASTATE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_FIXED_VOLTAGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LCD_L4F00242T03_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_RENESAS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SIGMATEL_FIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SAA717X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYS: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_TPS6507X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BE2ISCSI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET_XFRM_TUNNEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_FM3130_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_EFI: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_RTSX_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPMI_POWEROFF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_VMASTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MARK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XTABLES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_LBLC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_NULL_BLK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ISP1760_HCD: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_OPERA1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_ECHAINIV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_ARCH_AUDITSYSCALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_BD2802_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_MC13783_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_STOWAWAY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_RIVA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SLABINFO: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_HE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_POWER_AVS: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPMI_SI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_QCOM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STORAGE_DATAFAB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_AF9005_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_RBTREE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_RC5T583: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCP_CONG_VEGAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_88PM860X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_USER_API_HASH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TIMER_STATS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_IBMPEX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BOOT_PRINTK_DELAY: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_88PM860X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IWLMVM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADM1026_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_NINJA32_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DEV_CCP_DD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADT7470_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_SLEEP_SMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_PXA2XX_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_PM3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_16BIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_HW: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC80211_RC_MINSTREL_HT: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_EG20T_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STORAGE_KARMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TTPCI_EEPROM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP4_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TEHUTI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PUNIT_ATOM_DEBUG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SIS900_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_MAGN_SPI_3AXIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCSPKR_PLATFORM: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_LIVEPATCH: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEGARAID_LEGACY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_AV7110_IR: ::std::os::raw::c_uint = 1;
pub const CONFIG_CARDBUS: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH9K_AHB: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ISL29018_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA19W: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_SSP_SENSORHUB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_GREENASIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ORINOCO_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_ILI210X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_ACPI_PROCESSOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEGRITY_ASYMMETRIC_KEYS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_RP2_NR_UARTS: ::std::os::raw::c_uint = 32;
pub const CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_8723AU_BT_COEXIST: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_DA903X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_POWERCLAMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DEFAULT_BUF_SIZE_KB: ::std::os::raw::c_uint = 2048;
pub const CONFIG_BIG_KEYS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_ST21NFCA_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_ADP5520_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_FSL_ESAI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SMS_USB_DRV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_AC: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_HOTPLUG_IOAPIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_STEELSERIES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFFS2_FS_WRITEBUFFER: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_MASTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_RA8875_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_OPTICON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8180_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IEEE802154_AT86RF230_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD5504_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_SC16IS7XX_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TC90522_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_NXT200X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM87_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SST_IPC_ACPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_THROTTLING: ::std::os::raw::c_uint = 1;
pub const CONFIG_VT_HW_CONSOLE_BINDING: ::std::os::raw::c_uint = 1;
pub const CONFIG_AIX_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_TEAM_MODE_BROADCAST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MPLS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_TABLES_NETDEV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_SMB347_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_TW9903_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH9K_CHANNEL_CONTEXT: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_ACT_GACT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SLIP_MODE_SLIP6: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8192E_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_GYRATION_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_AK4642_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IRDA_CACHE_LAST_LSAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SRAM: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_MASQ_IPV4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_WDM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_TOSHIBA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIBCM203X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_WM8400_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_THERMAL_HWMON: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_COMPOSITE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_MUX_PCA9541_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAX1363_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_USB_HIFACE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_EM28XX_DVB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KOBIL_SCT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HDLC_FR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_ATY128_BACKLIGHT: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_TOUPTEK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENEVE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XZ_DEC_X86: ::std::os::raw::c_uint = 1;
pub const CONFIG_MLX5_INFINIBAND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC80211_LEDS: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_JOYDEV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_MATROX_MAVEN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_LKKBD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TPROXY_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_HIBERNATE_CALLBACKS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEN_Z188_ADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_MC13783_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_8250_DW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_CS42L56_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_DCCP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIBIPW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FIREWIRE_OHCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCIEASPM_DEBUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMMON_CLK_S2MPS11_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ACM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADL_PCI9118_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_RTL8150_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_MAX7300_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_MSI2500_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRC16: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_SKY81452_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_AX8817X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_EMU10K1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_CALIBRATE_DELAY: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_GF128MUL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_ISO8859_6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CLS: ::std::os::raw::c_uint = 1;
pub const CONFIG_R8723AU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADF4350_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XFS_RT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SI7005_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_S626_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_INDIGO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AX25_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_YMFPCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TMPFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_LM3533_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOSTAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_OV5642_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_CT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ANON_INODES: ::std::os::raw::c_uint = 1;
pub const CONFIG_CADENCE_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_OHCI_HCD_PLATFORM: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8711_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_EM28XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_936_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAMACHI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXTCON_ARIZONA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ET131X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_ITE_CIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WCN36XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_BUDGET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUTEX: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_ANUBIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_AT_A2150_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_PNP_DHCP: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_LABPC_ISA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_HX8357D_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIRTIO_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SENSOR_ALS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MCP320X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MISDN_HFCMULTI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MWAVE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_3C574_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_AVM_A1_PCMCIA: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SQ930X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8192SE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_SPACEBALL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGMAP_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD5449_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_HAS_FAST_MULTIPLIER: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_MATRIXKMAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH9K_DEBUGFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_BCM590XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_CXD2099_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_REALTEK: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_SM501_GPIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_DM1105_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_RDC321X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD5421_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_XPAD_FF: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_HL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_LP8788_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEGARAID_SAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_HPT3X2N_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFSD_V2_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ME_DAQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_JANZ_ICAN3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET2280_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISL29003_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_USER_API_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_HCTOSYS: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_OCORES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NAU7802_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_NETWORK: ::std::os::raw::c_uint = 1;
pub const CONFIG_FMC_CHARDEV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_CORE_CONSOLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOTPLUG_PCI_CPCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_HUGETLB_PAGE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_SM_COMMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HW_RANDOM_TPM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CIFS_WEAK_PW_HASH: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_SMIPCIE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_GUNZE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM78_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_EMULEX: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIZNET_W5100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGMAP_IRQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_K10TEMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_HID_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_AF9015_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UBIFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_PT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TEST_USER_COPY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8192CU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_DRIVERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA28: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_TGR192_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_RBD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_HMC5843_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIO_PS2MULT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_TPS6105X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USER_STACKTRACE_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEGARAID_MAILBOX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LANMEDIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_TABLES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATMAN_ADV_MCAST: ::std::os::raw::c_uint = 1;
pub const CONFIG_IT8712F_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SLUB_DEBUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_M41T80_WDT: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIZNET_W5300_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_670X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_MD: ::std::os::raw::c_uint = 1;
pub const CONFIG_UCS2_STRING: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_VUB300_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_AIRCABLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_BITMAP_IP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_VX855_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC_EMUMOUSEBTN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RAPIDIO_CPS_XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_MTK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8978_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DECNET_NF_GRABULATOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_SBC_GXX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_NCI_SPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_RNDIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_INGRESS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DMADEVICES: ::std::os::raw::c_uint = 1;
pub const CONFIG_XENFS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AXP288_CHARGER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCA3000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_AACRAID_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MISDN_HFCUSB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_APEI_MEMORY_FAILURE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_LM3639_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_EVENTS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_PS2_ELANTECH: ::std::os::raw::c_uint = 1;
pub const CONFIG_PINCTRL: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SENSOR_DEVICE_ROTATION_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_IPV6_NDISC_NODETYPE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_MSM6242_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_TECHNISAT_USB2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI_LABEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_ZLIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_1251_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_MIDI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_X38_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FANOTIFY: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_MXL301RF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_BUTTERFLY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_CAPI_CAPIDRV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SONYPI_COMPAT: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_PROTO_SCTP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SP5100_TCO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNLABEL_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_SGETMASK_SYSCALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_SIL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ALTERA_STAPL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CGROUP_SCHED: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_RECONFIG: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_ADV7842_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QUEUED_RWLOCKS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYSVIPC: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_LABPC_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOSTAP_PLX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_PCOMP2: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_ECM_SUBSET: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_UBI_BLOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_DEBUG_KMEMLEAK: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_INTERACT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SMSC911X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DT282X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TDA10071_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HDLC_CISCO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MLX4_INFINIBAND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_OR51211_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2X00_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_863_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_DESIGNWARE_I2S_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADT7X10_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_G_HID_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_FTP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_SAVAGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_MRVL_UART_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHELSIO_T4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MODULES: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_MATCH_ECN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_PHONET: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GADGET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MAX8660_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EEPROM_LEGACY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_NES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_IMSTT: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SPCA506_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_CC770_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_ARTOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_NEWTON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HARDLOCKUP_DETECTOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX88_DVB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_DA9055_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_EM28XX_ALSA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_MXL5005S_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_TWL4030_VIBRA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_HIDDEV: ::std::os::raw::c_uint = 1;
pub const CONFIG_IOMMU_IOVA: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_IPOIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DUMMY_CONSOLE_COLUMNS: ::std::os::raw::c_uint = 80;
pub const CONFIG_SENSORS_APDS990X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ETH_RNDIS: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7606_IFACE_PARALLEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_SI21XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_WINBOND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOUND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_MASQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_RTI802_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_AUO_PIXCIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOLIET: ::std::os::raw::c_uint = 1;
pub const CONFIG_WLCORE_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_SC16IS7XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_VP7045_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET2272_DMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KPROBES_ON_FTRACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BNX2X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_TDA9887_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADVANTECH_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AUDIT_WATCH: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_TEA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD5624R_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_HIBERNATION_POSSIBLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KVM_APIC_ARCHITECTURE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_SI476X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_LME2510_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PROC_CHILDREN: ::std::os::raw::c_uint = 1;
pub const CONFIG_PDC_ADMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_VXPOCKET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_USB_LINE6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UNIX: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CATC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_DRIVERS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QNX6FS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NO_HZ_COMMON: ::std::os::raw::c_uint = 1;
pub const CONFIG_MINIX_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_MIPI_DSI: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRCMSMAC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_DEV_EVTCHN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_CLK: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_HASH2: ::std::os::raw::c_uint = 1;
pub const CONFIG_CARL9170_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_CODEC_CONEXANT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_LZ4HC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_CX24117_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_THERMAL_GOV_STEP_WISE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_RME9652_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_ABSENT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_88PM860X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEFAULT_HOSTNAME: &'static [u8; 7usize] = b"(none)\x00";
pub const CONFIG_SRCU: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMMON_CLK_SI5351_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_KOI8_R_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADT7410_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS: ::std::os::raw::c_uint = 2;
pub const CONFIG_THUNDER_NIC_VF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_HASH_NETPORTNET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SONIXB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_RTL28XXU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CARDMAN_4040_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_REALTEK_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STORAGE_ISD200_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_FREQ_GOV_POWERSAVE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_OV534_9_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RIONET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_TWOFISH_X86_64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_SMSC95XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRASH_DUMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_LM3533_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_ADDR_TRANS: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_IO_TRACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XPS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DEV_QAT_DH895xCC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_8255_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_ACT_SKBEDIT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADV_PCI1723_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET_ESP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_SELINUX_DEVELOP: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7816_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HPET_TIMER: ::std::os::raw::c_uint = 1;
pub const CONFIG_LCD_TDO24M_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCH_CONST_M: ::std::os::raw::c_uint = 14;
pub const CONFIG_LZ4_DECOMPRESS: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_GPIO_BEEPER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_HCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_MAX732X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HSI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_ZONES: ::std::os::raw::c_uint = 1;
pub const CONFIG_EFI_RUNTIME_MAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_IPV6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FONT_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADVISE_SYSCALLS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MD: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_ALGAPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_FDDI: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_VT8231_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_BUDGET_CI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_FIT3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_KE_COUNTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_I3200_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CEPH_FSCACHE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_KXTJ9_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_ADV7604_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BSD_PROCESS_ACCT_V3: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_WIZNET: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_DMX3191D_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_G_DBGP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CGROUP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TABLET_USB_GTCO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD2S90_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RAPIDIO_TSI57X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CYPRESS_CY7C63_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EEPROM_AT25_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RD_BZIP2: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_VIPERBOARD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WANT_DEV_COREDUMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_UINPUT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_ARC_NR_PORTS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CHECKSUM_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_CHARGER_TPS65090_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IOSF_MBI_DEBUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_POWER_RESET_RESTART: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_TRIGGER_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTLWIFI_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AUFS_BRANCH_MAX_127: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCG_ATMEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OVERLAY_FS_V1: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_MB86A16_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_SIMPLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_OXYGEN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_ATKBD: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_QLA_ISCSI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD5446_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_MEMBLOCK_NODE_MAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_PLATFORM_DEVICES: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_MAGN_I2C_3AXIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIBNVDIMM: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_IP_TUNNEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WANXL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_CFI_I1: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_PWM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_SLAVE_DS2780_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAX_RAW_DEVS: ::std::os::raw::c_uint = 256;
pub const CONFIG_UBIFS_FS_ZLIB: ::std::os::raw::c_uint = 1;
pub const CONFIG_W83877F_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WAFER_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_U132_HCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_UPD64031A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_88PM860X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_XIRCOM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_INTEGRITY: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_AZ6027_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_OKI: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_BCM5974_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_IDLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NTB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_RX51_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_ST21NFCA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_MATCH_RPFILTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_TABLES_INET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_COMMON: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHR_DEV_SCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_6LOWPAN_NHC_IPV6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_TABLES_IPV6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FAIR_GROUP_SCHED: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_HIH6130_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2800USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_BATTERY_SBS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_HASH: ::std::os::raw::c_uint = 1;
pub const CONFIG_AL3320A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIMAX_GDM72XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EFI_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_PROBE_EVENTS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SSB_PCMCIAHOST_POSSIBLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_AMSO1100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TRACE_CLOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCG_TIS_I2C_INFINEON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_CODEC_HDMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCMA_BLOCKIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_MODULE_SIG_HASH: &'static [u8; 7usize] = b"sha512\x00";
pub const CONFIG_PCI_BUS_ADDR_T_64BIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_LOG_BUF_SHIFT: ::std::os::raw::c_uint = 18;
pub const CONFIG_PATA_IT8213_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMORY_HOTREMOVE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_NOTIFIER_ERROR_INJECT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RAPIDIO_CPS_GEN2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_CMIPCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BH1750_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_WMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HPET: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_857_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_DSCP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_EMU10K1X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXTRA_FIRMWARE: &'static [u8; 1usize] = b"\x00";
pub const CONFIG_TCG_TPM: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_8390: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_WM5102: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPV6_MROUTE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_PCIDEV_BACKEND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PROC_EVENTS: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_VIDEO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIRT_TO_BUS: ::std::os::raw::c_uint = 1;
pub const CONFIG_VFAT_FS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_MUSB_PIO_ONLY: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_GYRO_SPI_3AXIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_I5000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PID_NS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MD_RAID1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADDI_APCI_2200_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_S2MPS11_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_VMAC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ACPI_POWER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEXEC: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_CMPC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RADIO_TEF6862_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRC32_SLICEBY8: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_DDC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_DA9150_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DAS08_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_LIBCOMPOSITE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_MPT2SAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HVC_XEN: ::std::os::raw::c_uint = 1;
pub const CONFIG_UWB_WHCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_WM9713: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_FQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_INTEL_HASWELL_MACH_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_VIDEO_HDPVR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OLD_BELKIN_DONGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_TPS65912: ::std::os::raw::c_uint = 1;
pub const CONFIG_ROMFS_ON_BLOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_AMD64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SB1000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_ARIZONA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HERMES_CACHE_FW_ON_INIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_SR: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_RMAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HWDEP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MODULE_SIG_SHA512: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_X32: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_CPU: ::std::os::raw::c_uint = 1;
pub const CONFIG_GIGASET_M101_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DIVAS_PRIPCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_LAYLA20_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_LOOP: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_BT8XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPMI_HANDLER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_LM3642_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B44_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEFAULT_HUNG_TASK_TIMEOUT: ::std::os::raw::c_uint = 120;
pub const CONFIG_SYSV_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIRTIO_PCI_LEGACY: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATMEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_THMC50_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_HIBERNATION_HEADER: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_OPTPROBES: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_FENTRY: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_AMBASSADOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_L2TP_ETH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADDI_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_ATIIXP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I8K_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_QLOGIC_1280_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DELL_SMO8800_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HYPERV_UTILS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYNCLINK_GT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CFQ_GROUP_IOSCHED: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_IRC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RAPIDIO_TSI568_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_60XX_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_XC2028_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_MISC: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_COMPRESS_OFFLOAD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_NUVOTON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_SCH5627_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADIS16080_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_AMD756_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UIO_PRUSS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_E1000E_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_LP8788: ::std::os::raw::c_uint = 1;
pub const CONFIG_MS5611_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DNET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CAST6_AVX_X86_64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_STV0288_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SL811_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MULTIUSER: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_PCAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SUSPEND: ::std::os::raw::c_uint = 1;
pub const CONFIG_SUNRPC_XPRT_RDMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_INTEL_SST_ACPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CROSS_MEMORY_ATTACH: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_ECC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CBC: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM93_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_ON20_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_CMTP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_ZORAN_LML33R10_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KS0108_DELAY: ::std::os::raw::c_uint = 2;
pub const CONFIG_VIDEO_CX88_VP3054_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_CONTROLLER: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_HMARK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_MMA8450_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MRP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I8253_LOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_SMSC_SCH311X_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AK8975_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AIC79XX_CMDS_PER_DEVICE: ::std::os::raw::c_uint = 32;
pub const CONFIG_IP6_NF_MATCH_RT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_IPR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_8250_RUNTIME_UARTS: ::std::os::raw::c_uint = 32;
pub const CONFIG_NS83820_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TSL4531_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_SIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KPROBES: ::std::os::raw::c_uint = 1;
pub const CONFIG_FS_MBCACHE: ::std::os::raw::c_uint = 1;
pub const CONFIG_T5403_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_JC42_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MD_MULTIPATH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DS1682_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_STK1160_COMMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_AS3711: ::std::os::raw::c_uint = 1;
pub const CONFIG_GFS2_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_TUA9001_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_CLASS: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TUNER_DIB0070_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NCPFS_NLS: ::std::os::raw::c_uint = 1;
pub const CONFIG_F2FS_FS_ENCRYPTION: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_MB862XX_PCI_GDC: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRC7_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_RNG_DEFAULT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SLICOSS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LTC4215_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KVM_AMD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CLS_TCINDEX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_EMI26_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_PROTO_ESP: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_LATENCYTOP_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCNET32_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_IT913X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GIGASET_I4L: ::std::os::raw::c_uint = 1;
pub const CONFIG_MWIFIEX_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SAMSUNG_Q10_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TMPFS_XATTR: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_I82975X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_NMCLAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_TEAM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_UVESA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LCD_ILI922X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_TSC2007_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_RME96_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DCA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_KVASER_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_ALI1535_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_I801_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_UMEM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_CAFE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS: ::std::os::raw::c_uint = 16;
pub const CONFIG_W1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SAA7134_ALSA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2800PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_VC032X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OPENVSWITCH_GRE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_RAYCS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IOMMU_HELPER: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_ISL6421_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_AU0828_RC: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS1374_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MICROCODE_OLD_INTERFACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AUFS_INO_T_64: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_BQ4802_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TMD_HERMES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_ACPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_TRACER: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_ISO8859_5_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_VGEM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_WLC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FM10K_VXLAN: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_FUNCTION_TRACER: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_PHY: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADE7758_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_TFTP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_MULTIPORT_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_CHARGER_MAX14577_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_SPI_NOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_MANAGER: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_NETEM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_PROCESSOR_AGGREGATOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_BCM2048_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STORAGE_REALTEK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_AC97_CODEC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CAMELLIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_EMU10K1_SEQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS1307_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_SIS630_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_SELECT_MEMORY_MODEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFSD_V4: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_SI4713_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AUFS_EXPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_PMBUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EFI_MIXED: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_MEYE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCP_CONG_ILLINOIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ZEROPLUS_FF: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_REDIRECT_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_CRYPTO_MANAGER2: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_QIB_DCA: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GADGET_VBUS_DRAW: ::std::os::raw::c_uint = 2;
pub const CONFIG_NFC_MEI_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_MYRI: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEXEC_FILE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRAGONRISE_FF: ::std::os::raw::c_uint = 1;
pub const CONFIG_CLZ_TAB: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_3M: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_EGALAX: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_SUR40_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_DNAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_PCI_IOMAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_LOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SLUB: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_AD7418_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CONFIGFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_HHF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_TEST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_UBI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_SMSC: ::std::os::raw::c_uint = 1;
pub const CONFIG_XZ_DEC_BCJ: ::std::os::raw::c_uint = 1;
pub const CONFIG_SLIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_SLEEP: ::std::os::raw::c_uint = 1;
pub const CONFIG_F2FS_FS_XATTR: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_FAM15H_POWER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_WM5110: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMPAL_LAPTOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFFS2_ZLIB: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_CHELSIO_FCOE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_PCNET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_DECODE_MCE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_VT1211_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B44_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPP_MULTILINK: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_ONENAND_GENERIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPACK_BUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BINFMT_SCRIPT: ::std::os::raw::c_uint = 1;
pub const CONFIG_EFI_STUB: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_PROMISE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARPORT_1284: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_PS2_CYPRESS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_POWR1220_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX25840_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_PENDING_IRQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_AMD756_S4882_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARPORT_PC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_TEAM_MODE_LOADBALANCE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_MN88472_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPS_CLIENT_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_NEED_RELOCS: ::std::os::raw::c_uint = 1;
pub const CONFIG_EARLY_PRINTK_DBGP: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_ADV7175_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_SRP_ATTRS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FRAME_POINTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_IPGRE_BROADCAST: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HIDP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PD6729_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KS8851_MLL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX231XX_RC: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_PS2_LOGIPS2PP: ::std::os::raw::c_uint = 1;
pub const CONFIG_TICK_CPU_ACCOUNTING: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DT2817_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SMC_IRCC_FIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_PCXHR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_TPS65217_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VM_EVENT_COUNTERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_COMMON_OPTIONS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_MICROREAD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_SX8654_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RELAY: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD9834_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IWLDVM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_MMIOTRACE_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCHED_STACK_END_CHECK: ::std::os::raw::c_uint = 1;
pub const CONFIG_ASUS_NB_WMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_FINEPIX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_NETJET: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_ECB: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_ETOMS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SHA512_SSSE3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MAX77693_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_PALMAS: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_STD_PARTITION: &'static [u8; 1usize] = b"\x00";
pub const CONFIG_SQUASHFS_LZO: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_DYNAMIC_MINORS: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUJITSU_LAPTOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCM_FILEIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_XIRCOM: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_FIND_FIRST_BIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_STEX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_6LOWPAN_NHC_HOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOTPLUG_PCI_CPCI_ZT5550_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIUART_ATH3K: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_AMANDA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ATIIXP_MODEM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEBUG_FS: ::std::os::raw::c_uint = 1;
pub const CONFIG_UNISYS_VISORBUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CC_STACKPROTECTOR_REGULAR: ::std::os::raw::c_uint = 1;
pub const CONFIG_FEALNX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_EXTLOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_FUNCTIONFS_RNDIS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_AMD: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KERNEL_LZ4: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_PKTGEN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HP_WMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_DENALI_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_EDGEPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_TTM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BASE_FULL: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_CFB_IMAGEBLIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_ZLIB_DEFLATE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_REJECT_INET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SUNRPC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOLARIS_X86_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCNET_RAW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_DISCARD_MEMBLOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_PMIC_DA903X: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_DH_RDAC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_W83795_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_P4_CLOCKMOD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_ATI_REMOTE2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CNIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RSI_SDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_I810_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OSF_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_864_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_BUFFER: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_CY8CTMG110_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IWL3945_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_LBLCR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_SYSFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_HP_WIRELESS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_YUREX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_BACKEND: ::std::os::raw::c_uint = 1;
pub const CONFIG_FW_LOADER: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_G_DBGP_SERIAL: ::std::os::raw::c_uint = 1;
pub const CONFIG_LITELINK_DONGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_NAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_WM8350_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADS7828_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KALLSYMS: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMMON_CLK: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SPCA501_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOTPLUG_PCI_PCIE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTERVAL_TREE_TEST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_HCTOSYS_DEVICE: &'static [u8; 5usize] = b"rtc0\x00";
pub const CONFIG_CRYPTO_XTS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ZL6100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_RL6231_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PWM: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_DS2781_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_PCF50633_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_RECENT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DECOMPRESS_XZ: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_BCM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_PKTTYPE_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_PCI_QUIRKS: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_USNIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MII_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_TCA8418_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SIGNALFD: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MAX8997_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_PS2_ALPS: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CPIA2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_UNSTABLE_SCHED_CLOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXT4_FS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC80211_DEBUGFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_DRR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LTC4151_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_802_3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU5_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMORY_BALLOON: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_65XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_USDHI6ROL0_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_SC16IS7XX_SPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_LE80578_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX88_BLACKBIRD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_SEC_CORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_PCM512x_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_HW_BREAKPOINT: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_SUPPORTS_DEFERRED_STRUCT_PAGE_INIT:
          ::std::os::raw::c_uint =
    1;
pub const CONFIG_KRETPROBES: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_LPDDR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SHA1: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_MM_EDAC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_FOTG210_HCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_MT6397_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QUOTACTL_COMPAT: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_PENMOUNT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_BQ27X00_PLATFORM: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPMI_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MD_CLUSTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_TDFX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_JOYDUMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_USER_ACCESS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VMWARE_VMCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHELSIO_T4_DCB: ::std::os::raw::c_uint = 1;
pub const CONFIG_BPQETHER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ADUTUX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_UDA1342_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HSI_BOARDINFO: ::std::os::raw::c_uint = 1;
pub const CONFIG_KGDB_LOW_LEVEL_TRAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_MT7601U_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_C_CAN_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_WANT_GENERAL_HUGETLB: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_SMSC47M192_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_TPS65218_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADT7316_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCH_CONST_PARAMS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRC8_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_KOI8_U_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RADIO_SHARK2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_CS42L51_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_SCH5636_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PKCS7_TEST_KEY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XZ_DEC: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_BELKIN: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_PMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SMS_SIANO_DEBUGFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPW2100_MONITOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_QLA3XXX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8192U_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_VCAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SBNI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH_COMMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_TI: ::std::os::raw::c_uint = 1;
pub const CONFIG_CROS_EC_LPC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LOCKD_V4: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LTC2945_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DUMMY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_XGI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CODA_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_SLAVE_DS2431_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_LM3530_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TUNER_CX24113_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_MARK_T_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WATCHDOG: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_MAX17042_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_ADVANSYS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_B2C2_FLEXCOP_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_RN5T618_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAS_IOMEM: ::std::os::raw::c_uint = 1;
pub const CONFIG_RING_BUFFER_ALLOW_SWAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_RAWMIDI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOTPLUG_PCI_ACPI_IBM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_ARIZONA_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_LOG_IPV6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIRC_SASEM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DE4X5_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IEEE802154_SOCKET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_RSA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_STK1135_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_8139TOO_8129: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_INPUT_BEEP_MODE: ::std::os::raw::c_uint = 0;
pub const CONFIG_VIRT_DRIVERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_AUFS_SBILIST: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LTC4222_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PCL724_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIUART_INTEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_DEVRES: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_AUO_K1900_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_FINTEK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_PXA2XX_DMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_IRQ_PROBE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH6KL_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUSION_LOGGING: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_CDC_EEM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRCM_TRACING: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STORAGE_SDDR09_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SCS1X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HYPERV_STORAGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_MATCH_TTL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_MCS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ASYNC_RAID6_RECOV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_STA32X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SI7020_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_SSD1289_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDD_OFF: ::std::os::raw::c_uint = 1;
pub const CONFIG_PWM_LPSS_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GART_IOMMU: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_RT9455_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_SYM53C8XX_MAX_TAGS: ::std::os::raw::c_uint = 64;
pub const CONFIG_FB_CARMINE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CW1200_WLAN_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFTL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI_MMCONFIG: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_TRACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_STA350_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_AM53C974_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TRACE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HVC_IRQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_IWLWIFI_DEVICE_TRACING: ::std::os::raw::c_uint = 1;
pub const CONFIG_MDIO_OCTEON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_ZATM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_NFIT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GADGETFS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IRDA_ULTRA: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_RME32_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PROC_KCORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_X1205_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_1: ::std::os::raw::c_uint = 1;
pub const CONFIG_LPC_ICH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NUMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_MATCH_FRAG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_CYBERJACK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_PRIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JSA1212_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCHED_HRTICK: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA28XB: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_ULI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_DRXK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_IUU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_GO7007_USB_S2250_BOARD_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_EPOLL: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_MATROX_G: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_AIC79XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MICROCODE_EARLY: ::std::os::raw::c_uint = 1;
pub const CONFIG_RADIO_MAXIRADIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_LZO: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_PCM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_TWOFISH_AVX_X86_64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIRC_ZILOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCM_USER2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB: ::std::os::raw::c_uint =
    20480;
pub const CONFIG_BRIDGE_EBT_SNAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_HWEIGHT_CFLAGS: &'static [u8; 134usize] =
    b"-fcall-saved-rdi -fcall-saved-rsi -fcall-saved-rdx -fcall-saved-rcx -fcall-saved-r8 -fcall-saved-r9 -fcall-saved-r10 -fcall-saved-r11\x00";
pub const CONFIG_TCG_TIS_ST33ZP24_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_AU8820_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RAPIDIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_OCRDMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GIRBIL_DONGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_DT3155_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SDIO_UART_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KVM_COMPAT: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARTITION_ADVANCED: ::std::os::raw::c_uint = 1;
pub const CONFIG_EZX_PCAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_SCH56XX_COMMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_DCCP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ICPLUS_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CGROUP_HUGETLB: ::std::os::raw::c_uint = 1;
pub const CONFIG_UNIXWARE_DISKLABEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_U_ETHER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_NUMACHIP: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_USBDUXFAST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_LP872X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXTCON_AXP288_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_BNEP_MC_FILTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CRC32_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_ISCSI_ATTRS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_DENALI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_NET_DSA: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_EMPEG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_MAX7359_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_SPINAND_ONDIEECC: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_SONY_DECODER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_852_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCG_TIS: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_IDEALTEK: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_PVRUSB2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_COMMENT_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_NFS_SWAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ISP116X_HCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_ISCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_RNDIS_HOST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATARI_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_MS5611_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SQUASHFS_FILE_DIRECT: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_OHCI_HCD_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_EVDEV: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_JACK: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD5933_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DDR: ::std::os::raw::c_uint = 1;
pub const CONFIG_LUSTRE_LLITE_LLOOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IDEAPAD_LAPTOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_PATH: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADIS16220_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TCPMSS_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_FB_TFT_SSD1351_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BE2NET_VXLAN: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43LEGACY_DMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_SLEEP: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_VIRTUAL_CONSUMER_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_NETFILTER_XT_MATCH_DSCP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_WP512_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CFAG12864B_RATE: ::std::os::raw::c_uint = 20;
pub const CONFIG_C2PORT_DURAMAR_2150_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_DRAGONRISE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_ESPFIX64: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNTRACK_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_GPIO_RDC321X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_KGDB_NMI: ::std::os::raw::c_uint = 1;
pub const CONFIG_VMIVME_7805_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADQ12B_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_BT848_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLOCK_COMPAT: ::std::os::raw::c_uint = 1;
pub const CONFIG_ITCO_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_LABPC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_IGUANA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_LP8788_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_RATEEST_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_FW_LOADER_USER_HELPER: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ALOOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH9K_STATION_STATISTICS: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_KBD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HPFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PINMUX: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_LD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_GEN_PROBE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QUOTA_TREE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_VIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAIF_NETDEV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_PCSPKR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IRQ_DOMAIN_HIERARCHY: ::std::os::raw::c_uint = 1;
pub const CONFIG_PNFS_OBJLAYOUT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HVC_XEN_FRONTEND: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_AV7110_OSD: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIO_PCIPS2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MPILIB: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_CDCETHER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMA9551_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PACKET: ::std::os::raw::c_uint = 1;
pub const CONFIG_MODULE_SRCVERSION_ALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_FIREWIRE_SERIAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_M48T86_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XFRM_ALGO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_TIMESTAMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCIF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_CLK_PREPARE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX88_MPEG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_AKCIPHER2: ::std::os::raw::c_uint = 1;
pub const CONFIG_TAHVO_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NODES_SHIFT: ::std::os::raw::c_uint = 6;
pub const CONFIG_SENSORS_SMM665_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MWIFIEX_SDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_IPRANGE_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_INTEL_IOATDMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CLS_BASIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AXP288_ADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_LM3533_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_GENERIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AUFS_BR_HFSPLUS: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD5764_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_TINY_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETROM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC35240_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUSION_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BTRFS_FS_POSIX_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_OV534_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_TCA6416_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DT3000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FRONTSWAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_MPR: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_GL861_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IMA_APPRAISE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DUMMY_CONSOLE_ROWS: ::std::os::raw::c_uint = 25;
pub const CONFIG_MFD_ARIZONA_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_XHCI_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_TLV320AIC23_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_TFTP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_V3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_MAX6902_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_MAX8997: ::std::os::raw::c_uint = 1;
pub const CONFIG_PHY_TUSB1210_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_ANYSEE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_HFC_SX: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KVM_IRQFD: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_949_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_CX24110_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_TMP102_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NOP_TRACER: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_LCD_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_LOOPBACK_TARGET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISL29020_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_TSL2563_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_PATCH_LOADER: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_XENBUS_FRONTEND: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_PCRYPT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SENSOR_PRESS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_CB_PCIMDDA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_ROUTE_VERBOSE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XZ_DEC_POWERPC: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_WL3501_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_MAX3421_HCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_RTL2832_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_MUSB_HDRC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIRTIO_NET: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMORY_NOTIFIER_ERROR_INJECT_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_NETFILTER_XT_MATCH_ADDRTYPE_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_DRM_I915_KMS: ::std::os::raw::c_uint = 1;
pub const CONFIG_PREVENT_FIRMWARE_BUILD: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_8250_PNP: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_MCS7830_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEOBUF2_DVB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ENS1371_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_TWOFISH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FREEZER: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_I5500_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_SUBSET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FIREWIRE_NET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADV_PCI1724_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_SLAVE_DS2413_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_TEST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_MAX11801_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8737_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADAPTEC_STARFIRE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_BCM590XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIVHCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_CM109_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AXP288_FUEL_GAUGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI_DOMAINS: ::std::os::raw::c_uint = 1;
pub const CONFIG_EFI_VARS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_INTEL_BYT_RT5640_MACH_MODULE: ::std::os::raw::c_uint
          =
    1;
pub const CONFIG_USB_SWITCH_FSA9480_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_88PM800_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_QUEUE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LCD_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_MXL111SF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_IT87_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LPC_SCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CLS_ACT: ::std::os::raw::c_uint = 1;
pub const CONFIG_MLX90614_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REED_SOLOMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CIFS_DFS_UPCALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_CHELSIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_LZ4HC_COMPRESS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADL_PCI6208_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HDLC_RAW_ETH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EFIVAR_FS: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_BROUTE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_SMSC75XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LNET_SELFTEST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BE2NET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_TPS80031_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VORTEX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPEAKUP_SYNTH_DECTLK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_IPVS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TIPC_MEDIA_UDP: ::std::os::raw::c_uint = 1;
pub const CONFIG_VMWARE_VMCI_VSOCKETS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_DEBUGCTLMSR: ::std::os::raw::c_uint = 1;
pub const CONFIG_HDLC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CLS_BPF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_SOLOS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_8139TOO_PIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN: &'static [u8; 11usize] =
    b"kernel.org\x00";
pub const CONFIG_IP_SET_MAX: ::std::os::raw::c_uint = 256;
pub const CONFIG_HAPPYMEAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_WACOM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_ACM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QLCNIC_DCB: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCIF_BUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_CP210X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_PCMCIA: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_SFQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_LIB: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEVFREQ_GOV_POWERSAVE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_LOCAL_APIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GOKU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_UEAGLEATM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_POLICY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MWL8K_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KPROBES: ::std::os::raw::c_uint = 1;
pub const CONFIG_NUMA_BALANCING_DEFAULT_ENABLED: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_AGM1264K_FL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_INTEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TPS65010_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_ROUTE_CLASSID: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_SYNAPTICS_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TEE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_USB_VARIAX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HPWDT_NMI_DECODING: ::std::os::raw::c_uint = 1;
pub const CONFIG_ENC28J60_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_PS2_TOUCHKIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_PWM_LP3943_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_XSENS_MT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX88_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_ITM: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_AES: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_LP855X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_DIB7000P_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIOLIB: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_TI_AM335X_TSCADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SSB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_ISL6271A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_MATROX_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_STUB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXTCON_MAX8997_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_BIO_PRISON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_DRV2667_HAPTICS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_EM28XX_RC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_LIMIT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RADIO_TEA5764_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FT1000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYS_COMPAT: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SPCA1528_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_TLC591XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SVGALIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BMC150_MAGN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARPORT_AX88796_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TI_ADC128S052_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXT4_USE_FOR_EXT23: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD2S1210_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_PID: ::std::os::raw::c_uint = 1;
pub const CONFIG_NV_TCO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_QT2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SMSC9420_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PCI_DRIVERS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_MAX6639_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GAMEPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISO9660_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SKY2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_NAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7793_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIUART_H4: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_F_MIDI: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_GPIO_TILT_POLLED_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS3232_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MC13783_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_M920X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_WALTOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_LM3630A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_MT9T031_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADIS16136_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_RC5T583: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_ADV7170_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UIO_DMEM_GENIRQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_TAS5086_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_VIRTIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_MARK: ::std::os::raw::c_uint = 1;
pub const CONFIG_HVC_DRIVER: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_PCIESSD_MTIP32XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_REJECT_IPV4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RC_LOOPBACK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DRV_AVMB1_T1PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TEST_HEXDUMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_HASHLIMIT_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_MODULE_SIG: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_AMONG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DT2814_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH9K_WOW: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43_PIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_APPARMOR_UNCONFINED_INIT: ::std::os::raw::c_uint =
    1;
pub const CONFIG_BACKLIGHT_88PM860X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_DEV_DMA_OPS: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43_BUSES_BCMA_AND_SSB: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADIS16201_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_R8A66597_HCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_TWL4030_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_MSR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_ARCH_KASAN: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_SMSC: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_NETLINK_ACCT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_8254_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CLUSTER_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_USB_KC2190: ::std::os::raw::c_uint = 1;
pub const CONFIG_R6040_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_MDC800_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AIRO_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_6LOWPAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIPERBOARD_ADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HWMON_VID_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIO_SERPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_BOOT_VESA_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_PPP_VJ: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ME4000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_950_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_STV0297_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TTUSB_DEC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_TRIGGER_ONESHOT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HT_IRQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIRC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_PWM_BEEPER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_AIC94XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_BNEP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_QFQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TDA826X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_MPC624_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_RAM_COUNT: ::std::os::raw::c_uint = 16;
pub const CONFIG_SCSI_FUTURE_DOMAIN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IXGBEVF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_AC97_POWER_SAVE_DEFAULT: ::std::os::raw::c_uint = 0;
pub const CONFIG_TABLET_SERIAL_WACOM4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_THINKPAD_ACPI_DEBUGFACILITIES: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_NGENE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RD_XZ: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_MROUTE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET_XFRM_MODE_TUNNEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_MXB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_SMAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_TLV320AIC23_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VGA_CONSOLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_NEEDED: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_HTU21_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_RMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATA_VERBOSE_ERROR: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DRV_AVMB1_B1PCMCIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_BLKDEV_FRONTEND: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_SNMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CM3232_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_DRIVERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_S0BOX: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_BELKIN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_MASTER_DS2490_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_MT2266_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_MAC_GREEK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_FLOW_LIMIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_XFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_DME1737_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_KEYSPAN_REMOTE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_PAC7302_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LOCKDEP_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_MCE_INJECT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIRC_PARALLEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_ELO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_869_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_NCT7904_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_AZT3328_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_LOG_BRIDGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_AC97_POWER_SAVE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_TARGET_MASQUERADE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_PALMAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_REDIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_VIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PCMMIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION: ::std::os::raw::c_uint =
    1;
pub const CONFIG_NO_HZ: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_SOC_PMIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_WANT_HUGE_PMD_SHARE: ::std::os::raw::c_uint = 1;
pub const CONFIG_POSIX_MQUEUE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NOUVEAU_DEBUG: ::std::os::raw::c_uint = 5;
pub const CONFIG_NETFILTER_INGRESS: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_TOUCHIT213_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_DWAPB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_PFUZE100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_PM2_FIFO_DISCONNECT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM83_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_CDC_MBIM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PMC_ATOM: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACENIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_MIGHT_HAVE_PC_SERIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_PSTORE_RAM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PCM3724_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_BLINKM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_FREQ_STAT: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFS_STATISTICS: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISCSI_IBFT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_DAQ_700_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_PXA2XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_SMC91C92_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIDTL1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TIFM_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_PRIVCMD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUSION_SAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_STRNCPY_FROM_USER: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHR_DEV_OSST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_SSD1331_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_BLKDEVS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_KEMPLD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TDA10086_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HP100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_3W_XXXX_RAID_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMSTICK_R592_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_MQPRIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_NETMAP_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_VIDEO_VPX3220_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_APDS9802ALS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_NXT6000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MANTIS_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_MARVELL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64_MODULE:
          ::std::os::raw::c_uint =
    1;
pub const CONFIG_NETFILTER_XT_MATCH_SCTP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_SIL24_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SMS_SIANO_RC: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_PCM_OSS_PLUGINS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_CS42L52_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISL29125_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_DEC: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_NOTIFIER_ERROR_INJECT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_ISO8859_15_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SENSOR_MAGNETOMETER_3D_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_TOUCHSCREEN_EETI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_VIA686A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET6_ESP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOSTAP_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_WRR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AUTOFS4_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETLINK_MMAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH5K_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_FB_IVTV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_BUTTON: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_LM355x_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ILLEGAL_POINTER_VALUE: ::std::os::raw::c_longlong =
    -2401263026318606336;
pub const CONFIG_CRYPTO_DEV_CCP_CRYPTO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYSCTL_SYSCALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_UIO_NETX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PDA_POWER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_SET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_MAC_CROATIAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SFC_MTD: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_OV2640_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FMC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_MAX98090_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TASKSTATS: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXTCON_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCNET_1201_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_932_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_PMC_IPC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MCB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2X00_LIB_MMIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CRC32C_INTEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_MAC_ICELAND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ATMEL_SOC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_SUBDRV_AUTOSELECT: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_I915_FBDEV: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_PLX_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_FUNCTIONFS_GENERIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFS_POSIX_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_ALI1563_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_FILTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EFI_ESRT: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_MOUSEDEV_SCREEN_X: ::std::os::raw::c_uint = 1024;
pub const CONFIG_NEED_DMA_MAP_STATE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_ILI9340_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_G762_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_PREALLOC_SIZE: ::std::os::raw::c_uint = 64;
pub const CONFIG_GARP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_AHA152X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_TWL6040_VIBRA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2500USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_YENTA_ENE_TUNE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_PS2_LIFEBOOK: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIO_LIBPS2: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_DRBD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_PROTO_TCP: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISCSI_BOOT_SYSFS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_CPUID_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_RED_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI_ATMEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_NFACCT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNBYTES_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_KDB_CONTINUE_CATASTROPHIC: ::std::os::raw::c_uint = 0;
pub const CONFIG_LNET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_METRO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_PRINTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_DIEHLDIVA: ::std::os::raw::c_uint = 1;
pub const CONFIG_FONT_8x8: ::std::os::raw::c_uint = 1;
pub const CONFIG_SSB_SPROM: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_PAC207_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_ATHEROS: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_IR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SIMPLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SKGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DT9812_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_ACT8865_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_AK4104_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_DA9055_ONKEY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCM_PSCSI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RELOCATABLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_POLY1305_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QUEUED_SPINLOCKS: ::std::os::raw::c_uint = 1;
pub const CONFIG_XOR_BLOCKS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_TWINHAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_V4_1_MIGRATION: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_NTC_THERMISTOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_SX150X: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_OC_TINY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AS3935_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MISDN_L1OIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_PCM1792A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_PT1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DMIID: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_SUN: ::std::os::raw::c_uint = 1;
pub const CONFIG_PANIC_TIMEOUT: ::std::os::raw::c_uint = 0;
pub const CONFIG_ASUS_WMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_DS1621_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_TOSHIBA_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QUOTA_NETLINK_INTERFACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_JOYSTICK: ::std::os::raw::c_uint = 1;
pub const CONFIG_QNX4FS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_ACT_SIMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_OXU210HP_HCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2X00_LIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_DWC2: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_BATTERY_STRENGTH: ::std::os::raw::c_uint = 1;
pub const CONFIG_YAM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_VERITY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_ECN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_STV0680_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_RCU_NOCB_CPU_ALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH9K_PCOEM: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_FM801_TEA575X_BOOL: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STORAGE_SDDR55_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPDEV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_CS4271_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_S6D02A1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_INTEL_BAYTRAIL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RFKILL_REGULATOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_TARGET_TTL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AMILO_RFKILL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_MASQUERADE_IPV4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DRV_AVMB1_B1PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CFG80211_DEFAULT_PS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_META_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_LED_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BUILD_BIN2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_IOMAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_IEEE802154_FAKELB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USBIP_HOST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_BQ24190_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_WACOM_W8001_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_PRESS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADL_PCI7X3X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_PLUTO2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8723AE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DECOMPRESS_LZ4: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_FBDEV_FRONTEND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_DLN2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPARSEMEM_MANUAL: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_AV7110_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK: ::std::os::raw::c_uint =
    1;
pub const CONFIG_DVB_OR51132_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2X00_LIB_FIRMWARE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DL2K_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_MMS114_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SXGBE_ETH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BPF_SYSCALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_SMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_KYRO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_ZL10353_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_INTEL_LPSS_ACPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_TIME_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TTY: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KERNEL_GZIP: ::std::os::raw::c_uint = 1;
pub const CONFIG_ZSMALLOC: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_UEVENT: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_ESD_USB2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAIF_VIRTIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_MV_UDC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_I825XX: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_XUSBATM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PNP: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_RP5C01_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_MAC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_NFORCE2_S4985_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_THUNDER_NIC_BGX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_NCT6775_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_YELLOWFIN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_TPS6507X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DW_DMAC_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_AMPLC_DIO200_ISA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_ACT_PEDIT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_NFLOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_BT819_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DA9150_GPADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_JASTEC: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_ALLOCATOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_OPENVSWITCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS1390_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_L2TP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_DA9052_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_B2C2_FLEXCOP_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCP_CONG_WESTWOOD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_M41T93_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KALLSYMS_ALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_FORE200E_TX_RETRY: ::std::os::raw::c_uint = 16;
pub const CONFIG_HID_AUREAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SPCA561_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPMI_SSIF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_GMA600: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_IO: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIBCRC32C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_MATRIX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RSI_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_BOOTMEM_INFO_NODE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_PCF50633_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_BUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SHA256: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_FTRACE_MCOUNT_RECORD: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_GUILLEMOT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_VLAN_FILTERING: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_AU0828_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WL18XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET_TCP_DIAG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SONY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_PVRUSB2_DVB: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_PRINTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMSTICK_REALTEK_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI_PASID: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_BLOWFISH_X86_64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HW_CONSOLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MDIO_BITBANG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_ACT_IPT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_AS102_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KVM_IRQ_ROUTING: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_ON26_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_BNX2X_FCOE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_UBI_GLUEBI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RAS: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMMON_CLK_CDCE706_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_GO7007_LOADER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_TW9910_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_MT9V022_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DA9052_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ETH_EEM: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_TWL4030_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HYPERV_NET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGMAP_SPMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEVMEM: ::std::os::raw::c_uint = 1;
pub const CONFIG_SMSC_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HP_ACCEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_PS2_FOCALTECH: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_EMS_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_BNX2_ISCSI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OMFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCG_TIS_I2C_NUVOTON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_ZC3XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ES1968_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_EUROTECH_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_DLN2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MLX5_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_LOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_ADP8870_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_MTOUCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_IP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_EPAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_MONTEREY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_UDL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_CYPRESS_M8_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_NEOMAGIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_TPS65217_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_EZKEY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PADATA: ::std::os::raw::c_uint = 1;
pub const CONFIG_IOSCHED_NOOP: ::std::os::raw::c_uint = 1;
pub const CONFIG_THERMAL_GOV_USER_SPACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_S5H1409_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPW2200_QOS: ::std::os::raw::c_uint = 1;
pub const CONFIG_HSU_DMA_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MDIO_BCM_UNIMAC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_LOWLEVEL_PCMCIA: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_TMEM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFFS2_FS_POSIX_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_DA9052_ONKEY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_THIN_PROVISIONING_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_UID16: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_NONSTANDARD: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT61PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMPAT_OLD_SIGACTION: ::std::os::raw::c_uint = 1;
pub const CONFIG_MICROCODE_AMD_EARLY: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_JMICRON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_TSC_SERIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_OSD_ULD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_FEATURE_NAMES: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_XPAD_LEDS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_TC74_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPW2100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_PPA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_PWM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_MRVL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QUOTACTL: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_RX8581_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_V4L2_MEM2MEM_DEV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SAVAGE_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARAVIRT: ::std::os::raw::c_uint = 1;
pub const CONFIG_TWL4030_MADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WQ_POWER_EFFICIENT_DEFAULT: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_MENLOW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_CAPI_CAPI20_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CRYPTD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_EATA_MAX_TAGS: ::std::os::raw::c_uint = 16;
pub const CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_IOREMAP_PROT: ::std::os::raw::c_uint = 1;
pub const CONFIG_CM32181_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USBIP_VHCI_HCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_RZ1000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_ADP8860_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAX8925_POWER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAPI_TRACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEBUG_KERNEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_RAM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8192DE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_TOSHIBA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GAMEPORT_NS558_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INV_MPU6050_IIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LTC2978_REGULATOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX2341X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_VIPERBOARD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LOCALVERSION: &'static [u8; 1usize] = b"\x00";
pub const CONFIG_NCPFS_IOCTL_LOCKING: ::std::os::raw::c_uint = 1;
pub const CONFIG_REISERFS_FS_SECURITY: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_STV6110x_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_IT821X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACERHDF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_INTEL_BROADWELL_MACH_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_RADIO_ADAPTERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_QCOM_SPMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMTEST: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_XTKBD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_PCSPKR_PLATFORM: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_FSCACHE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS:
          ::std::os::raw::c_uint =
    1;
pub const CONFIG_MAC80211_MESH: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_WBSD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_TOPRO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_MARS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_RAW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_SI2165_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MAX8973_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_MUX_PCA954x_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUNCTION_TRACER: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_MATROX_MILLENIUM: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_EMC6W201_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_TRANCEVIBRATOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCHED_DEBUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_CHAIN_NAT_IPV4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STKWEBCAM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_BROCADE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BTRFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEFAULT_MMAP_MIN_ADDR: ::std::os::raw::c_uint = 65536;
pub const CONFIG_SND_USB_6FIRE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PERF_EVENTS_INTEL_UNCORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_HWDEP: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_AD714X_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_SIS96X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_TIFM_SD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GFS2_FS_LOCKING_DLM: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_TDA18218_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_IPTABLES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_HFC4S8S_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_SLAVE_BQ27000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VSOCKETS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_F7188X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_BNEP_PROTO_FILTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_DYNAMIC_FTRACE_WITH_REGS: ::std::os::raw::c_uint = 1;
pub const CONFIG_IWLWIFI_LEDS: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CHIPIDEA_HOST: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_RETU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_QLOGIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_CPIA1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_PF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HSI_CHAR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEOBUF2_DMA_CONTIG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_XHCI_HCD: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIRTIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_DMA_API_DEBUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_TPS65910_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_16_3: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEFAULT_CUBIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_KVASER_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_YENTA_TI: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_660X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_CS35L32_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_SM501_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7606_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SAMSUNG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_XCOMM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SFC_MCDI_LOGGING: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_LIST_SET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCM_IBLOCK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_PIMSM_V2: ::std::os::raw::c_uint = 1;
pub const CONFIG_CFS_BANDWIDTH: ::std::os::raw::c_uint = 1;
pub const CONFIG_WM831X_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_CODEC_CA0132_DSP: ::std::os::raw::c_uint = 1;
pub const CONFIG_XFRM_STATISTICS: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_GENERIC_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_MCE_THRESHOLD: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_SCB2_FLASH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_TW2804_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIA_RHINE_MMIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ISIGHTFW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JME_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_LINK_LAYER_TEST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_CODEC_CMEDIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_TRF7970A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DMA_VIRTUAL_CHANNELS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_WD719X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_YENTA_O2: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_MSI_IRQ_DOMAIN: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SEQ_HRTIMER_DEFAULT: ::std::os::raw::c_uint = 1;
pub const CONFIG_I40E_FCOE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ARCH_HAS_HCD: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_CHAIN_ROUTE_IPV6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_DIB3000MC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_STRICT_DEVMEM: ::std::os::raw::c_uint = 1;
pub const CONFIG_CACHEFILES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_OLDPIIX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_KEMPLD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_IRQ_SHOW: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_CODEC_SI3054_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADIS16204_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_PCF50633_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LCD_ILI9320_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_MAX8925: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_MICROREAD_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_HAS_ELF_RANDOMIZE: ::std::os::raw::c_uint = 1;
pub const CONFIG_9P_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MD_AUTODETECT: ::std::os::raw::c_uint = 1;
pub const CONFIG_PANIC_ON_OOPS_VALUE: ::std::os::raw::c_uint = 0;
pub const CONFIG_JOYSTICK_A3D_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_SAMSUNG: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_CS4270_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ATK0110_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_VIA_X_COMPATIBILITY: ::std::os::raw::c_uint = 1;
pub const CONFIG_SFC_SRIOV: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_SCCNXP: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCP_CONG_HSTCP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_MOD: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_SSM2602_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_DPT_I2O_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_88PM860X_ONKEY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_CROS_EC_TUNNEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_MICREL: ::std::os::raw::c_uint = 1;
pub const CONFIG_AUDIT_TREE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_PM2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GIGASET_M105_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_UPD161704_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MPLS_ROUTING_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_F2FS_FS_POSIX_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_FWTTY_MAX_TOTAL_PORTS: ::std::os::raw::c_uint = 64;
pub const CONFIG_VIDEOBUF2_DMA_SG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_HFC_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_ZHENHUA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_SPCP8X5_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_AK5386_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP4_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SENSOR_PROX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RC_DECODERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43_LEDS: ::std::os::raw::c_uint = 1;
pub const CONFIG_P54_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_MK712_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_ATY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_CYTTSP4_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_KINECT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPEAKUP_SYNTH_DECEXT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_WISHBONE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DAQBOARD2000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_CLASS_FLASH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_HUAWEI_CDC_NCM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OPROFILE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_ESAS2R_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX25821_ALSA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CRC32C: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_CORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_SENSORS_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUSE_FS: ::std::os::raw::c_uint = 1;
pub const CONFIG_BUILDTIME_EXTABLE_SORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_SERIAL: ::std::os::raw::c_uint = 1;
pub const CONFIG_UID16: ::std::os::raw::c_uint = 1;
pub const CONFIG_ETHOC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DW_DMAC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_PCM512x_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_HED: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_DEBUG_STACKOVERFLOW: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_MICROSOFT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTLLIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIVEPATCH: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_PHYS_ADDR_T_64BIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCC: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_S35390A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KRETPROBES: ::std::os::raw::c_uint = 1;
pub const CONFIG_HYPERV_BALLOON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_IMM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM25066_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ASSOCIATIVE_ARRAY: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_F_UVC: ::std::os::raw::c_uint = 1;
pub const CONFIG_HSA_AMD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AGP_VIA: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_DEFRAG_IPV6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_CONEX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MICREL_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_LOAD_EDID_FIRMWARE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_DEV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KS0108_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SGI_IOC4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_V4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_WM831X: ::std::os::raw::c_uint = 1;
pub const CONFIG_PMIC_ADP5520: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_TPS80031_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IRCOMM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPP_FILTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_DYNAMIC_FTRACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAILBOX: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_LEDS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_SLRAM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INLINE_READ_UNLOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_ROM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_PDC2027X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LTC2978_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAS_DMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_IPS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CT_PROTO_SCTP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_VISOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_PMC551_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BROADCOM_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PCMUIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_AS102_FE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IO_DELAY_TYPE_NONE: ::std::os::raw::c_uint = 3;
pub const CONFIG_SND_SOC_CS42XX8_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENWQE_PLATFORM_ERROR_RECOVERY: ::std::os::raw::c_uint = 0;
pub const CONFIG_FB_CFB_FILLRECT: ::std::os::raw::c_uint = 1;
pub const CONFIG_FT1000_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2800_LIB_MMIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HYPERV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AT76C50X_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QCOM_SPMI_IADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_WM8994_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUNCTION_GRAPH_TRACER: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_MCE_INJ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_PPTP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_CHICONY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_MAC_ROMAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HW_RANDOM_AMD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SST_IPC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AUFS_XATTR: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_VIVID_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIBERTAS_THINFIRM_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CGROUP_NET_PRIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_RANDOMIZE_BASE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_F_UAC1: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_DWC3_DUAL_ROLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND: ::std::os::raw::c_uint = 1;
pub const CONFIG_PWM_TWL_LED_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SLIP_SMART: ::std::os::raw::c_uint = 1;
pub const CONFIG_IXGB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_ISO8859_9_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_ZFORCE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_ACT_BPF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FIRMWARE_EDID: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SERIAL_U16550_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AMD_IOMMU_V2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ARMLINUX: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_SMBUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_PE_SIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_TWL4030_MADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMSTICK_REALTEK_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PLATFORM_SI4713_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_GF2K_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTLWIFI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCG_TIS_ST33ZP24_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LP8788_ADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CLKDEV_LOOKUP: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_TRIGGER_DEFAULT_ON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MXM_WMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FONT_8x16: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_MELLANOX: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC80211_HWSIM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_LGDT330X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_MIC_X100_DMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_8250_MANY_PORTS: ::std::os::raw::c_uint = 1;
pub const CONFIG_VT_CONSOLE_SLEEP: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIBFC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_MCE_INTEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_64: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_CMOS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_USER_API_AEAD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PTP_1588_CLOCK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IEEE802154_DRIVERS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LNET_MAX_PAYLOAD: ::std::os::raw::c_uint = 1048576;
pub const CONFIG_TOUCHSCREEN_USB_IRTOUCH: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_AMD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_PWC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE: ::std::os::raw::c_uint = 3;
pub const CONFIG_SENSORS_AD7414_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_TDA8290_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADV_PCI_DIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_PANJIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2800PCI_RT53XX: ::std::os::raw::c_uint = 1;
pub const CONFIG_BONDING_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_TOMOYO_ACTIVATION_TRIGGER: &'static [u8; 11usize] =
    b"/sbin/init\x00";
pub const CONFIG_MEDIA_TUNER_TDA18212_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MCP3422_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_EM3027_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_HAS_CACHE_LINE_SIZE: ::std::os::raw::c_uint = 1;
pub const CONFIG_6LOWPAN_NHC_DEST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SAA7134_RC: ::std::os::raw::c_uint = 1;
pub const CONFIG_JBD2: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_AMPLC_PC236_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ASB100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_INTEL8X0_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_ATMIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_NS87415_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USBIP_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DAC02_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH10K_TRACING: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_BR2684_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPARSEMEM_VMEMMAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CAMELLIA_X86_64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IB700_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_USHC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_CB_PCIDAS64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_TLE62X0_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET6_IPCOMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SONY_LAPTOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QLCNIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMCG_KMEM: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SIS_315: ::std::os::raw::c_uint = 1;
pub const CONFIG_TPS6507X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IRDA_FAST_RR: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_W6692: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_MARVELL: ::std::os::raw::c_uint = 1;
pub const CONFIG_PHYLIB: ::std::os::raw::c_uint = 1;
pub const CONFIG_IGB_DCA: ::std::os::raw::c_uint = 1;
pub const CONFIG_CIFS_SMB311: ::std::os::raw::c_uint = 1;
pub const CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SHA1_SSSE3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPV6_TUNNEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM77_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_SLAVE_DS2760_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_NVIDIA: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_MEMORY_PROBE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_AMD_FREQ_SENSITIVITY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TDA665x_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SAA7164_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_MRVL_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_874_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_CMDLINE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OPTIMIZE_INLINING: ::std::os::raw::c_uint = 1;
pub const CONFIG_ULTRIX_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_IRQ_DOMAIN: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIRTIO_BALLOON: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOTPLUG_PCI_CPCI_GENERIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_LSM_MMAP_MIN_ADDR: ::std::os::raw::c_uint = 0;
pub const CONFIG_SCSI_ARCMSR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PINCTRL_AMD: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEGRITY_AUDIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_AMPLC_DIO200_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PVPANIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS: ::std::os::raw::c_uint =
    0;
pub const CONFIG_CAN_PEAK_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPS_CLIENT_LDISC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_CMDLINE_PARSER: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_ONENAND_2X_PROGRAM: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_MT20XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_TULIP: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFFS2_RTIME: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPC_NS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_GLUE_HELPER_X86_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_FRITZ_PCIPNP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MISC_FILESYSTEMS: ::std::os::raw::c_uint = 1;
pub const CONFIG_FTRACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNLIMIT_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_ATP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_THERMAL_VECTOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_SECURITY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_RAW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_CC_STACKPROTECTOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_ARPFILTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_LP8788_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_ETT_TC45USB: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIRC_SERIAL_TRANSMITTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_CON: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_SOCKET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_ASILIANT: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPPOL2TP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_TLS8204_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYNCLINK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_ADP5588_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CLOCKSOURCE_WATCHDOG: ::std::os::raw::c_uint = 1;
pub const CONFIG_R8712U_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_TOPSEED_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_RC5T583_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43_PHY_HT: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_VT8623_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_MAX_CARDS: ::std::os::raw::c_uint = 8;
pub const CONFIG_AD7606_IFACE_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_DA9052_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DECOMPRESS_BZIP2: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2800PCI_RT33XX: ::std::os::raw::c_uint = 1;
pub const CONFIG_CORDIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH9K_RFKILL: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_CB_PCIDAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TRIDENT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_AXP20X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADM1029_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_SENSORS_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KSM: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_SUPPORTS_UPROBES: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_STMICRO: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_I3000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARPORT_PC_FIFO: ::std::os::raw::c_uint = 1;
pub const CONFIG_DECNET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOPSTAR_LAPTOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AGP_SIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_H323_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XZ_DEC_SPARC: ::std::os::raw::c_uint = 1;
pub const CONFIG_IMA_LSM_RULES: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_TURBOGRAFX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_SPARSEMEM_DEFAULT: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DMM32AT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_QMI_WWAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_TEAM_MODE_ROUNDROBIN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BOARD_TPCI200_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_RT5033_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_CMA3000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_IE31200_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_ENE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_S6D1121_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ALIM1535_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GIGASET_BASE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INLINE_READ_UNLOCK_IRQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_HYPERV_MOUSE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GACT_PROB: ::std::os::raw::c_uint = 1;
pub const CONFIG_MISDN_ISAR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REALTEK_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PROC_VMCORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_A4TECH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_MC44S803_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KMX61_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_PN544_MEI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_860_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD799X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_MONA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_ESP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NIU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD8366_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_PS2_VMMOUSE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_TARGET_NETMAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SPCA505_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_REJECT_IPV6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RCU_CPU_STALL_TIMEOUT: ::std::os::raw::c_uint = 60;
pub const CONFIG_BACKLIGHT_ADP5520_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SQ905C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_842_COMPRESS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_VITESSE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ZR364XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHECKPOINT_RESTORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PRINTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_ISL1208_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_MENF21BMC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DIVAS_DIVACAPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_CS4265_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_VERBOSE_PROCFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_HMC5843_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_FIREWIRE_LIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INT340X_THERMAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DA9052_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CFG80211_DEBUGFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIUART_BCM: ::std::os::raw::c_uint = 1;
pub const CONFIG_LAPB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_GYRO_3AXIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY: ::std::os::raw::c_uint =
    2048;
pub const CONFIG_IP_ROUTE_MULTIPATH: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_PCF2123_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DIVAS_USERIDI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_MIC_CARD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_LNBP21_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_NETDEV_FRONTEND: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TDA10048_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_FF_MEMLESS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARAVIRT_CLOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_BMP085_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_FSL_SAI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_F_PRINTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_W83627HF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHR_DEV_SG: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CDC_PHONET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_HASH_NET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_DSMARK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_AD1889_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SSB_DRIVER_PCICORE_POSSIBLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MISDN_AVMFRITZ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_RESERVE_LOW: ::std::os::raw::c_uint = 64;
pub const CONFIG_SMS_SDIO_DRV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFSD_PNFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NEED_SG_DMA_LENGTH: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_AXP20X_PEK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_MPU401_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_CX24116_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_POWER_RESET: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_XCBC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_AMANDA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPW2200_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_MARK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_QT2160_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADT7411_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IXGBE_DCA: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_GPIO_CIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_MATCH_IPV6HEADER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MACVLAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FWTTY_MAX_CARD_PORTS: ::std::os::raw::c_uint = 32;
pub const CONFIG_TPS6105X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_PDC_OLD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_L2TP_V3: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8723_COMMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHELSIO_T1_1G: ::std::os::raw::c_uint = 1;
pub const CONFIG_BPF_JIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_INTERRUPT_TRIGGER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_INA2XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WLCORE_SDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_ARK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_IFORCE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCIEASPM_DEFAULT: ::std::os::raw::c_uint = 1;
pub const CONFIG_PROFILING: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCF50633_ADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTERVAL_TREE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_ST7735R_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCNET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8731_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IOSF_MBI: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_ALI15X3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPARSEMEM: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET6_XFRM_MODE_TRANSPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_FAN53555_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADDI_APCI_2032_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_ARC4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_DA9210_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_REGULATOR_HAPTIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IEEE802154_6LOWPAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LUSTRE_OBD_MAX_IOCTL_BUFFER: ::std::os::raw::c_uint = 8192;
pub const CONFIG_VHOST_NET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_TEA6415C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_STV0900_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_NFORCE2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_DIGI_ACCELEPORT_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_USB_GL860_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GRACE_PERIOD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SLHC: ::std::os::raw::c_uint = 1;
pub const CONFIG_R8188EU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_TEHUTI: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_LTC3589_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_UFSHCD_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ALS300_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADT7316_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ALTERA_TSE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_GPIO_POLLED_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_MANAGER: ::std::os::raw::c_uint = 1;
pub const CONFIG_PHY_SAMSUNG_USB2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_MEI_TXE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_IPR_TRACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_HTB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EEPROM_AT24_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UIO_SERCOS3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_CP2112_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOSTAP_FIRMWARE_NVRAM: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPP_BSDCOMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCHED_SMT: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_TTUSB2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_CIFS_STATS: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT_MUTEXES: ::std::os::raw::c_uint = 1;
pub const CONFIG_LOCK_SPIN_ON_OWNER: ::std::os::raw::c_uint = 1;
pub const CONFIG_WLCORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_ORTEK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_MARK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AR5523_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_MXL5007T_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CX_ECAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_I2C_SIL164_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MD_LINEAR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_INIC162X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HUGETLBFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHECK_SIGNATURE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TDA10021_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX231XX_DVB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KERNFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_INTEL_MPX: ::std::os::raw::c_uint = 1;
pub const CONFIG_WL1251_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_ALGOBIT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPV6_SUBTREES: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_BLOCK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CLS_FW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KVM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DEV_CCP: ::std::os::raw::c_uint = 1;
pub const CONFIG_PAGE_COUNTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SIMPLE_CARD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ABX500_CORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_SLAVE_DS2781_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SAA7185_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SAA7134_DVB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_BQ27X00_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_FORE200E_DEBUG: ::std::os::raw::c_uint = 0;
pub const CONFIG_EXPERT: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_PCAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DRV_HISAX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATL1C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_SANYO_DECODER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DMAR_TABLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_INTEL_LPSS_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HW_RANDOM_INTEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LCD_LTV350QV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIRC_SERIAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LXT_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_MB862XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_MT9V011_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_ALC5623_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_M_CAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIRELESS: ::std::os::raw::c_uint = 1;
pub const CONFIG_WEXT_PROC: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCMA_DRIVER_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_SQUASHFS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_6LOWPAN_NHC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_I7CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HZ_250: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_N411_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_IO_APIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_DELL_WMI_AIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ALS4000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_KONICA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCG_TIS_I2C_ATMEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8770_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_TBF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PKCS7_MESSAGE_PARSER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIBTUSB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_LED_TRIG: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_ILI9481_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_CX22702_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KGDB: ::std::os::raw::c_uint = 1;
pub const CONFIG_LTR501_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIO_RAW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TASK_IO_ACCOUNTING: ::std::os::raw::c_uint = 1;
pub const CONFIG_FAT_DEFAULT_IOCHARSET: &'static [u8; 10usize] =
    b"iso8859-1\x00";
pub const CONFIG_UWB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ASYNC_XOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_MASS_STORAGE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_CAPI_MIDDLEWARE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_CLS_RSVP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TIPC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENEVE_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMORY_HOTPLUG_SPARSE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_ILI9163_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_STB6100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W83977F_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MD_RAID0_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FRAME_WARN: ::std::os::raw::c_uint = 1024;
pub const CONFIG_NET_VENDOR_AGERE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_CDC_NCM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_GENERIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SIS_300: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACT200L_DONGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_VSYSCALL_EMULATION: ::std::os::raw::c_uint = 1;
pub const CONFIG_DUMMY_IRQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_DWC2_HOST: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_HACKRF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7303_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HP_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DAS08_ISA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_DATAFLASH_OTP: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_USB_DRIVERS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCM87XX_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_DESIGNWARE_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ASYNC_RAID6_TEST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ETH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_SCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_VIM2M_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_ILI9320_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_ADAU1701_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_TWL4030_MADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_HWEIGHT: ::std::os::raw::c_uint = 1;
pub const CONFIG_INITRAMFS_SOURCE: &'static [u8; 1usize] = b"\x00";
pub const CONFIG_RTL_CARDS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_NETCELL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_IMS_PCU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DHT11_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS1374_WDT: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_CLIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_RTD520_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_CODEC_SIGMATEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CGROUPS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_AXP20X: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_RT5670_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_USB_CAIAQ_INPUT: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC: ::std::os::raw::c_uint = 1;
pub const CONFIG_LZO_COMPRESS: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_PHONET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIRTIO_INPUT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DELL_RBTN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_GUNZE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SEQIV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_CACHE_CLEANER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRCMFMAC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_QUATECH_DAQP_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_AD7877_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_POWER_SAVE_DEFAULT: ::std::os::raw::c_uint = 0;
pub const CONFIG_TTY_PRINTK: ::std::os::raw::c_uint = 1;
pub const CONFIG_9P_FSCACHE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_LOGITECH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_INDIGODJX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_I4L_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCNET_COM90xx_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VME_BUS: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_LOG_USERSPACE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_GAMECON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_USER_API_RNG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_ENCLOSURE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAPI_EICON: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_SP887X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_STACKTRACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_EMATCH_CANID_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TAHVO_USB_HOST_BY_DEFAULT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM92_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXTCON: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADDI_APCI_3120_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_SAS_LIBSAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISCSI_TARGET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IMA_MEASURE_PCR_IDX: ::std::os::raw::c_uint = 10;
pub const CONFIG_HAVE_ACPI_APEI: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCNET_RIM_I_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_NETLINK_QUEUE_CT: ::std::os::raw::c_uint = 1;
pub const CONFIG_OPROFILE_NMI_TIMER: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_RADISYS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOSHIBA_HAPS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPV6_GRE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_IDLETIMER_MODULE: ::std::os::raw::c_uint
          =
    1;
pub const CONFIG_FB_ATY128_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VFIO_PCI_INTX: ::std::os::raw::c_uint = 1;
pub const CONFIG_BMG160_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UIO_AEC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_PM8001_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_IMX074_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_RNDIS_WLAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_TUNER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IFB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_ACCEL_3AXIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_FUNCTIONFS_ETH: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCS3472_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_LP3944_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SEVSEG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_8723AU_AP_MODE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_MPU401_UART_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPV6_VTI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DRBG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_PCF8563_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_MAX_CARDS: ::std::os::raw::c_uint = 32;
pub const CONFIG_PPTP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_MSI001_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_V2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_SMSC47M1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_USB_US122L_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CDC_COMPOSITE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_DSBR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISCSI_IBFT_FIND: ::std::os::raw::c_uint = 1;
pub const CONFIG_KGDB_KDB: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_I2C_ADV7511_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DCB: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCIPCWATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CGROUP_CPUACCT: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_OTI6858_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_SC16IS7XX_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACTISYS_DONGLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_GO7007_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_BCM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAS_IOPORT_MAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_TI_CPSW_ALE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_CMPXCHG64: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SAA7146_VV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CARL9170_HWRNG: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH10K_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_PEAK_PCMCIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_VIA: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ATM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISA_DMA_API: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_FDOMAIN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HZ: ::std::os::raw::c_uint = 250;
pub const CONFIG_IIO_SIMPLE_DUMMY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_8250_SHARE_IRQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_UCB1400_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_ACT_VLAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IXGBE_HWMON: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_RTL8152_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NEED_MULTIPLE_NODES: ::std::os::raw::c_uint = 1;
pub const CONFIG_ECHO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_F_UAC2: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_HELPER_AUTO: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_U32_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_AMPLC_DIO200_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SONY_BTF_MPX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SQUASHFS_ZLIB: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX23885_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA49WLC: ::std::os::raw::c_uint = 1;
pub const CONFIG_AGP_INTEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_INLINE_SPIN_UNLOCK_IRQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_ISO8859_4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_AD7879_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_OAKTRAIL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_MTS64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADE7759_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_BACKLIGHT: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_RX8025_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_8250_NR_UARTS: ::std::os::raw::c_uint = 48;
pub const CONFIG_TCP_CONG_DCTCP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_MAX8997_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_EMATCH_IPSET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TI_AM335X_ADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7291_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_SRPT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_RMD160_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_IMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCM7XXX_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_HPT366_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_EATA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIS3L02DQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_AUTO_XLATE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_ARC: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_HASH_MAC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_IPATH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_BD663474_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET_AH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ATXP1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_LENOVO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_USER_RETURN_NOTIFIER: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_UBI_BEB_LIMIT: ::std::os::raw::c_uint = 20;
pub const CONFIG_DEFAULT_IOSCHED: &'static [u8; 9usize] = b"deadline\x00";
pub const CONFIG_DRM_I2C_CH7006_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TABLET_USB_KBTAB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UDF_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS1343_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_INTEL_BYTCR_RT5640_MACH_MODULE:
          ::std::os::raw::c_uint =
    1;
pub const CONFIG_IPV6_MIP6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADIS16060_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MARVELL_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_PERF_USER_STACK_DUMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_EC_DEBUGFS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VXFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_SCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CGROUP_PERF: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLATTR: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_LOLA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_CAPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOTPLUG_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ADIS_LIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ZD1211RW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCP_CONG_CUBIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_CEPH_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_NETLINK: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_BD6107_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCG_TIS_ST33ZP24_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NR_CPUS: ::std::os::raw::c_uint = 256;
pub const CONFIG_IXGBE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SUSPEND_FREEZER: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_BUFFER_CB: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIRC_IMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_SDHCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_CRYSTAL_COVE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_MOUSE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43_SSB: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SUPPORT_OLD_API: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_DIB7000M_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_CONNMARK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_ACCEL_SPI_3AXIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_LT3593_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LOGITECH_FF: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_AF9033_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_KYE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_PS2_TRACKPOINT: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CHACHA20_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_VSXXXAA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FIRMWARE_IN_KERNEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_TM6000_ALSA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_COMPAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IDMA64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_PCA963X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_NOUVEAU_BACKLIGHT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOFT_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYSFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPWIRELESS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXT4_FS_ENCRYPTION: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_FRPW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_BITMAP_IPMAC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_RICOH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_DEFAULT_PERSIST: ::std::os::raw::c_uint = 1;
pub const CONFIG_PANEL_PARPORT: ::std::os::raw::c_uint = 0;
pub const CONFIG_DVB_MN88473_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_UCB1400_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIB80211_CRYPT_WEP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DELL_WMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SBP_TARGET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_W83791D_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_TOUCHSCREEN: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2800USB_UNKNOWN: ::std::os::raw::c_uint = 1;
pub const CONFIG_RADIO_SI4713_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DSCC4_PCI_RST: ::std::os::raw::c_uint = 1;
pub const CONFIG_RIONET_RX_SIZE: ::std::os::raw::c_uint = 128;
pub const CONFIG_SND_SOC_CS42L51_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_VIAPRO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_HYPERV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_NW80X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_LABELS: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_ADP5520_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_RC5T583_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SM7XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_MATCH_AH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_SRP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYNCLINK_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CARL9170_WPC: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SAA7134_GO7007_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCP_CONG_VENO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_S5H1420_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_88PM800_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_S526_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DAS1800_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_EHCI_HCD_PLATFORM: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_MT9M001_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_NET: ::std::os::raw::c_uint = 1;
pub const CONFIG_ASN1: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_LOG_COMMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_PARPORT_LIGHT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_LIMIT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_AES_NI_INTEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_SHDLC: ::std::os::raw::c_uint = 1;
pub const CONFIG_ULI526X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SHA1_MB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_BU21013_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CC_STACKPROTECTOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_SIMTEC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SMSCUFX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NTB_TRANSPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XZ_DEC_ARM: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEFAULT_IO_DELAY_TYPE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_775_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_EEM: ::std::os::raw::c_uint = 1;
pub const CONFIG_IRLAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTLLIB_CRYPTO_TKIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_SERIAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_HASH_INFO: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SYS_FOPS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_ANALOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MISDN_HFCPCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIMAX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_SYSCALL_TRACEPOINTS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_ST_NCI_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_XC4000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_DEVGROUP_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_ACPI_BATTERY: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_TAS571X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_LGDT3305_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMSTICK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUJITSU_TABLET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_PRESS_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_MPR121_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_USBTV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_DEVFREQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_JANZ_CMODIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_ELSA: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SAA7146_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_SPINAND_MT29F_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_COMPLEX_MAPPINGS: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_DA9030_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IMA_NG_TEMPLATE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TRACING: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_SYSFS_TRIGGER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_MATCH_RPFILTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_865_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_COMPAT: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_OPENCORES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFSD_V3_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_SSM4567_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SPCA500_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_UCB1400_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPARSEMEM_VMEMMAP_ENABLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_TRIGGER_CPU: ::std::os::raw::c_uint = 1;
pub const CONFIG_PC300TOO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_ELO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPVLAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_LABPC_ISADMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_ACT_NAT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_DS2780_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_PORT100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FTRACE_MCOUNT_RECORD: ::std::os::raw::c_uint = 1;
pub const CONFIG_OCFS2_FS_STATS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_SKY81452_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIRTUALIZATION: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_ZORAN_DC10_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MSDOS_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CHIPIDEA_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_RTI800_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MYRI10GE_DCA: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIUART_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TEST_STRING_HELPERS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_NEXIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE: ::std::os::raw::c_uint = 0;
pub const CONFIG_RT2800USB_RT33XX: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8903_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_LNBP22_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_WM831X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PINCTRL_INTEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_TPS6586X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_ADP5588_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_TMP421_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8804_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_RADEON_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_RTL2832_SDR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SN9C2028_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SUNGEM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_OPROFILE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_STREAMZAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDSPM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_PEAK_PCIEC: ::std::os::raw::c_uint = 1;
pub const CONFIG_EFI_VARS_PSTORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_INTEL_LPSS: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_CLEVO_MAIL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TEST_UDELAY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_IDLE_GOV_LADDER: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_THERMAL: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_BUDGET_PATCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_XHCI_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_TOUCHRIGHT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AMD8111_ETH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADL_PCI8164_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_ACPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_AMD_IOMMU: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_AMD8111_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_POWERMATE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_FC: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_S3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DGAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRCMUTIL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TTUSB_BUDGET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VETH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_PCF8583_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_MT312_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MLX5_CORE_EN: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_TPS65912_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_3COM: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_DUMMY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAX517_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_PETALYNX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AMD_NUMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_PCMCIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_ATY_CT: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADXRS450_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TLAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_MIC_BUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_AMPLC_PCI230_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_CODEC_VIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CMDLINE_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMSTICK_TIFM_MS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_LANE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMMON_CLK_PWM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_W83L786NG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_PCM1681_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_ACT_MIRRED_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_ARCH_KGDB: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_USE_QUEUED_SPINLOCKS: ::std::os::raw::c_uint = 1;
pub const CONFIG_IMA_DEFAULT_HASH: &'static [u8; 5usize] = b"sha1\x00";
pub const CONFIG_INPUT_APANEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_ABLK_HELPER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43_PCICORE_AUTOSELECT: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_IPV4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QLCNIC_SRIOV: ::std::os::raw::c_uint = 1;
pub const CONFIG_MYRI10GE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_PM_TIMER: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_VL600_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ZONE_DMA_FLAG: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_BPCK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_HID_SENSOR_TIME_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43LEGACY_HWRNG: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_INTEL_CHT_BSW_RT5672_MACH_MODULE:
          ::std::os::raw::c_uint =
    1;
pub const CONFIG_BATTERY_BQ27x00_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH9K_BTCOEX_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_SOFTING_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2X00_LIB_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_DUMMY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_DEBUG_FPU: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_MVSAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADIS16260_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_INTEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_WUSB_CBAF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_PN544_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_TAS2552_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RPS: ::std::os::raw::c_uint = 1;
pub const CONFIG_PACKET_DIAG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_AU8522_DTV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_ST5481_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_ZAURUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEVFREQ_GOV_PERFORMANCE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET6_XFRM_TUNNEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_AST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_MULTIPATH_ST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_TEAM_MODE_RANDOM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_DW_MID_DMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM95241_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PROC_PID_CPUSET: ::std::os::raw::c_uint = 1;
pub const CONFIG_REALTEK_AUTOPM: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_AX88179_178A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_METRONOME_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_TABLES_BRIDGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_MV_U3D_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD525X_DPOT_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_GAUGE_LTC2941_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEGACY_PTY_COUNT: ::std::os::raw::c_uint = 0;
pub const CONFIG_MEDIA_TUNER_E4000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_ATLAS_BTNS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACQUIRE_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_WAKELOCKS_LIMIT: ::std::os::raw::c_uint = 100;
pub const CONFIG_VIDEO_SAA6588_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_DMC_TSC10: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_ZL10039_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAPI_AVM: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_2: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_AUDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_REJECT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WDTPCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_DEBUG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_MAX16064_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_DENALI_DT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SET_HASH_IPPORTIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MLX4_EN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_DSTR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TABLET_USB_ACECAD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HYPERVISOR_GUEST: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM70_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_MAX310X: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_SMACK_NETFILTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_EMATCH_NBYTE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_BH1770_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NORTEL_HERMES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SIS190_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS: ::std::os::raw::c_uint = 1;
pub const CONFIG_RAPIDIO_DMA_ENGINE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_BDC_UDC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCG_NSC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ZISOFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIMAX_I2400M_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CUSE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8728_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_BROADSHEET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HTC_PASIC3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ZERO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_CRYPTOLOOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_WM97XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_TABLES_IPV4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_MULTICAST: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_RADEON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_CACHE_SMQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_RMD256_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_INTEL_HASWELL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_MT352_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RC_ATI_REMOTE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W83627HF_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SQUASHFS_XZ: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_VOODOO1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_CX82310_ETH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_CMOS_UPDATE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_CISCO: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_AS3711_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EEPROM_MAX6875_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_ALS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_MASTER_MATROX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_CIRRUS_QEMU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_APPLETOUCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_LOGITECH_DJ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEFAULT_SECURITY: &'static [u8; 9usize] = b"apparmor\x00";
pub const CONFIG_MFD_DLN2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_STK1160_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TICK_ONESHOT: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_HFCUSB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_I740_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_PCIDEV_FRONTEND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_BETOP_FF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_PROTO_UDPLITE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_SIERRAWIRELESS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CTR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_TPS6586X: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_XIRC2PS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMPAT_FOR_U64_ALIGNMENT: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTRR_SANITIZER: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_STV090x_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_HPTIOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NATIONAL_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43LEGACY_PCICORE_AUTOSELECT: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CONFIGFS_F_LB_SS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_DW_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_PDA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_TW68_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DE_AOC: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIRELESS_EXT: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_MT2060_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_PICOLCD_BACKLIGHT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_RT5640_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADV_PCI1710_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I40E_VXLAN: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_CODEC_CA0110_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_TPS65910: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_ST_NCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_RS5C348_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MODVERSIONS: ::std::os::raw::c_uint = 1;
pub const CONFIG_HW_RANDOM: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43_PCI_AUTOSELECT: ::std::os::raw::c_uint = 1;
pub const CONFIG_MUTEX_SPIN_ON_OWNER: ::std::os::raw::c_uint = 1;
pub const CONFIG_NCPFS_STRONG: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_LEGACY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IO_DELAY_TYPE_0X80: ::std::os::raw::c_uint = 0;
pub const CONFIG_DVB_USB_AU6610_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_LEDS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_LM70_LLP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_SPEEDSTEP_LIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IE6XX_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIBTUSB_RTL: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYS_HYPERVISOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_DMA_ATTRS: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_WACOM_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_IA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IRNET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TRACE_ROUTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_VIRTUOSO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AMIGA_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_EARLY_PRINTK: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8804_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_THINKPAD_ACPI_ALSA_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_CGROUP_NET_CLASSID: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_AR7_PARTS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMCG_SWAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADS7871_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_SYNPROXY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FS_DAX: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_737_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_IPV4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_FUNCTION_GRAPH_TRACER: ::std::os::raw::c_uint = 1;
pub const CONFIG_HW_RANDOM_VIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SUNDANCE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_W83781D_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_DESIGNWARE_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_SOFTING_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_CMPXCHG_LOCAL: ::std::os::raw::c_uint = 1;
pub const CONFIG_LNET_XPRT_IB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEOBUF2_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_COMM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SSB_DRIVER_GPIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_IRTTY_SIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_ARIZONA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EEEPC_WMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_ADXL34X_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NTFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_AU0828_V4L2: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MAX8998_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_THERMAL: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2X00_LIB_CRYPTO: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_PERIODIC_RTC_TRIGGER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_DH_HP_SW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_SCTP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_STB0899_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_SOC_BUTTON_ARRAY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_P54_PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_ADP5520_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_8250_DMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_BASE_SMALL: ::std::os::raw::c_uint = 0;
pub const CONFIG_LUSTRE_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IWLEGACY_DEBUGFS: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADE7854_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_GRANT_DEV_ALLOC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_PPP_BSDCOMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_WAKELOCKS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_BLKCIPHER2: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_SAS_ATTRS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_SELINUX_AVC_STATS: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8187_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEVPTS_MULTIPLE_INSTANCES: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SEQ_DUMMY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_AES_X86_64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43LEGACY_PCI_AUTOSELECT: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_RAID_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMPACTION: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_V2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_HCD_BCMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADE7854_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_MPT3SAS_MAX_SGE: ::std::os::raw::c_uint = 128;
pub const CONFIG_CAN_SJA1000_ISA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TDA18271C2DD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QLGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_AIRSPY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ALIENWARE_WMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_TM6000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_CXD2820R_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WM8350_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_TDA7432_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TEST_POWER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIMAX_GDM72XX_USB: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8723BE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS2404_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_ERA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_DAQ_DIO24_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SONIXJ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_ALTERA_UART_BAUDRATE: ::std::os::raw::c_uint = 115200;
pub const CONFIG_THINKPAD_ACPI_HOTKEY_POLL: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_F81232_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_AMDGPU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_OV7670_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS1553_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_HAMPSHIRE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_KHAZAD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_TSC2005_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PROC_FS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_CB710_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_PACKET_ENGINE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_BLOCK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_OXFW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MPL3115_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_HOTPLUG_MEMORY: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEOBUF2_VMALLOC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_BRIDGE_REJECT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_BUG_RELATIVE_POINTERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8523_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_6LOWPAN_NHC_FRAGMENT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_TOMOYO: ::std::os::raw::c_uint = 1;
pub const CONFIG_RC_MAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LCD_S6E63M0_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WEXT_PRIV: ::std::os::raw::c_uint = 1;
pub const CONFIG_THINKPAD_ACPI_VIDEO: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIRTIO_MMIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_ROCKER: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_LOWLEVEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_ROSE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_SOC_DTS_IOSF_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_GPIO_ROTARY_ENCODER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_PROTO_AH_ESP: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_QINFO_PROBE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_DRV260X_HAPTICS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IRQ_FORCED_THREADING: ::std::os::raw::c_uint = 1;
pub const CONFIG_NILFS2_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH9K_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_ATOMIC_SCRUB: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_HID_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_YAMA_STACKED: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_ISO8859_3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RSI_91X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_OPENCORES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_SYS_HYPERVISOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CMAC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIMAX_GDM72XX_K_MODE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PCL816_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_PANTHERLORD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTDRAM_ERASE_SIZE: ::std::os::raw::c_uint = 128;
pub const CONFIG_TEST_KSTRTOX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_ICHXROM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_INTEL_SST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_GYRO_I2C_3AXIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_TEQL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMSTICK_JMICRON_38X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_MCP3021_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SALSA20_X86_64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_RC6_DECODER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_NETDEV_BACKEND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_LP3943_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_ABB5ZES3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_DENALI_SCRATCH_REG_ADDR: ::std::os::raw::c_uint =
    4279271448;
pub const CONFIG_SCSI_SNIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KXCJK1013_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_OOPS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IWLEGACY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_INIA100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_S2IO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_SH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_BALLOON: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_DOCG4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_MSP3400_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_BT856_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_OBEX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PLIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_EATA_TAGGED_QUEUE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SERPENT_AVX_X86_64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_PEGASUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MAX77843_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_MAGN_3AXIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_UC1701_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_TMC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8962_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_E3X0_BUTTON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_G_WEBCAM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SBC_EPX_C3_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_HE_USE_SUNI: ::std::os::raw::c_uint = 1;
pub const CONFIG_PAGEFLAGS_EXTENDED: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_FD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LCD_HX8357_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPPP_FILTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_V4L_PLATFORM_DRIVERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_SLAVE_DS2408_READBACK: ::std::os::raw::c_uint = 1;
pub const CONFIG_EVM: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_PCSP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_NVIDIA_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_RFKILL_INPUT: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_USB6501_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_CIRRUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_NATSEMI: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_MUSB_DUAL_ROLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_BSGLIB: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH5K_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_FC2580_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TABLET_USB_HANWANG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_MASS_STORAGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_AAT2870_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MENF21BMC_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH9K_COMMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_STB6000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QLCNIC_VXLAN: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_MISC_DRIVERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_QCAUX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_ACARD_AHCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_USE_KERNEL_DNS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MISDN_SPEEDFAX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_IBMAEM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DMA_ENGINE_RAID: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_MIC_HOST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIRC_STAGING: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_I915: ::std::os::raw::c_uint = 1;
pub const CONFIG_QCOM_SPMI_VADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIMAX_GDM72XX_WIMAX2: ::std::os::raw::c_uint = 1;
pub const CONFIG_LATTICE_ECP3_CONFIG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYSCTL: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DES3_EDE_X86_64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_842_DECOMPRESS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_HAS_GCOV_PROFILE_ALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_IGMP_SNOOPING: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_TARGET_CLUSTERIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_BLOCK2MTD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_SLAVE_THERM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_SLCAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_KBIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_TWIDJOY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PHYS_ADDR_T_64BIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DT2815_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA19QI: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_M88DS3103_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NOZOMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PCL711_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_DWC3_ULPI: ::std::os::raw::c_uint = 1;
pub const CONFIG_MLX4_EN_DCB: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_842_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_AUDIT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VT6655_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_PIXCIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOSTAP_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WM831X_BACKUP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_C_RECORDMCOUNT: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_MSI_IRQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADCXX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_CS4281_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_8255_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LCD_LD9040_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_MT2131_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_DELL_SMM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_THINGM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_KALMIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_TTUSBIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH6KL_SDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_DM9601_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_ARCH_TRACEHOOK: ::std::os::raw::c_uint = 1;
pub const CONFIG_SSB_PCIHOST: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_MCEUSB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_OSD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_ACCEL_I2C_3AXIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LDM_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_CIFS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SMSC37B787_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XFRM_USER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_1TR6: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCP_CONG_BIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXTCON_PALMAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_PCA9532_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TASK_DELAY_ACCT: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_IGORPLUGUSB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_PCF50633_PMU_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_DA9063_ONKEY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_DH_EMC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXTCON_USB_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_NS: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ISP1760_DUAL_ROLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_TMP401_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_BALLOON_MEMORY_HOTPLUG_LIMIT: ::std::os::raw::c_uint =
    512;
pub const CONFIG_REGULATOR_MAX1586_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REISERFS_FS_XATTR: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADT7475_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMORY: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_PERF_EVENTS: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_XIRCOM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_II_PCI20KC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_SCT_QUADRO: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_MANTIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LIS3_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2800PCI_RT35XX: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_C_CAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BTT: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATA_SFF: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_MENF21BMC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_WALKERA0701_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_LRW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS1685_FAMILY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_WM8350_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IWLWIFI_OPMODE_MODULAR: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_EMATCH_CMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_T613_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_VIA82XX_MODEM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8580_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_MTPAV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPP_ASYNC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MD_RAID10_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_ALIGNED_STRUCT_PAGE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NO_BOOTMEM: ::std::os::raw::c_uint = 1;
pub const CONFIG_SSB_SDIOHOST_POSSIBLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_APPLESMC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_GW_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_CODEPAGE_866_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ABITUGURU3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRAMFS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RADIO_SAA7706H_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SKGE_GENESIS: ::std::os::raw::c_uint = 1;
pub const CONFIG_WM831X_POWER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PINCTRL_SUNRISEPOINT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_TRIGGER_TRANSIENT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CYCLADES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_LM8323_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_STMMAC_ETH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHELSIO_T1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_AIO_AIO12_8_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFSD_V4_SECURITY_LABEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_CEPH_FS_POSIX_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_PMEM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AUDIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHR_DEV_ST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_TPS65910_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATTERY_RT5033_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_IOMMU: ::std::os::raw::c_uint = 1;
pub const CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_MULTIPATH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_USER_API_SKCIPHER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_3W_SAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_ATMIO16D_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_RN5T618_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MC13892_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM80_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CMA_AREAS: ::std::os::raw::c_uint = 7;
pub const CONFIG_PCIEASPM: ::std::os::raw::c_uint = 1;
pub const CONFIG_PM_ADVANCED_DEBUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_TSL2x7x_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VME_TSI148_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATA_PIIX: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43LEGACY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AIC7XXX_REG_PRETTY_PRINT: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_MULTITOUCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_HDLC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ECRYPT_FS_MESSAGING: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_DEFERRED_IO: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_AHCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_MITE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIMAX_GDM72XX_USB_PM: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_A800_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_INTEL_CHT_BSW_RT5645_MACH_MODULE:
          ::std::os::raw::c_uint =
    1;
pub const CONFIG_XEN_BALLOON_MEMORY_HOTPLUG: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_SI470X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_A8293_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ASC7621_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OPTPROBES: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_AMD5536UDC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_BQ2415X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_NETJET_U: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETXEN_NIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BNX2X_SRIOV: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_NUMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_TCP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GR_UDC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_ISL9305_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_ELECOM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_TFT_PCD8544_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_TIMER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ICP_MULTI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_R128_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KVM_MMIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_EHCI_TT_NEWSCHED: ::std::os::raw::c_uint = 1;
pub const CONFIG_FAT_DEFAULT_CODEPAGE: ::std::os::raw::c_uint = 437;
pub const CONFIG_TCM_FC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPV6_MROUTE_MULTIPLE_TABLES: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_TLV320AIC31XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIO_I8042: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC80211_RC_DEFAULT: &'static [u8; 12usize] =
    b"minstrel_ht\x00";
pub const CONFIG_FARSYNC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8187_LEDS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_ACL_SUPPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2800USB_RT55XX: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_SLAVE_DS2433_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHROME_PLATFORMS: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATL1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_APPLICOM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_NI1: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_OMNINET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HDLC_PPP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_AMD_PLATFORM_DEVICE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_NETFILTER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCP_CONG_SCALABLE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_MB86A20S_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_TRIFLEX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PCL818_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_TMDC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MCP4922_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_ALTERA_UART_MAXPORTS: ::std::os::raw::c_uint = 4;
pub const CONFIG_IOMMU_API: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_GENERIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TRACING_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_UNIX98_PTYS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CDROM_PKTCDVD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MS_BLOCK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VFIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_MICROREAD_MEI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CONNMARK_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_MINIX_SUBPARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHROMEOS_PSTORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_RX_BUSY_POLL: ::std::os::raw::c_uint = 1;
pub const CONFIG_RADIO_WL1273_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_SMSC47B397_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_MICHAEL_MIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_ANSI_CPRNG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SECURITY_SELINUX: ::std::os::raw::c_uint = 1;
pub const CONFIG_ZONE_DMA32: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCHED: ::std::os::raw::c_uint = 1;
pub const CONFIG_LCD_LMS501KF03_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CONNSECMARK_MODULE:
          ::std::os::raw::c_uint =
    1;
pub const CONFIG_UWB_I1480U_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PCL726_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIQUIDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_STAGING_MEDIA: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_PANEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_PLL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PRINTK_TIME: ::std::os::raw::c_uint = 1;
pub const CONFIG_PANEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_JSM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_MOUSEDEV_SCREEN_Y: ::std::os::raw::c_uint = 768;
pub const CONFIG_SECCOMP_FILTER: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_HPT37X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UIO_PCI_GENERIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPP: ::std::os::raw::c_uint = 1;
pub const CONFIG_RFD_FTL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_QUOTA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TI_ST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_MAY_HAVE_PC_FDC: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_PIE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_TPS65217_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_ATMEL_MXT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KERNEL_LZO: ::std::os::raw::c_uint = 1;
pub const CONFIG_ASYNC_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_MULTIQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET_DIAG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_GHASH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OCFS2_DEBUG_MASKLOG: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_WM8741_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYNCLINKMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PSTORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_LPFC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_FTP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC80211_RC_MINSTREL: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_RMD320_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_CONSUMERS_PER_TRIGGER: ::std::os::raw::c_uint = 2;
pub const CONFIG_NF_CT_PROTO_UDPLITE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CARDMAN_4000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IO_DELAY_TYPE_UDELAY: ::std::os::raw::c_uint = 2;
pub const CONFIG_SPEAKUP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_TARGET_SYNPROXY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HANGCHECK_TIMER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_WARRIOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_AIO_IIRO_16_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_W83627EHF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ELF_CORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEV_COREDUMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_NOTIFIER_ERROR_INJECTION_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM73_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIA_VELOCITY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_PC87360_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TEXTSEARCH: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_AMDGPU_USERPTR: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_IVTV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_DOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_DWC3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KS8851_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_HAVE_PVMMU: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_JEDECPROBE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CT_NETLINK_HELPER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_ON_DEMAND_PAGING: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_ONENAND_VERIFY_WRITE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA19QW: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_PCF8574_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_OV9640_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_SCMI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_VIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_POLLDEV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_MAX8925_ONKEY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_INTEL8X0M_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_FUSBH200_HCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MODIFY_LDT_SYSCALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_UPROBE_EVENT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADC128D818_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_RC_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEMPLD_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_BQ32K_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_PAC7311_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PCMAD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIA_WDT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_NVME_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRCMFMAC_PROTO_BCDC: ::std::os::raw::c_uint = 1;
pub const CONFIG_TWL4030_CORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_HWA_HCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_ZYNQMP_GQSPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_EASYTOUCH: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_LP8860_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_STAGING: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_SIS: ::std::os::raw::c_uint = 1;
pub const CONFIG_F2FS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_EDT_FT5X06_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WL_MEDIATEK: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_RL6347A_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_RIVA_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LIS3LV02D_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET_LRO: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXTCON_MAX14577_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD9523_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_RT5645_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FIREWIRE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMIOTRACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAX63XX_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_ST1232_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIMAX_GDM72XX_QOS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_FC_ATTRS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VT_CONSOLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EDAC_SBRIDGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_UCLOGIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HW_RANDOM_VIRTIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PCMCIA_DRIVERS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_APEI: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ES1968_RADIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SB_COMMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CFG80211_WEXT_EXPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_CS46XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCHED_INFO: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_STK014_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_FTP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FANOTIFY_ACCESS_PERMISSIONS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM3533_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_PRESS_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX18_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XILINX_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VMWARE_PVSCSI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CFG80211_WEXT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_SCCNXP_CONSOLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_EURO: ::std::os::raw::c_uint = 1;
pub const CONFIG_SMARTJOYPLUS_FF: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_XTFPGA_I2S_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_PARPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DIVAS_BRIPCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_PHYSDEV_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_NOP_USB_XCEIV: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_DA9052_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRCMFMAC_PCIE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXTCON_MAX77843_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_VIA82XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DIVAS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CC10001_ADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_PN533_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_ANATOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_DIBUSB_MB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TWL6030_GPADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_DARLA20_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_MAX77843: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_RAM: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_NCM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_AD7879_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMA9553_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_HDAPS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_STATE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_L64781_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_EVBUG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RN5T618_WATCHDOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LOGIRUMBLEPAD2_FF: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_INDIGOIOX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_TPS6586X: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ASIHPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BSD_DISKLABEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_M48T35_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_TAOS_EVM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_CAST_COMMON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_TRIGGERED_BUFFER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_KCOMEDILIB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_HGA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_PVH: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_PCF2127_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STORAGE_FREECOM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LCD_VGG2432A4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_BUSLOGIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_LOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_ADS7846_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_CARILLO_RANCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OPENVSWITCH_VXLAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GADGET_UAC1: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_RC5_DECODER_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_S5M8767_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FIREWIRE_NOSY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_GRED_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI_DIRECT: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_VIA_SDMMC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FUSION_MAX_SGE: ::std::os::raw::c_uint = 128;
pub const CONFIG_RTC_DRV_DA9055_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DOUBLEFAULT: ::std::os::raw::c_uint = 1;
pub const CONFIG_INET6_XFRM_MODE_BEET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7150_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_RADIO_SUPPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCF50633_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IWL4965_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_POSIX_MQUEUE_SYSCTL: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_MAX6900_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ICS932S401_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RIONET_TX_SIZE: ::std::os::raw::c_uint = 128;
pub const CONFIG_RBTREE_TEST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_UNUSED_SYMBOLS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_MAX1111_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_DEV_PADLOCK_AES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ISDN_DRV_AVMB1_B1PCIV4: ::std::os::raw::c_uint = 1;
pub const CONFIG_SAMSUNG_LAPTOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BE2NET_HWMON: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_USS720_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_DAC124S085_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_CFB_COPYAREA: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_ECM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_EFI: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_GPIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SISUSBVGA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_RTL2830_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I40E_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_KVM_IRQCHIP: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_STP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT73USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_ULPI_BUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DE2104X_DSL: ::std::os::raw::c_uint = 0;
pub const CONFIG_BRIDGE_EBT_ARP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BALLOON_COMPACTION: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_MAX8997_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CYTHERM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_TWL4030_AUDIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_MATCH_EUI64_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BINARY_PRINTF: ::std::os::raw::c_uint = 1;
pub const CONFIG_MWIFIEX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HP_ILO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STORAGE_JUMPSHOT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_MAX6642_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_MC33880_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_SGTL5000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_PLUG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_GINA20_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_FREQ_STAT_DETAILS: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_REV_OVERRIDE_POSSIBLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TRACER_MAX_TRACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_KEENE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEOBUF_GEN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_CFI_AMDSTD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CLK_TWL6040_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_WM831X_STATUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DRM_VIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SGI_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_SPARSEKMAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_PALMAS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_TWOFISH_X86_64_3WAY_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_ADIS16400_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AIC7XXX_CMDS_PER_DEVICE: ::std::os::raw::c_uint = 8;
pub const CONFIG_SYSFS_SYSCALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTL8192EE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TCG_XEN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_V4L2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_STV6110_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS1685: ::std::os::raw::c_uint = 1;
pub const CONFIG_AC97_BUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CW1200_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYSVIPC_SYSCTL: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_FIREWORKS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADE7753_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_KEYSPAN_USA19: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_NTRIG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_IPV6: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_64_ACPI_NUMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_DMA_SHARED_BUFFER: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_SYSTOHC: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_NOVA_T_USB2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VHOST_SCSI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CIFS_POSIX: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH_CARDS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_RDC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_PORTMAN2X4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_EPSON2888: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_INDIGODJ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_W83L785TS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_MXUPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_W1_SLAVE_DS28E04_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DECOMPRESS_GZIP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_AW2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_EMC2103_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_MAC_CELTIC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_AU8830_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_SC18IS602_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTLLIB_CRYPTO_WEP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_THERMAL_GOV_POWER_ALLOCATOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIRTIO_BLK: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_8250_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DECOMPRESS_LZO: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_ARK3116_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_64BIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_MIXART_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_QUOTA: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_BT87X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_WM8350_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EARLY_PRINTK_EFI: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM9102_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_NI_MIO_CS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LINEAGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_EMS_PCMCIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_MPT2SAS_MAX_SGE: ::std::os::raw::c_uint = 128;
pub const CONFIG_VXGE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_PCD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ZBUD: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_SDHCI_PLTFM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_I2C_CHARDEV: ::std::os::raw::c_uint = 1;
pub const CONFIG_RCU_NOCB_CPU: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_FC0013_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LLC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_NANDSIM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CROSS_COMPILE: &'static [u8; 1usize] = b"\x00";
pub const CONFIG_FMC_FAKEDEV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MAX8649_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_USE_QUEUED_RWLOCKS: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENWQE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_TEA5761_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_MC13XXX_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SC92031_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGMAP_MMIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_REDIR_IPV4_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_TRIDENT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPDDP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETWORK_SECMARK: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_RIPTIDE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_CTXFI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPMI_SI_PROBE_DEFAULTS: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS_BROADCAST: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_TVAUDIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MAX8907_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RXKAD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_HOLTEK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_GPIO_ADDR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_SAMSUNG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_RANDOM: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_8250_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIB80211_CRYPT_CCMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_MIXED_BREAKPOINTS_REGS: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_DTCS033_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS1672_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_MEI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_SSU100_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BATMAN_ADV_DAT: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_PS2_SYNAPTICS: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATA_BMDMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_SIM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATALK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XZ_DEC_ARMTHUMB: ::std::os::raw::c_uint = 1;
pub const CONFIG_B43_BCMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_RT5631_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD7791_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_SWAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_F_UAC1_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JFFS2_CMODE_FAVOURLZO: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEMORY_FAILURE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFS_V4_1: ::std::os::raw::c_uint = 1;
pub const CONFIG_SKFP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_USE_CMPXCHG_LOCKREF: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_WANT_FRAME_POINTERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGMAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SFC_MCDI_MON: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_DOCG3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_6PACK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_UTF8_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RADIO_SI470X: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCIE_PME: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_TM6000_DVB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_JOYSTICK_XPAD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_ATY_BACKLIGHT: ::std::os::raw::c_uint = 1;
pub const CONFIG_BCMA_HOST_SOC: ::std::os::raw::c_uint = 1;
pub const CONFIG_PHY_PXA_28NM_USB2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_SSM2602_I2C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_ISERT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADIS16130_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BAYCOM_PAR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AB3100_CORE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_DEV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_WM831X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_YEALINK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_VMK80XX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_DIB3000MB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IEEE802154_CC2520_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_PXA27X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_DA9055: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_NCT6683_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD5755_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TI_ADC081C_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPEAKUP_SYNTH_SPKOUT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_M41T80_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_MEN_Z135_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCCARD_NONSTATIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_VT6656_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XEN_SCSI_FRONTEND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_USBNET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CPU_SUP_CENTAUR: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_CS4271_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CB710_CORE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_PL2303_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_ACT_POLICE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AIC79XX_DEBUG_MASK: ::std::os::raw::c_uint = 0;
pub const CONFIG_UEFI_CPER: ::std::os::raw::c_uint = 1;
pub const CONFIG_NODES_SPAN_OTHER_NODES: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_INTEL_TXT: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAMRADIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYSCTL_EXCEPTION_TRACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_M62332_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_PCAP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SYSVIPC_COMPAT: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_PCA953X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_XEN_KBDDEV_FRONTEND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HOTPLUG_PCI_SHPC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADIS16240_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_CINERGY_T2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FHANDLE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FT1000_PCMCIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ADDI_APCI_3XXX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIAL_ALTERA_UART_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_MICROTEK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PANASONIC_LAPTOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_BKM_A4T: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_MC13783_PWRBUTTON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_ENTERNOW_PCI: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_SMARTJOYPLUS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATA_GENERIC: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_INTEL_MID: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_GOODIX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NEW_LEDS: ::std::os::raw::c_uint = 1;
pub const CONFIG_SWAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_TPS80031: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_ONENAND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_BRIDGE_META_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MICROCODE_INTEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_ADC_BATTERY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_ELAN_I2C_I2C: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS1511_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_FIB_TRIE_STATS: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SHA256_SSSE3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TEST_FIRMWARE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATM_FORE200E_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SOLO6X10_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_HFSC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_RV3029C2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_TWL6040_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WIL6210_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ISIGHT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEOBUF_DMA_SG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_NAND_DISKONCHIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC80211_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPI_ALTERA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEGARAID_MM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_USES_PG_UNCACHED: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRC_CCITT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_TS3A227E_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIOLIB_IRQCHIP: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_VENDOR_CAVIUM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TDA8261_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IGBVF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_SD: ::std::os::raw::c_uint = 1;
pub const CONFIG_MFD_MAX14577: ::std::os::raw::c_uint = 1;
pub const CONFIG_PHYSICAL_ALIGN: ::std::os::raw::c_uint = 16777216;
pub const CONFIG_ACPI_LEGACY_TABLES_LOOKUP: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_AD714X_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_NETLINK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VITESSE_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MODULE_UNLOAD: ::std::os::raw::c_uint = 1;
pub const CONFIG_FSCACHE_STATS: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEVFREQ_GOV_USERSPACE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AVERAGE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_MTHCA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_MAX6650_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_BENQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_ACPI_APEI_NMI: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_TPS65023_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_LE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_AC97_CODEC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_WANT_OLD_COMPAT_IPC: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOXA_SMARTIO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_CXUSB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TSL2583_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X25_ASY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2500PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CMA: ::std::os::raw::c_uint = 1;
pub const CONFIG_RWSEM_SPIN_ON_OWNER: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_LM85_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD525X_DPOT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ATIIXP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MEDIA_TUNER_M88RS6000T_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TRACER_SNAPSHOT: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_IPOIB_CM: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_PARPORT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADE7854_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_PICOLCD_LCD: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST: ::std::os::raw::c_uint = 1;
pub const CONFIG_BITREVERSE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFT_MASQ_IPV6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEVPORT: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_CX88_ENABLE_VP3054: ::std::os::raw::c_uint = 1;
pub const CONFIG_INTEL_RST_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X509_CERTIFICATE_PARSER: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_RAM_SIZE: ::std::os::raw::c_uint = 65536;
pub const CONFIG_USB_SERIAL_WWAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_ICE1724_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_CONSOLE_POLL: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ADIS_LIB_BUFFER: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_DA9052_ADC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_XFS_POSIX_ACL: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_WILINK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_PCOMP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_DA9034_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CISS_SCSI_TAPE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ND_BLK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MSI_LAPTOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_DT2801_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRCMFMAC_USB: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_DYNAPRO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_MODE_HELPERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_ISO8859_13_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_MTDRAM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI_PRI: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_SX8_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_BLKCIPHER: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_SKEIN: ::std::os::raw::c_uint = 1;
pub const CONFIG_EXTCON_MAX77693_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_L1_CACHE_SHIFT: ::std::os::raw::c_uint = 6;
pub const CONFIG_X86_PAT: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_STORAGE_ONETOUCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_ISO8859_8_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DM_CACHE_MQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RT2400PCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CONNTRACK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_PCF8523_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_PICOLCD_CIR: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_PANDORA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_GSC_HPDI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_ISL12057_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_NVIDIA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EFI_RUNTIME_WRAPPERS: ::std::os::raw::c_uint = 1;
pub const CONFIG_LCD_CLASS_DEVICE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IPDDP_ENCAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_ARCH_DMA_ADDR_T_64BIT: ::std::os::raw::c_uint = 1;
pub const CONFIG_FILE_LOCKING: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_HPT3X3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_XIRLINK_CIT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AD2S1200_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_STK17TA8_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_GSPCA_SN9C20X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOUCHSCREEN_USB_ELO: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_CHAOSKEY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST: ::std::os::raw::c_uint = 1;
pub const CONFIG_TEST_BPF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_LV5207LP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KARMA_PARTITION: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_SM501_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_I2C_AND_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETPOLL: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_ISADMA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ZSWAP: ::std::os::raw::c_uint = 1;
pub const CONFIG_SPEAKUP_SYNTH_AUDPTR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MAC80211_MESSAGE_TRACING: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_F71882FG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_APEI_GHES: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_CARILLO_RANCH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_ADT7310_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AIO: ::std::os::raw::c_uint = 1;
pub const CONFIG_SERIO_ARC_PS2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_TDA8083_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_MPLS_GSO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RTC_DRV_DS1347_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_DEV_DAC960_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_FOTG210_UDC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CLKEVT_I8253: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_AZ6007_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_USERSPACE_CONSUMER_MODULE: ::std::os::raw::c_uint =
    1;
pub const CONFIG_NET_EMATCH: ::std::os::raw::c_uint = 1;
pub const CONFIG_PERF_EVENTS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMC_REALTEK_USB_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GENERIC_TIME_VSYSCALL: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_NF_TARGET_REJECT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_SCH_CHOKE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_CLASS: ::std::os::raw::c_uint = 1;
pub const CONFIG_COMEDI_BOND_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_DIGITV_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_MATCH_HL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BLK_CPQ_CISS_DA_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TIPC_MEDIA_IB: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_SAA7110_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_L440GX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WINBOND_FIR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_TAB_BITS: ::std::os::raw::c_uint = 12;
pub const CONFIG_COMEDI_NI_AT_AO_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_MATCH_OPTS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_DA9055_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_TWL4030_PWRBUTTON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_SAS_HOST_SMP: ::std::os::raw::c_uint = 1;
pub const CONFIG_VERSION_SIGNATURE: &'static [u8; 47usize] =
    b"Ubuntu 4.2.0-41.48~14.04.1-generic 4.2.8-ckt11\x00";
pub const CONFIG_RTC_INTF_DEV: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_4: ::std::os::raw::c_uint = 1;
pub const CONFIG_IIO_ST_SENSORS_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DCACHE_WORD_ACCESS: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP6_NF_TARGET_NPT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SOC_CAMERA_OV9740_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_USB_CE6230_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PARIDE_ATEN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEFAULT_DEADLINE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INFINIBAND_CXGB3_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SERIAL_SYMBOL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHARGER_MAX77693_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HERMES_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_MAX8952_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_HDMI_CODEC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_OSF_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_MIDI_GADGET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_QSTOR_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WILINK_PLATFORM_DATA: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_GO7007_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_SIS: ::std::os::raw::c_uint = 1;
pub const CONFIG_MESSAGE_LOGLEVEL_DEFAULT: ::std::os::raw::c_uint = 4;
pub const CONFIG_GPIO_TWL4030_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AMD_NB: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_VIRMIDI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LIB80211_CRYPT_TKIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LOCKUP_DETECTOR: ::std::os::raw::c_uint = 1;
pub const CONFIG_QSEMI_PHY_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_PROTO_UDP: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_BT866_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NLS_DEFAULT: &'static [u8; 5usize] = b"utf8\x00";
pub const CONFIG_ACPI_CONTAINER: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_DMA_SGBUF: ::std::os::raw::c_uint = 1;
pub const CONFIG_UTS_NS: ::std::os::raw::c_uint = 1;
pub const CONFIG_IR_HIX5HD2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CT_PROTO_GRE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BT_HCIUART_BCSP: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_S2MPA01_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_CT_NETLINK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_EFS_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AUXDISPLAY: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_NET_SR9800_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_EMATCH_TEXT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_DMA_ENGINE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_CODEC_ANALOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ADIS16209_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_ACPI_CPUFREQ: ::std::os::raw::c_uint = 1;
pub const CONFIG_HID_WIIMOTE_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_BACKLIGHT_AS3711_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_APDS9300_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_MA901_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_P54_SPI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RDS_TCP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_AEAD2: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_FCRYPT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NF_NAT_MASQUERADE_IPV6_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCMCIA_ATMEL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_NCI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TOSHIBA_BT_RFKILL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MOUSE_PS2_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NET_IPIP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_IP_VS_SH_TAB_BITS: ::std::os::raw::c_uint = 8;
pub const CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE: ::std::os::raw::c_uint = 0;
pub const CONFIG_USB_SERIAL_IPAQ_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_MATCH_HL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CHROMEOS_LAPTOP_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NFC_DIGITAL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_LEDS_TCA6507_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_USB_POD_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CRYPTO_ALGAPI2: ::std::os::raw::c_uint = 1;
pub const CONFIG_SATA_SIS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PHYSICAL_START: ::std::os::raw::c_uint = 16777216;
pub const CONFIG_NETFILTER_XT_TARGET_LED_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_WEXT_SPY: ::std::os::raw::c_uint = 1;
pub const CONFIG_UBIFS_FS_LZO: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_G_ACM_MS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ACPI_SBS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_KEYBOARD_ADP5589_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_MEMBLOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_DEBUG_RODATA: ::std::os::raw::c_uint = 1;
pub const CONFIG_FB_3DFX_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_X86_PMEM_LEGACY: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT: ::std::os::raw::c_uint = 1;
pub const CONFIG_KVM_DEVICE_ASSIGNMENT: ::std::os::raw::c_uint = 1;
pub const CONFIG_PCI200SYN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PPPOATM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_VIDEO_ZORAN_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PMIC_DA9052: ::std::os::raw::c_uint = 1;
pub const CONFIG_PATA_OPTI_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_PROC_SYSCTL: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_HDA_CODEC_REALTEK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_ATH6KL_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HAVE_PERF_EVENTS_NMI: ::std::os::raw::c_uint = 1;
pub const CONFIG_SND_SOC_FSL_ASRC_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CT_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_RD_LZ4: ::std::os::raw::c_uint = 1;
pub const CONFIG_MMU: ::std::os::raw::c_uint = 1;
pub const CONFIG_DVB_CX24123_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_OCFS2_FS_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_MTD_M25P80_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_KAWETH_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_USB_SIERRA_NET_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AIC7XXX_RESET_DELAY_MS: ::std::os::raw::c_uint = 5000;
pub const CONFIG_VMWARE_BALLOON_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_GPIO_MCP23S08_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_HISAX_GAZEL: ::std::os::raw::c_uint = 1;
pub const CONFIG_BRIDGE_EBT_NFLOG_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_CAN_SJA1000_PLATFORM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_TABLET_USB_AIPTEK_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_AGP: ::std::os::raw::c_uint = 1;
pub const CONFIG_INLINE_WRITE_UNLOCK: ::std::os::raw::c_uint = 1;
pub const CONFIG_ZPOOL: ::std::os::raw::c_uint = 1;
pub const CONFIG_REGULATOR_TPS6524X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_INPUT_AD714X_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SENSORS_GL520SM_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_E1000_MODULE: ::std::os::raw::c_uint = 1;
pub const CONFIG_SCSI_SYM53C8XX_MMIO: ::std::os::raw::c_uint = 1;
pub const __BITS_PER_LONG: ::std::os::raw::c_uint = 64;
pub const BITS_PER_LONG: ::std::os::raw::c_uint = 64;
pub const BITS_PER_LONG_LONG: ::std::os::raw::c_uint = 64;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const KERN_SOH: &'static [u8; 2usize] = b"\x01\x00";
pub const KERN_SOH_ASCII: u8 = b'\x01';
pub const KERN_EMERG: &'static [u8; 3usize] = b"\x010\x00";
pub const KERN_ALERT: &'static [u8; 3usize] = b"\x011\x00";
pub const KERN_CRIT: &'static [u8; 3usize] = b"\x012\x00";
pub const KERN_ERR: &'static [u8; 3usize] = b"\x013\x00";
pub const KERN_WARNING: &'static [u8; 3usize] = b"\x014\x00";
pub const KERN_NOTICE: &'static [u8; 3usize] = b"\x015\x00";
pub const KERN_INFO: &'static [u8; 3usize] = b"\x016\x00";
pub const KERN_DEBUG: &'static [u8; 3usize] = b"\x017\x00";
pub const KERN_DEFAULT: &'static [u8; 3usize] = b"\x01d\x00";
pub const KERN_CONT: &'static [u8; 1usize] = b"\x00";
pub const LOGLEVEL_SCHED: ::std::os::raw::c_int = -2;
pub const LOGLEVEL_DEFAULT: ::std::os::raw::c_int = -1;
pub const LOGLEVEL_EMERG: ::std::os::raw::c_uint = 0;
pub const LOGLEVEL_ALERT: ::std::os::raw::c_uint = 1;
pub const LOGLEVEL_CRIT: ::std::os::raw::c_uint = 2;
pub const LOGLEVEL_ERR: ::std::os::raw::c_uint = 3;
pub const LOGLEVEL_WARNING: ::std::os::raw::c_uint = 4;
pub const LOGLEVEL_NOTICE: ::std::os::raw::c_uint = 5;
pub const LOGLEVEL_INFO: ::std::os::raw::c_uint = 6;
pub const LOGLEVEL_DEBUG: ::std::os::raw::c_uint = 7;
pub const __ALIGN_STR: &'static [u8; 14usize] = b".align 4,0x90\x00";
pub const SI_LOAD_SHIFT: ::std::os::raw::c_uint = 16;
pub const L1_CACHE_SHIFT: ::std::os::raw::c_uint = 6;
pub const L1_CACHE_BYTES: ::std::os::raw::c_uint = 64;
pub const INTERNODE_CACHE_SHIFT: ::std::os::raw::c_uint = 6;
pub const INTERNODE_CACHE_BYTES: ::std::os::raw::c_uint = 64;
pub const SMP_CACHE_BYTES: ::std::os::raw::c_uint = 64;
pub const CONSOLE_EXT_LOG_MAX: ::std::os::raw::c_uint = 8192;
pub const MESSAGE_LOGLEVEL_DEFAULT: ::std::os::raw::c_uint = 4;
pub const CONSOLE_LOGLEVEL_SILENT: ::std::os::raw::c_uint = 0;
pub const CONSOLE_LOGLEVEL_MIN: ::std::os::raw::c_uint = 1;
pub const CONSOLE_LOGLEVEL_QUIET: ::std::os::raw::c_uint = 4;
pub const CONSOLE_LOGLEVEL_DEFAULT: ::std::os::raw::c_uint = 7;
pub const CONSOLE_LOGLEVEL_DEBUG: ::std::os::raw::c_uint = 10;
pub const CONSOLE_LOGLEVEL_MOTORMOUTH: ::std::os::raw::c_uint = 15;
pub const FW_BUG: &'static [u8; 17usize] = b"[Firmware Bug]: \x00";
pub const FW_WARN: &'static [u8; 18usize] = b"[Firmware Warn]: \x00";
pub const FW_INFO: &'static [u8; 18usize] = b"[Firmware Info]: \x00";
pub const HW_ERR: &'static [u8; 19usize] = b"[Hardware Error]: \x00";
pub const DEPRECATED: &'static [u8; 15usize] = b"[Deprecated]: \x00";
pub const _DPRINTK_FLAGS_NONE: ::std::os::raw::c_uint = 0;
pub const _DPRINTK_FLAGS_PRINT: ::std::os::raw::c_uint = 1;
pub const _DPRINTK_FLAGS_INCL_MODNAME: ::std::os::raw::c_uint = 2;
pub const _DPRINTK_FLAGS_INCL_FUNCNAME: ::std::os::raw::c_uint = 4;
pub const _DPRINTK_FLAGS_INCL_LINENO: ::std::os::raw::c_uint = 8;
pub const _DPRINTK_FLAGS_INCL_TID: ::std::os::raw::c_uint = 16;
pub const _DPRINTK_FLAGS_DEFAULT: ::std::os::raw::c_uint = 0;
pub const LINUX_MM_DEBUG_H: ::std::os::raw::c_uint = 1;
pub const __BUG_C0: &'static [u8; 30usize] =
    b"2:\\t.long 1b - 2b, %c0 - 2b\\n\x00";
pub const BUGFLAG_WARNING: ::std::os::raw::c_uint = 1;
pub const BITS_PER_BYTE: ::std::os::raw::c_uint = 8;
pub const GDT_ENTRY_BOOT_CS: ::std::os::raw::c_uint = 2;
pub const GDT_ENTRY_BOOT_DS: ::std::os::raw::c_uint = 3;
pub const GDT_ENTRY_BOOT_TSS: ::std::os::raw::c_uint = 4;
pub const __BOOT_CS: ::std::os::raw::c_uint = 16;
pub const __BOOT_DS: ::std::os::raw::c_uint = 24;
pub const __BOOT_TSS: ::std::os::raw::c_uint = 32;
pub const SEGMENT_RPL_MASK: ::std::os::raw::c_uint = 3;
pub const USER_RPL: ::std::os::raw::c_uint = 3;
pub const SEGMENT_TI_MASK: ::std::os::raw::c_uint = 4;
pub const SEGMENT_LDT: ::std::os::raw::c_uint = 4;
pub const SEGMENT_GDT: ::std::os::raw::c_uint = 0;
pub const GDT_ENTRY_INVALID_SEG: ::std::os::raw::c_uint = 0;
pub const GDT_ENTRY_KERNEL32_CS: ::std::os::raw::c_uint = 1;
pub const GDT_ENTRY_KERNEL_CS: ::std::os::raw::c_uint = 2;
pub const GDT_ENTRY_KERNEL_DS: ::std::os::raw::c_uint = 3;
pub const GDT_ENTRY_DEFAULT_USER32_CS: ::std::os::raw::c_uint = 4;
pub const GDT_ENTRY_DEFAULT_USER_DS: ::std::os::raw::c_uint = 5;
pub const GDT_ENTRY_DEFAULT_USER_CS: ::std::os::raw::c_uint = 6;
pub const GDT_ENTRY_TSS: ::std::os::raw::c_uint = 8;
pub const GDT_ENTRY_LDT: ::std::os::raw::c_uint = 10;
pub const GDT_ENTRY_TLS_MIN: ::std::os::raw::c_uint = 12;
pub const GDT_ENTRY_TLS_MAX: ::std::os::raw::c_uint = 14;
pub const GDT_ENTRY_PER_CPU: ::std::os::raw::c_uint = 15;
pub const GDT_ENTRIES: ::std::os::raw::c_uint = 16;
pub const __KERNEL32_CS: ::std::os::raw::c_uint = 8;
pub const __KERNEL_CS: ::std::os::raw::c_uint = 16;
pub const __KERNEL_DS: ::std::os::raw::c_uint = 24;
pub const __USER32_CS: ::std::os::raw::c_uint = 35;
pub const __USER_DS: ::std::os::raw::c_uint = 43;
pub const __USER32_DS: ::std::os::raw::c_uint = 43;
pub const __USER_CS: ::std::os::raw::c_uint = 51;
pub const __PER_CPU_SEG: ::std::os::raw::c_uint = 123;
pub const FS_TLS: ::std::os::raw::c_uint = 0;
pub const GS_TLS: ::std::os::raw::c_uint = 1;
pub const GS_TLS_SEL: ::std::os::raw::c_uint = 107;
pub const FS_TLS_SEL: ::std::os::raw::c_uint = 99;
pub const IDT_ENTRIES: ::std::os::raw::c_uint = 256;
pub const NUM_EXCEPTION_VECTORS: ::std::os::raw::c_uint = 32;
pub const EXCEPTION_ERRCODE_MASK: ::std::os::raw::c_uint = 163072;
pub const GDT_SIZE: ::std::os::raw::c_uint = 128;
pub const GDT_ENTRY_TLS_ENTRIES: ::std::os::raw::c_uint = 3;
pub const TLS_SIZE: ::std::os::raw::c_uint = 24;
pub const EARLY_IDT_HANDLER_SIZE: ::std::os::raw::c_uint = 9;
pub const PAGE_SHIFT: ::std::os::raw::c_uint = 12;
pub const HUGE_MAX_HSTATE: ::std::os::raw::c_uint = 2;
pub const KASAN_STACK_ORDER: ::std::os::raw::c_uint = 0;
pub const THREAD_SIZE_ORDER: ::std::os::raw::c_uint = 2;
pub const EXCEPTION_STACK_ORDER: ::std::os::raw::c_uint = 0;
pub const DEBUG_STACK_ORDER: ::std::os::raw::c_uint = 1;
pub const IRQ_STACK_ORDER: ::std::os::raw::c_uint = 2;
pub const DOUBLEFAULT_STACK: ::std::os::raw::c_uint = 1;
pub const NMI_STACK: ::std::os::raw::c_uint = 2;
pub const DEBUG_STACK: ::std::os::raw::c_uint = 3;
pub const MCE_STACK: ::std::os::raw::c_uint = 4;
pub const N_EXCEPTION_STACKS: ::std::os::raw::c_uint = 4;
pub const __PHYSICAL_MASK_SHIFT: ::std::os::raw::c_uint = 46;
pub const __VIRTUAL_MASK_SHIFT: ::std::os::raw::c_uint = 47;
pub const KERNEL_IMAGE_SIZE_DEFAULT: ::std::os::raw::c_uint = 536870912;
pub const KERNEL_IMAGE_SIZE: ::std::os::raw::c_uint = 1073741824;
pub const FRAME_SIZE: ::std::os::raw::c_uint = 168;
pub const PTRACE_GETREGS: ::std::os::raw::c_uint = 12;
pub const PTRACE_SETREGS: ::std::os::raw::c_uint = 13;
pub const PTRACE_GETFPREGS: ::std::os::raw::c_uint = 14;
pub const PTRACE_SETFPREGS: ::std::os::raw::c_uint = 15;
pub const PTRACE_GETFPXREGS: ::std::os::raw::c_uint = 18;
pub const PTRACE_SETFPXREGS: ::std::os::raw::c_uint = 19;
pub const PTRACE_OLDSETOPTIONS: ::std::os::raw::c_uint = 21;
pub const PTRACE_GET_THREAD_AREA: ::std::os::raw::c_uint = 25;
pub const PTRACE_SET_THREAD_AREA: ::std::os::raw::c_uint = 26;
pub const PTRACE_ARCH_PRCTL: ::std::os::raw::c_uint = 30;
pub const PTRACE_SYSEMU: ::std::os::raw::c_uint = 31;
pub const PTRACE_SYSEMU_SINGLESTEP: ::std::os::raw::c_uint = 32;
pub const PTRACE_SINGLEBLOCK: ::std::os::raw::c_uint = 33;
pub const X86_EFLAGS_CF_BIT: ::std::os::raw::c_uint = 0;
pub const X86_EFLAGS_FIXED_BIT: ::std::os::raw::c_uint = 1;
pub const X86_EFLAGS_PF_BIT: ::std::os::raw::c_uint = 2;
pub const X86_EFLAGS_AF_BIT: ::std::os::raw::c_uint = 4;
pub const X86_EFLAGS_ZF_BIT: ::std::os::raw::c_uint = 6;
pub const X86_EFLAGS_SF_BIT: ::std::os::raw::c_uint = 7;
pub const X86_EFLAGS_TF_BIT: ::std::os::raw::c_uint = 8;
pub const X86_EFLAGS_IF_BIT: ::std::os::raw::c_uint = 9;
pub const X86_EFLAGS_DF_BIT: ::std::os::raw::c_uint = 10;
pub const X86_EFLAGS_OF_BIT: ::std::os::raw::c_uint = 11;
pub const X86_EFLAGS_IOPL_BIT: ::std::os::raw::c_uint = 12;
pub const X86_EFLAGS_NT_BIT: ::std::os::raw::c_uint = 14;
pub const X86_EFLAGS_RF_BIT: ::std::os::raw::c_uint = 16;
pub const X86_EFLAGS_VM_BIT: ::std::os::raw::c_uint = 17;
pub const X86_EFLAGS_AC_BIT: ::std::os::raw::c_uint = 18;
pub const X86_EFLAGS_VIF_BIT: ::std::os::raw::c_uint = 19;
pub const X86_EFLAGS_VIP_BIT: ::std::os::raw::c_uint = 20;
pub const X86_EFLAGS_ID_BIT: ::std::os::raw::c_uint = 21;
pub const X86_CR0_PE_BIT: ::std::os::raw::c_uint = 0;
pub const X86_CR0_MP_BIT: ::std::os::raw::c_uint = 1;
pub const X86_CR0_EM_BIT: ::std::os::raw::c_uint = 2;
pub const X86_CR0_TS_BIT: ::std::os::raw::c_uint = 3;
pub const X86_CR0_ET_BIT: ::std::os::raw::c_uint = 4;
pub const X86_CR0_NE_BIT: ::std::os::raw::c_uint = 5;
pub const X86_CR0_WP_BIT: ::std::os::raw::c_uint = 16;
pub const X86_CR0_AM_BIT: ::std::os::raw::c_uint = 18;
pub const X86_CR0_NW_BIT: ::std::os::raw::c_uint = 29;
pub const X86_CR0_CD_BIT: ::std::os::raw::c_uint = 30;
pub const X86_CR0_PG_BIT: ::std::os::raw::c_uint = 31;
pub const X86_CR3_PWT_BIT: ::std::os::raw::c_uint = 3;
pub const X86_CR3_PCD_BIT: ::std::os::raw::c_uint = 4;
pub const X86_CR4_VME_BIT: ::std::os::raw::c_uint = 0;
pub const X86_CR4_PVI_BIT: ::std::os::raw::c_uint = 1;
pub const X86_CR4_TSD_BIT: ::std::os::raw::c_uint = 2;
pub const X86_CR4_DE_BIT: ::std::os::raw::c_uint = 3;
pub const X86_CR4_PSE_BIT: ::std::os::raw::c_uint = 4;
pub const X86_CR4_PAE_BIT: ::std::os::raw::c_uint = 5;
pub const X86_CR4_MCE_BIT: ::std::os::raw::c_uint = 6;
pub const X86_CR4_PGE_BIT: ::std::os::raw::c_uint = 7;
pub const X86_CR4_PCE_BIT: ::std::os::raw::c_uint = 8;
pub const X86_CR4_OSFXSR_BIT: ::std::os::raw::c_uint = 9;
pub const X86_CR4_OSXMMEXCPT_BIT: ::std::os::raw::c_uint = 10;
pub const X86_CR4_VMXE_BIT: ::std::os::raw::c_uint = 13;
pub const X86_CR4_SMXE_BIT: ::std::os::raw::c_uint = 14;
pub const X86_CR4_FSGSBASE_BIT: ::std::os::raw::c_uint = 16;
pub const X86_CR4_PCIDE_BIT: ::std::os::raw::c_uint = 17;
pub const X86_CR4_OSXSAVE_BIT: ::std::os::raw::c_uint = 18;
pub const X86_CR4_SMEP_BIT: ::std::os::raw::c_uint = 20;
pub const X86_CR4_SMAP_BIT: ::std::os::raw::c_uint = 21;
pub const CX86_PCR0: ::std::os::raw::c_uint = 32;
pub const CX86_GCR: ::std::os::raw::c_uint = 184;
pub const CX86_CCR0: ::std::os::raw::c_uint = 192;
pub const CX86_CCR1: ::std::os::raw::c_uint = 193;
pub const CX86_CCR2: ::std::os::raw::c_uint = 194;
pub const CX86_CCR3: ::std::os::raw::c_uint = 195;
pub const CX86_CCR4: ::std::os::raw::c_uint = 232;
pub const CX86_CCR5: ::std::os::raw::c_uint = 233;
pub const CX86_CCR6: ::std::os::raw::c_uint = 234;
pub const CX86_CCR7: ::std::os::raw::c_uint = 235;
pub const CX86_PCR1: ::std::os::raw::c_uint = 240;
pub const CX86_DIR0: ::std::os::raw::c_uint = 254;
pub const CX86_DIR1: ::std::os::raw::c_uint = 255;
pub const CX86_ARR_BASE: ::std::os::raw::c_uint = 196;
pub const CX86_RCR_BASE: ::std::os::raw::c_uint = 220;
pub const X86_VM_MASK: ::std::os::raw::c_uint = 0;
pub const CLBR_NONE: ::std::os::raw::c_uint = 0;
pub const CLBR_EAX: ::std::os::raw::c_uint = 1;
pub const CLBR_ECX: ::std::os::raw::c_uint = 2;
pub const CLBR_EDX: ::std::os::raw::c_uint = 4;
pub const CLBR_EDI: ::std::os::raw::c_uint = 8;
pub const CLBR_RAX: ::std::os::raw::c_uint = 1;
pub const CLBR_RCX: ::std::os::raw::c_uint = 2;
pub const CLBR_RDX: ::std::os::raw::c_uint = 4;
pub const CLBR_RDI: ::std::os::raw::c_uint = 8;
pub const CLBR_RSI: ::std::os::raw::c_uint = 16;
pub const CLBR_R8: ::std::os::raw::c_uint = 32;
pub const CLBR_R9: ::std::os::raw::c_uint = 64;
pub const CLBR_R10: ::std::os::raw::c_uint = 128;
pub const CLBR_R11: ::std::os::raw::c_uint = 256;
pub const CLBR_ANY: ::std::os::raw::c_uint = 511;
pub const CLBR_ARG_REGS: ::std::os::raw::c_uint = 126;
pub const CLBR_RET_REG: ::std::os::raw::c_uint = 1;
pub const CLBR_SCRATCH: ::std::os::raw::c_uint = 384;
pub const CLBR_CALLEE_SAVE: ::std::os::raw::c_uint = 510;
pub const KM_TYPE_NR: ::std::os::raw::c_uint = 20;
pub const FIRST_USER_ADDRESS: ::std::os::raw::c_uint = 0;
pub const _PAGE_BIT_PRESENT: ::std::os::raw::c_uint = 0;
pub const _PAGE_BIT_RW: ::std::os::raw::c_uint = 1;
pub const _PAGE_BIT_USER: ::std::os::raw::c_uint = 2;
pub const _PAGE_BIT_PWT: ::std::os::raw::c_uint = 3;
pub const _PAGE_BIT_PCD: ::std::os::raw::c_uint = 4;
pub const _PAGE_BIT_ACCESSED: ::std::os::raw::c_uint = 5;
pub const _PAGE_BIT_DIRTY: ::std::os::raw::c_uint = 6;
pub const _PAGE_BIT_PSE: ::std::os::raw::c_uint = 7;
pub const _PAGE_BIT_PAT: ::std::os::raw::c_uint = 7;
pub const _PAGE_BIT_GLOBAL: ::std::os::raw::c_uint = 8;
pub const _PAGE_BIT_SOFTW1: ::std::os::raw::c_uint = 9;
pub const _PAGE_BIT_SOFTW2: ::std::os::raw::c_uint = 10;
pub const _PAGE_BIT_SOFTW3: ::std::os::raw::c_uint = 11;
pub const _PAGE_BIT_PAT_LARGE: ::std::os::raw::c_uint = 12;
pub const _PAGE_BIT_SPECIAL: ::std::os::raw::c_uint = 9;
pub const _PAGE_BIT_CPA_TEST: ::std::os::raw::c_uint = 9;
pub const _PAGE_BIT_SPLITTING: ::std::os::raw::c_uint = 10;
pub const _PAGE_BIT_HIDDEN: ::std::os::raw::c_uint = 11;
pub const _PAGE_BIT_SOFT_DIRTY: ::std::os::raw::c_uint = 11;
pub const _PAGE_BIT_NX: ::std::os::raw::c_uint = 63;
pub const _PAGE_BIT_PROTNONE: ::std::os::raw::c_uint = 8;
pub const SECTION_SIZE_BITS: ::std::os::raw::c_uint = 27;
pub const MAX_PHYSADDR_BITS: ::std::os::raw::c_uint = 44;
pub const MAX_PHYSMEM_BITS: ::std::os::raw::c_uint = 46;
pub const SHARED_KERNEL_PMD: ::std::os::raw::c_uint = 0;
pub const PGDIR_SHIFT: ::std::os::raw::c_uint = 39;
pub const PTRS_PER_PGD: ::std::os::raw::c_uint = 512;
pub const PUD_SHIFT: ::std::os::raw::c_uint = 30;
pub const PTRS_PER_PUD: ::std::os::raw::c_uint = 512;
pub const PMD_SHIFT: ::std::os::raw::c_uint = 21;
pub const PTRS_PER_PMD: ::std::os::raw::c_uint = 512;
pub const PTRS_PER_PTE: ::std::os::raw::c_uint = 512;
pub const EARLY_DYNAMIC_PAGE_TABLES: ::std::os::raw::c_uint = 64;
pub const PV_SUPPORTED_RTC: ::std::os::raw::c_uint = 1;
pub const __TICKET_LOCK_INC: ::std::os::raw::c_uint = 2;
pub const _Q_LOCKED_OFFSET: ::std::os::raw::c_uint = 0;
pub const _Q_LOCKED_BITS: ::std::os::raw::c_uint = 8;
pub const _Q_PENDING_OFFSET: ::std::os::raw::c_uint = 8;
pub const _Q_PENDING_BITS: ::std::os::raw::c_uint = 8;
pub const _Q_TAIL_IDX_OFFSET: ::std::os::raw::c_uint = 16;
pub const _Q_TAIL_IDX_BITS: ::std::os::raw::c_uint = 2;
pub const _Q_TAIL_CPU_OFFSET: ::std::os::raw::c_uint = 18;
pub const _Q_TAIL_CPU_BITS: ::std::os::raw::c_uint = 14;
pub const _Q_TAIL_OFFSET: ::std::os::raw::c_uint = 16;
pub const _Q_LOCKED_VAL: ::std::os::raw::c_uint = 1;
pub const _Q_PENDING_VAL: ::std::os::raw::c_uint = 256;
pub const PARAVIRT_CALL: &'static [u8; 26usize] =
    b"call *%c[paravirt_opptr];\x00";
pub const alt_end_marker: &'static [u8; 4usize] = b"663\x00";
pub const alt_slen: &'static [u8; 10usize] = b"662b-661b\x00";
pub const alt_pad_len: &'static [u8; 10usize] = b"663b-662b\x00";
pub const alt_total_slen: &'static [u8; 10usize] = b"663b-661b\x00";
pub const NEED_3DNOW: ::std::os::raw::c_uint = 0;
pub const NEED_MOVBE: ::std::os::raw::c_uint = 0;
pub const NEED_PSE: ::std::os::raw::c_uint = 0;
pub const NEED_PGE: ::std::os::raw::c_uint = 0;
pub const REQUIRED_MASK2: ::std::os::raw::c_uint = 0;
pub const REQUIRED_MASK4: ::std::os::raw::c_uint = 0;
pub const REQUIRED_MASK5: ::std::os::raw::c_uint = 0;
pub const REQUIRED_MASK6: ::std::os::raw::c_uint = 0;
pub const REQUIRED_MASK7: ::std::os::raw::c_uint = 0;
pub const REQUIRED_MASK8: ::std::os::raw::c_uint = 0;
pub const REQUIRED_MASK9: ::std::os::raw::c_uint = 0;
pub const DISABLE_MPX: ::std::os::raw::c_uint = 0;
pub const DISABLED_MASK1: ::std::os::raw::c_uint = 0;
pub const DISABLED_MASK2: ::std::os::raw::c_uint = 0;
pub const DISABLED_MASK4: ::std::os::raw::c_uint = 0;
pub const DISABLED_MASK5: ::std::os::raw::c_uint = 0;
pub const DISABLED_MASK6: ::std::os::raw::c_uint = 0;
pub const DISABLED_MASK7: ::std::os::raw::c_uint = 0;
pub const DISABLED_MASK8: ::std::os::raw::c_uint = 0;
pub const DISABLED_MASK9: ::std::os::raw::c_uint = 0;
pub const NCAPINTS: ::std::os::raw::c_uint = 13;
pub const NBUGINTS: ::std::os::raw::c_uint = 1;
pub const X86_FEATURE_FPU: ::std::os::raw::c_uint = 0;
pub const X86_FEATURE_VME: ::std::os::raw::c_uint = 1;
pub const X86_FEATURE_DE: ::std::os::raw::c_uint = 2;
pub const X86_FEATURE_PSE: ::std::os::raw::c_uint = 3;
pub const X86_FEATURE_TSC: ::std::os::raw::c_uint = 4;
pub const X86_FEATURE_MSR: ::std::os::raw::c_uint = 5;
pub const X86_FEATURE_PAE: ::std::os::raw::c_uint = 6;
pub const X86_FEATURE_MCE: ::std::os::raw::c_uint = 7;
pub const X86_FEATURE_CX8: ::std::os::raw::c_uint = 8;
pub const X86_FEATURE_APIC: ::std::os::raw::c_uint = 9;
pub const X86_FEATURE_SEP: ::std::os::raw::c_uint = 11;
pub const X86_FEATURE_MTRR: ::std::os::raw::c_uint = 12;
pub const X86_FEATURE_PGE: ::std::os::raw::c_uint = 13;
pub const X86_FEATURE_MCA: ::std::os::raw::c_uint = 14;
pub const X86_FEATURE_CMOV: ::std::os::raw::c_uint = 15;
pub const X86_FEATURE_PAT: ::std::os::raw::c_uint = 16;
pub const X86_FEATURE_PSE36: ::std::os::raw::c_uint = 17;
pub const X86_FEATURE_PN: ::std::os::raw::c_uint = 18;
pub const X86_FEATURE_CLFLUSH: ::std::os::raw::c_uint = 19;
pub const X86_FEATURE_DS: ::std::os::raw::c_uint = 21;
pub const X86_FEATURE_ACPI: ::std::os::raw::c_uint = 22;
pub const X86_FEATURE_MMX: ::std::os::raw::c_uint = 23;
pub const X86_FEATURE_FXSR: ::std::os::raw::c_uint = 24;
pub const X86_FEATURE_XMM: ::std::os::raw::c_uint = 25;
pub const X86_FEATURE_XMM2: ::std::os::raw::c_uint = 26;
pub const X86_FEATURE_SELFSNOOP: ::std::os::raw::c_uint = 27;
pub const X86_FEATURE_HT: ::std::os::raw::c_uint = 28;
pub const X86_FEATURE_ACC: ::std::os::raw::c_uint = 29;
pub const X86_FEATURE_IA64: ::std::os::raw::c_uint = 30;
pub const X86_FEATURE_PBE: ::std::os::raw::c_uint = 31;
pub const X86_FEATURE_SYSCALL: ::std::os::raw::c_uint = 43;
pub const X86_FEATURE_MP: ::std::os::raw::c_uint = 51;
pub const X86_FEATURE_NX: ::std::os::raw::c_uint = 52;
pub const X86_FEATURE_MMXEXT: ::std::os::raw::c_uint = 54;
pub const X86_FEATURE_FXSR_OPT: ::std::os::raw::c_uint = 57;
pub const X86_FEATURE_GBPAGES: ::std::os::raw::c_uint = 58;
pub const X86_FEATURE_RDTSCP: ::std::os::raw::c_uint = 59;
pub const X86_FEATURE_LM: ::std::os::raw::c_uint = 61;
pub const X86_FEATURE_3DNOWEXT: ::std::os::raw::c_uint = 62;
pub const X86_FEATURE_3DNOW: ::std::os::raw::c_uint = 63;
pub const X86_FEATURE_RECOVERY: ::std::os::raw::c_uint = 64;
pub const X86_FEATURE_LONGRUN: ::std::os::raw::c_uint = 65;
pub const X86_FEATURE_LRTI: ::std::os::raw::c_uint = 67;
pub const X86_FEATURE_CXMMX: ::std::os::raw::c_uint = 96;
pub const X86_FEATURE_K6_MTRR: ::std::os::raw::c_uint = 97;
pub const X86_FEATURE_CYRIX_ARR: ::std::os::raw::c_uint = 98;
pub const X86_FEATURE_CENTAUR_MCR: ::std::os::raw::c_uint = 99;
pub const X86_FEATURE_K8: ::std::os::raw::c_uint = 100;
pub const X86_FEATURE_K7: ::std::os::raw::c_uint = 101;
pub const X86_FEATURE_P3: ::std::os::raw::c_uint = 102;
pub const X86_FEATURE_P4: ::std::os::raw::c_uint = 103;
pub const X86_FEATURE_CONSTANT_TSC: ::std::os::raw::c_uint = 104;
pub const X86_FEATURE_UP: ::std::os::raw::c_uint = 105;
pub const X86_FEATURE_ARCH_PERFMON: ::std::os::raw::c_uint = 107;
pub const X86_FEATURE_PEBS: ::std::os::raw::c_uint = 108;
pub const X86_FEATURE_BTS: ::std::os::raw::c_uint = 109;
pub const X86_FEATURE_SYSCALL32: ::std::os::raw::c_uint = 110;
pub const X86_FEATURE_SYSENTER32: ::std::os::raw::c_uint = 111;
pub const X86_FEATURE_REP_GOOD: ::std::os::raw::c_uint = 112;
pub const X86_FEATURE_MFENCE_RDTSC: ::std::os::raw::c_uint = 113;
pub const X86_FEATURE_LFENCE_RDTSC: ::std::os::raw::c_uint = 114;
pub const X86_FEATURE_NOPL: ::std::os::raw::c_uint = 116;
pub const X86_FEATURE_ALWAYS: ::std::os::raw::c_uint = 117;
pub const X86_FEATURE_XTOPOLOGY: ::std::os::raw::c_uint = 118;
pub const X86_FEATURE_TSC_RELIABLE: ::std::os::raw::c_uint = 119;
pub const X86_FEATURE_NONSTOP_TSC: ::std::os::raw::c_uint = 120;
pub const X86_FEATURE_EXTD_APICID: ::std::os::raw::c_uint = 122;
pub const X86_FEATURE_AMD_DCM: ::std::os::raw::c_uint = 123;
pub const X86_FEATURE_APERFMPERF: ::std::os::raw::c_uint = 124;
pub const X86_FEATURE_EAGER_FPU: ::std::os::raw::c_uint = 125;
pub const X86_FEATURE_NONSTOP_TSC_S3: ::std::os::raw::c_uint = 126;
pub const X86_FEATURE_XMM3: ::std::os::raw::c_uint = 128;
pub const X86_FEATURE_PCLMULQDQ: ::std::os::raw::c_uint = 129;
pub const X86_FEATURE_DTES64: ::std::os::raw::c_uint = 130;
pub const X86_FEATURE_MWAIT: ::std::os::raw::c_uint = 131;
pub const X86_FEATURE_DSCPL: ::std::os::raw::c_uint = 132;
pub const X86_FEATURE_VMX: ::std::os::raw::c_uint = 133;
pub const X86_FEATURE_SMX: ::std::os::raw::c_uint = 134;
pub const X86_FEATURE_EST: ::std::os::raw::c_uint = 135;
pub const X86_FEATURE_TM2: ::std::os::raw::c_uint = 136;
pub const X86_FEATURE_SSSE3: ::std::os::raw::c_uint = 137;
pub const X86_FEATURE_CID: ::std::os::raw::c_uint = 138;
pub const X86_FEATURE_FMA: ::std::os::raw::c_uint = 140;
pub const X86_FEATURE_CX16: ::std::os::raw::c_uint = 141;
pub const X86_FEATURE_XTPR: ::std::os::raw::c_uint = 142;
pub const X86_FEATURE_PDCM: ::std::os::raw::c_uint = 143;
pub const X86_FEATURE_PCID: ::std::os::raw::c_uint = 145;
pub const X86_FEATURE_DCA: ::std::os::raw::c_uint = 146;
pub const X86_FEATURE_XMM4_1: ::std::os::raw::c_uint = 147;
pub const X86_FEATURE_XMM4_2: ::std::os::raw::c_uint = 148;
pub const X86_FEATURE_X2APIC: ::std::os::raw::c_uint = 149;
pub const X86_FEATURE_MOVBE: ::std::os::raw::c_uint = 150;
pub const X86_FEATURE_POPCNT: ::std::os::raw::c_uint = 151;
pub const X86_FEATURE_TSC_DEADLINE_TIMER: ::std::os::raw::c_uint = 152;
pub const X86_FEATURE_AES: ::std::os::raw::c_uint = 153;
pub const X86_FEATURE_XSAVE: ::std::os::raw::c_uint = 154;
pub const X86_FEATURE_OSXSAVE: ::std::os::raw::c_uint = 155;
pub const X86_FEATURE_AVX: ::std::os::raw::c_uint = 156;
pub const X86_FEATURE_F16C: ::std::os::raw::c_uint = 157;
pub const X86_FEATURE_RDRAND: ::std::os::raw::c_uint = 158;
pub const X86_FEATURE_HYPERVISOR: ::std::os::raw::c_uint = 159;
pub const X86_FEATURE_XSTORE: ::std::os::raw::c_uint = 162;
pub const X86_FEATURE_XSTORE_EN: ::std::os::raw::c_uint = 163;
pub const X86_FEATURE_XCRYPT: ::std::os::raw::c_uint = 166;
pub const X86_FEATURE_XCRYPT_EN: ::std::os::raw::c_uint = 167;
pub const X86_FEATURE_ACE2: ::std::os::raw::c_uint = 168;
pub const X86_FEATURE_ACE2_EN: ::std::os::raw::c_uint = 169;
pub const X86_FEATURE_PHE: ::std::os::raw::c_uint = 170;
pub const X86_FEATURE_PHE_EN: ::std::os::raw::c_uint = 171;
pub const X86_FEATURE_PMM: ::std::os::raw::c_uint = 172;
pub const X86_FEATURE_PMM_EN: ::std::os::raw::c_uint = 173;
pub const X86_FEATURE_LAHF_LM: ::std::os::raw::c_uint = 192;
pub const X86_FEATURE_CMP_LEGACY: ::std::os::raw::c_uint = 193;
pub const X86_FEATURE_SVM: ::std::os::raw::c_uint = 194;
pub const X86_FEATURE_EXTAPIC: ::std::os::raw::c_uint = 195;
pub const X86_FEATURE_CR8_LEGACY: ::std::os::raw::c_uint = 196;
pub const X86_FEATURE_ABM: ::std::os::raw::c_uint = 197;
pub const X86_FEATURE_SSE4A: ::std::os::raw::c_uint = 198;
pub const X86_FEATURE_MISALIGNSSE: ::std::os::raw::c_uint = 199;
pub const X86_FEATURE_3DNOWPREFETCH: ::std::os::raw::c_uint = 200;
pub const X86_FEATURE_OSVW: ::std::os::raw::c_uint = 201;
pub const X86_FEATURE_IBS: ::std::os::raw::c_uint = 202;
pub const X86_FEATURE_XOP: ::std::os::raw::c_uint = 203;
pub const X86_FEATURE_SKINIT: ::std::os::raw::c_uint = 204;
pub const X86_FEATURE_WDT: ::std::os::raw::c_uint = 205;
pub const X86_FEATURE_LWP: ::std::os::raw::c_uint = 207;
pub const X86_FEATURE_FMA4: ::std::os::raw::c_uint = 208;
pub const X86_FEATURE_TCE: ::std::os::raw::c_uint = 209;
pub const X86_FEATURE_NODEID_MSR: ::std::os::raw::c_uint = 211;
pub const X86_FEATURE_TBM: ::std::os::raw::c_uint = 213;
pub const X86_FEATURE_TOPOEXT: ::std::os::raw::c_uint = 214;
pub const X86_FEATURE_PERFCTR_CORE: ::std::os::raw::c_uint = 215;
pub const X86_FEATURE_PERFCTR_NB: ::std::os::raw::c_uint = 216;
pub const X86_FEATURE_BPEXT: ::std::os::raw::c_uint = 218;
pub const X86_FEATURE_PERFCTR_L2: ::std::os::raw::c_uint = 220;
pub const X86_FEATURE_IDA: ::std::os::raw::c_uint = 224;
pub const X86_FEATURE_ARAT: ::std::os::raw::c_uint = 225;
pub const X86_FEATURE_CPB: ::std::os::raw::c_uint = 226;
pub const X86_FEATURE_EPB: ::std::os::raw::c_uint = 227;
pub const X86_FEATURE_PLN: ::std::os::raw::c_uint = 229;
pub const X86_FEATURE_PTS: ::std::os::raw::c_uint = 230;
pub const X86_FEATURE_DTHERM: ::std::os::raw::c_uint = 231;
pub const X86_FEATURE_HW_PSTATE: ::std::os::raw::c_uint = 232;
pub const X86_FEATURE_PROC_FEEDBACK: ::std::os::raw::c_uint = 233;
pub const X86_FEATURE_HWP: ::std::os::raw::c_uint = 234;
pub const X86_FEATURE_HWP_NOITFY: ::std::os::raw::c_uint = 235;
pub const X86_FEATURE_HWP_ACT_WINDOW: ::std::os::raw::c_uint = 236;
pub const X86_FEATURE_HWP_EPP: ::std::os::raw::c_uint = 237;
pub const X86_FEATURE_HWP_PKG_REQ: ::std::os::raw::c_uint = 238;
pub const X86_FEATURE_INTEL_PT: ::std::os::raw::c_uint = 239;
pub const X86_FEATURE_TPR_SHADOW: ::std::os::raw::c_uint = 256;
pub const X86_FEATURE_VNMI: ::std::os::raw::c_uint = 257;
pub const X86_FEATURE_FLEXPRIORITY: ::std::os::raw::c_uint = 258;
pub const X86_FEATURE_EPT: ::std::os::raw::c_uint = 259;
pub const X86_FEATURE_VPID: ::std::os::raw::c_uint = 260;
pub const X86_FEATURE_NPT: ::std::os::raw::c_uint = 261;
pub const X86_FEATURE_LBRV: ::std::os::raw::c_uint = 262;
pub const X86_FEATURE_SVML: ::std::os::raw::c_uint = 263;
pub const X86_FEATURE_NRIPS: ::std::os::raw::c_uint = 264;
pub const X86_FEATURE_TSCRATEMSR: ::std::os::raw::c_uint = 265;
pub const X86_FEATURE_VMCBCLEAN: ::std::os::raw::c_uint = 266;
pub const X86_FEATURE_FLUSHBYASID: ::std::os::raw::c_uint = 267;
pub const X86_FEATURE_DECODEASSISTS: ::std::os::raw::c_uint = 268;
pub const X86_FEATURE_PAUSEFILTER: ::std::os::raw::c_uint = 269;
pub const X86_FEATURE_PFTHRESHOLD: ::std::os::raw::c_uint = 270;
pub const X86_FEATURE_VMMCALL: ::std::os::raw::c_uint = 271;
pub const X86_FEATURE_FSGSBASE: ::std::os::raw::c_uint = 288;
pub const X86_FEATURE_TSC_ADJUST: ::std::os::raw::c_uint = 289;
pub const X86_FEATURE_BMI1: ::std::os::raw::c_uint = 291;
pub const X86_FEATURE_HLE: ::std::os::raw::c_uint = 292;
pub const X86_FEATURE_AVX2: ::std::os::raw::c_uint = 293;
pub const X86_FEATURE_SMEP: ::std::os::raw::c_uint = 295;
pub const X86_FEATURE_BMI2: ::std::os::raw::c_uint = 296;
pub const X86_FEATURE_ERMS: ::std::os::raw::c_uint = 297;
pub const X86_FEATURE_INVPCID: ::std::os::raw::c_uint = 298;
pub const X86_FEATURE_RTM: ::std::os::raw::c_uint = 299;
pub const X86_FEATURE_CQM: ::std::os::raw::c_uint = 300;
pub const X86_FEATURE_MPX: ::std::os::raw::c_uint = 302;
pub const X86_FEATURE_AVX512F: ::std::os::raw::c_uint = 304;
pub const X86_FEATURE_RDSEED: ::std::os::raw::c_uint = 306;
pub const X86_FEATURE_ADX: ::std::os::raw::c_uint = 307;
pub const X86_FEATURE_SMAP: ::std::os::raw::c_uint = 308;
pub const X86_FEATURE_PCOMMIT: ::std::os::raw::c_uint = 310;
pub const X86_FEATURE_CLFLUSHOPT: ::std::os::raw::c_uint = 311;
pub const X86_FEATURE_CLWB: ::std::os::raw::c_uint = 312;
pub const X86_FEATURE_AVX512PF: ::std::os::raw::c_uint = 314;
pub const X86_FEATURE_AVX512ER: ::std::os::raw::c_uint = 315;
pub const X86_FEATURE_AVX512CD: ::std::os::raw::c_uint = 316;
pub const X86_FEATURE_XSAVEOPT: ::std::os::raw::c_uint = 320;
pub const X86_FEATURE_XSAVEC: ::std::os::raw::c_uint = 321;
pub const X86_FEATURE_XGETBV1: ::std::os::raw::c_uint = 322;
pub const X86_FEATURE_XSAVES: ::std::os::raw::c_uint = 323;
pub const X86_FEATURE_CQM_LLC: ::std::os::raw::c_uint = 353;
pub const X86_FEATURE_CQM_OCCUP_LLC: ::std::os::raw::c_uint = 384;
pub const X86_CAP_FMT: &'static [u8; 3usize] = b"%s\x00";
pub const MAX_CPU_FEATURES: ::std::os::raw::c_uint = 416;
pub const CPU_FEATURE_TYPEFMT: &'static [u8; 26usize] =
    b"x86,ven%04Xfam%04Xmod%04X\x00";
pub const NOP_DS_PREFIX: ::std::os::raw::c_uint = 62;
pub const GENERIC_NOP1: ::std::os::raw::c_uint = 144;
pub const K8_NOP1: ::std::os::raw::c_uint = 144;
pub const K7_NOP1: ::std::os::raw::c_uint = 144;
pub const P6_NOP1: ::std::os::raw::c_uint = 144;
pub const ASM_NOP_MAX: ::std::os::raw::c_uint = 8;
pub const NOP_ATOMIC5: ::std::os::raw::c_uint = 9;
pub const _BITOPS_LONG_SHIFT: ::std::os::raw::c_uint = 6;
pub const POPCNT32: &'static [u8; 31usize] =
    b".byte 0xf3,0x40,0x0f,0xb8,0xc7\x00";
pub const POPCNT64: &'static [u8; 31usize] =
    b".byte 0xf3,0x48,0x0f,0xb8,0xc7\x00";
pub const REG_IN: &'static [u8; 2usize] = b"D\x00";
pub const REG_OUT: &'static [u8; 2usize] = b"a\x00";
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BITOP_LE_SWIZZLE: ::std::os::raw::c_uint = 0;
pub const UINT_MAX: ::std::os::raw::c_int = -1;
pub const ULONG_MAX: ::std::os::raw::c_int = -1;
pub const ULLONG_MAX: ::std::os::raw::c_int = -1;
pub const STACK_MAGIC: ::std::os::raw::c_uint = 3735928559;
pub const TAINT_PROPRIETARY_MODULE: ::std::os::raw::c_uint = 0;
pub const TAINT_FORCED_MODULE: ::std::os::raw::c_uint = 1;
pub const TAINT_CPU_OUT_OF_SPEC: ::std::os::raw::c_uint = 2;
pub const TAINT_FORCED_RMMOD: ::std::os::raw::c_uint = 3;
pub const TAINT_MACHINE_CHECK: ::std::os::raw::c_uint = 4;
pub const TAINT_BAD_PAGE: ::std::os::raw::c_uint = 5;
pub const TAINT_USER: ::std::os::raw::c_uint = 6;
pub const TAINT_DIE: ::std::os::raw::c_uint = 7;
pub const TAINT_OVERRIDDEN_ACPI_TABLE: ::std::os::raw::c_uint = 8;
pub const TAINT_WARN: ::std::os::raw::c_uint = 9;
pub const TAINT_CRAP: ::std::os::raw::c_uint = 10;
pub const TAINT_FIRMWARE_WORKAROUND: ::std::os::raw::c_uint = 11;
pub const TAINT_OOT_MODULE: ::std::os::raw::c_uint = 12;
pub const TAINT_UNSIGNED_MODULE: ::std::os::raw::c_uint = 13;
pub const TAINT_SOFTLOCKUP: ::std::os::raw::c_uint = 14;
pub const TAINT_LIVEPATCH: ::std::os::raw::c_uint = 15;
pub const PAGE_POISON: ::std::os::raw::c_uint = 170;
pub const RED_INACTIVE: ::std::os::raw::c_ulonglong = 718624318471594843;
pub const RED_ACTIVE: ::std::os::raw::c_longlong = -2863912482255763264;
pub const SLUB_RED_INACTIVE: ::std::os::raw::c_uint = 187;
pub const SLUB_RED_ACTIVE: ::std::os::raw::c_uint = 204;
pub const POISON_INUSE: ::std::os::raw::c_uint = 90;
pub const POISON_FREE: ::std::os::raw::c_uint = 107;
pub const POISON_END: ::std::os::raw::c_uint = 165;
pub const POISON_FREE_INITMEM: ::std::os::raw::c_uint = 204;
pub const JBD_POISON_FREE: ::std::os::raw::c_uint = 91;
pub const JBD2_POISON_FREE: ::std::os::raw::c_uint = 92;
pub const POOL_POISON_FREED: ::std::os::raw::c_uint = 167;
pub const POOL_POISON_ALLOCATED: ::std::os::raw::c_uint = 169;
pub const ATM_POISON_FREE: ::std::os::raw::c_uint = 18;
pub const ATM_POISON: ::std::os::raw::c_uint = 3735928559;
pub const NEIGHBOR_DEAD: ::std::os::raw::c_uint = 3735928559;
pub const NETFILTER_LINK_POISON: ::std::os::raw::c_uint = 3735902124;
pub const MUTEX_DEBUG_INIT: ::std::os::raw::c_uint = 17;
pub const MUTEX_DEBUG_FREE: ::std::os::raw::c_uint = 34;
pub const FLEX_ARRAY_FREE: ::std::os::raw::c_uint = 108;
pub const KEY_DESTROY: ::std::os::raw::c_uint = 189;
pub const OSS_POISON_FREE: ::std::os::raw::c_uint = 171;
pub const PREEMPT_BITS: ::std::os::raw::c_uint = 8;
pub const SOFTIRQ_BITS: ::std::os::raw::c_uint = 8;
pub const HARDIRQ_BITS: ::std::os::raw::c_uint = 4;
pub const NMI_BITS: ::std::os::raw::c_uint = 1;
pub const PREEMPT_SHIFT: ::std::os::raw::c_uint = 0;
pub const SOFTIRQ_SHIFT: ::std::os::raw::c_uint = 8;
pub const HARDIRQ_SHIFT: ::std::os::raw::c_uint = 16;
pub const NMI_SHIFT: ::std::os::raw::c_uint = 20;
pub const PREEMPT_OFFSET: ::std::os::raw::c_uint = 1;
pub const SOFTIRQ_OFFSET: ::std::os::raw::c_uint = 256;
pub const HARDIRQ_OFFSET: ::std::os::raw::c_uint = 65536;
pub const NMI_OFFSET: ::std::os::raw::c_uint = 1048576;
pub const SOFTIRQ_DISABLE_OFFSET: ::std::os::raw::c_uint = 512;
pub const PREEMPT_ACTIVE_BITS: ::std::os::raw::c_uint = 1;
pub const PREEMPT_ACTIVE_SHIFT: ::std::os::raw::c_uint = 21;
pub const PREEMPT_NEED_RESCHED: ::std::os::raw::c_uint = 2147483648;
pub const NR_CPUS: ::std::os::raw::c_uint = 256;
pub const MIN_THREADS_LEFT_FOR_ROOT: ::std::os::raw::c_uint = 4;
pub const PIDS_PER_CPU_DEFAULT: ::std::os::raw::c_uint = 1024;
pub const PIDS_PER_CPU_MIN: ::std::os::raw::c_uint = 8;
pub const PER_CPU_SHARED_ALIGNED_SECTION: &'static [u8; 1usize] = b"\x00";
pub const PER_CPU_ALIGNED_SECTION: &'static [u8; 1usize] = b"\x00";
pub const PER_CPU_FIRST_SECTION: &'static [u8; 8usize] = b"..first\x00";
pub const PER_CPU_BASE_SECTION: &'static [u8; 14usize] = b".data..percpu\x00";
pub const __HAVE_ARCH_GATE_AREA: ::std::os::raw::c_uint = 1;
pub const TOP_OF_KERNEL_STACK_PADDING: ::std::os::raw::c_uint = 0;
pub const FP_XSTATE_MAGIC1: ::std::os::raw::c_uint = 1179670611;
pub const FP_XSTATE_MAGIC2: ::std::os::raw::c_uint = 1179670597;
pub const MSR_EFER: ::std::os::raw::c_uint = 3221225600;
pub const MSR_STAR: ::std::os::raw::c_uint = 3221225601;
pub const MSR_LSTAR: ::std::os::raw::c_uint = 3221225602;
pub const MSR_CSTAR: ::std::os::raw::c_uint = 3221225603;
pub const MSR_SYSCALL_MASK: ::std::os::raw::c_uint = 3221225604;
pub const MSR_FS_BASE: ::std::os::raw::c_uint = 3221225728;
pub const MSR_GS_BASE: ::std::os::raw::c_uint = 3221225729;
pub const MSR_KERNEL_GS_BASE: ::std::os::raw::c_uint = 3221225730;
pub const MSR_TSC_AUX: ::std::os::raw::c_uint = 3221225731;
pub const _EFER_SCE: ::std::os::raw::c_uint = 0;
pub const _EFER_LME: ::std::os::raw::c_uint = 8;
pub const _EFER_LMA: ::std::os::raw::c_uint = 10;
pub const _EFER_NX: ::std::os::raw::c_uint = 11;
pub const _EFER_SVME: ::std::os::raw::c_uint = 12;
pub const _EFER_LMSLE: ::std::os::raw::c_uint = 13;
pub const _EFER_FFXSR: ::std::os::raw::c_uint = 14;
pub const EFER_SCE: ::std::os::raw::c_uint = 1;
pub const EFER_LME: ::std::os::raw::c_uint = 256;
pub const EFER_LMA: ::std::os::raw::c_uint = 1024;
pub const EFER_NX: ::std::os::raw::c_uint = 2048;
pub const EFER_SVME: ::std::os::raw::c_uint = 4096;
pub const EFER_LMSLE: ::std::os::raw::c_uint = 8192;
pub const EFER_FFXSR: ::std::os::raw::c_uint = 16384;
pub const MSR_IA32_PERFCTR0: ::std::os::raw::c_uint = 193;
pub const MSR_IA32_PERFCTR1: ::std::os::raw::c_uint = 194;
pub const MSR_FSB_FREQ: ::std::os::raw::c_uint = 205;
pub const MSR_NHM_PLATFORM_INFO: ::std::os::raw::c_uint = 206;
pub const MSR_NHM_SNB_PKG_CST_CFG_CTL: ::std::os::raw::c_uint = 226;
pub const NHM_C3_AUTO_DEMOTE: ::std::os::raw::c_uint = 33554432;
pub const NHM_C1_AUTO_DEMOTE: ::std::os::raw::c_uint = 67108864;
pub const ATM_LNC_C6_AUTO_DEMOTE: ::std::os::raw::c_uint = 33554432;
pub const SNB_C1_AUTO_UNDEMOTE: ::std::os::raw::c_uint = 134217728;
pub const SNB_C3_AUTO_UNDEMOTE: ::std::os::raw::c_uint = 268435456;
pub const MSR_PLATFORM_INFO: ::std::os::raw::c_uint = 206;
pub const MSR_MTRRcap: ::std::os::raw::c_uint = 254;
pub const MSR_IA32_BBL_CR_CTL: ::std::os::raw::c_uint = 281;
pub const MSR_IA32_BBL_CR_CTL3: ::std::os::raw::c_uint = 286;
pub const MSR_IA32_SYSENTER_CS: ::std::os::raw::c_uint = 372;
pub const MSR_IA32_SYSENTER_ESP: ::std::os::raw::c_uint = 373;
pub const MSR_IA32_SYSENTER_EIP: ::std::os::raw::c_uint = 374;
pub const MSR_IA32_MCG_CAP: ::std::os::raw::c_uint = 377;
pub const MSR_IA32_MCG_STATUS: ::std::os::raw::c_uint = 378;
pub const MSR_IA32_MCG_CTL: ::std::os::raw::c_uint = 379;
pub const MSR_IA32_MCG_EXT_CTL: ::std::os::raw::c_uint = 1232;
pub const MSR_OFFCORE_RSP_0: ::std::os::raw::c_uint = 422;
pub const MSR_OFFCORE_RSP_1: ::std::os::raw::c_uint = 423;
pub const MSR_NHM_TURBO_RATIO_LIMIT: ::std::os::raw::c_uint = 429;
pub const MSR_IVT_TURBO_RATIO_LIMIT: ::std::os::raw::c_uint = 430;
pub const MSR_TURBO_RATIO_LIMIT: ::std::os::raw::c_uint = 429;
pub const MSR_TURBO_RATIO_LIMIT1: ::std::os::raw::c_uint = 430;
pub const MSR_TURBO_RATIO_LIMIT2: ::std::os::raw::c_uint = 431;
pub const MSR_LBR_SELECT: ::std::os::raw::c_uint = 456;
pub const MSR_LBR_TOS: ::std::os::raw::c_uint = 457;
pub const MSR_LBR_NHM_FROM: ::std::os::raw::c_uint = 1664;
pub const MSR_LBR_NHM_TO: ::std::os::raw::c_uint = 1728;
pub const MSR_LBR_CORE_FROM: ::std::os::raw::c_uint = 64;
pub const MSR_LBR_CORE_TO: ::std::os::raw::c_uint = 96;
pub const MSR_LBR_INFO_0: ::std::os::raw::c_uint = 3520;
pub const LBR_INFO_CYCLES: ::std::os::raw::c_uint = 65535;
pub const MSR_IA32_PEBS_ENABLE: ::std::os::raw::c_uint = 1009;
pub const MSR_IA32_DS_AREA: ::std::os::raw::c_uint = 1536;
pub const MSR_IA32_PERF_CAPABILITIES: ::std::os::raw::c_uint = 837;
pub const MSR_PEBS_LD_LAT_THRESHOLD: ::std::os::raw::c_uint = 1014;
pub const MSR_IA32_RTIT_CTL: ::std::os::raw::c_uint = 1392;
pub const MSR_IA32_RTIT_STATUS: ::std::os::raw::c_uint = 1393;
pub const MSR_IA32_RTIT_CR3_MATCH: ::std::os::raw::c_uint = 1394;
pub const MSR_IA32_RTIT_OUTPUT_BASE: ::std::os::raw::c_uint = 1376;
pub const MSR_IA32_RTIT_OUTPUT_MASK: ::std::os::raw::c_uint = 1377;
pub const MSR_MTRRfix64K_00000: ::std::os::raw::c_uint = 592;
pub const MSR_MTRRfix16K_80000: ::std::os::raw::c_uint = 600;
pub const MSR_MTRRfix16K_A0000: ::std::os::raw::c_uint = 601;
pub const MSR_MTRRfix4K_C0000: ::std::os::raw::c_uint = 616;
pub const MSR_MTRRfix4K_C8000: ::std::os::raw::c_uint = 617;
pub const MSR_MTRRfix4K_D0000: ::std::os::raw::c_uint = 618;
pub const MSR_MTRRfix4K_D8000: ::std::os::raw::c_uint = 619;
pub const MSR_MTRRfix4K_E0000: ::std::os::raw::c_uint = 620;
pub const MSR_MTRRfix4K_E8000: ::std::os::raw::c_uint = 621;
pub const MSR_MTRRfix4K_F0000: ::std::os::raw::c_uint = 622;
pub const MSR_MTRRfix4K_F8000: ::std::os::raw::c_uint = 623;
pub const MSR_MTRRdefType: ::std::os::raw::c_uint = 767;
pub const MSR_IA32_CR_PAT: ::std::os::raw::c_uint = 631;
pub const MSR_IA32_DEBUGCTLMSR: ::std::os::raw::c_uint = 473;
pub const MSR_IA32_LASTBRANCHFROMIP: ::std::os::raw::c_uint = 475;
pub const MSR_IA32_LASTBRANCHTOIP: ::std::os::raw::c_uint = 476;
pub const MSR_IA32_LASTINTFROMIP: ::std::os::raw::c_uint = 477;
pub const MSR_IA32_LASTINTTOIP: ::std::os::raw::c_uint = 478;
pub const DEBUGCTLMSR_LBR: ::std::os::raw::c_uint = 1;
pub const DEBUGCTLMSR_BTF: ::std::os::raw::c_uint = 2;
pub const DEBUGCTLMSR_TR: ::std::os::raw::c_uint = 64;
pub const DEBUGCTLMSR_BTS: ::std::os::raw::c_uint = 128;
pub const DEBUGCTLMSR_BTINT: ::std::os::raw::c_uint = 256;
pub const DEBUGCTLMSR_BTS_OFF_OS: ::std::os::raw::c_uint = 512;
pub const DEBUGCTLMSR_BTS_OFF_USR: ::std::os::raw::c_uint = 1024;
pub const DEBUGCTLMSR_FREEZE_LBRS_ON_PMI: ::std::os::raw::c_uint = 2048;
pub const MSR_IA32_POWER_CTL: ::std::os::raw::c_uint = 508;
pub const MSR_IA32_MC0_CTL: ::std::os::raw::c_uint = 1024;
pub const MSR_IA32_MC0_STATUS: ::std::os::raw::c_uint = 1025;
pub const MSR_IA32_MC0_ADDR: ::std::os::raw::c_uint = 1026;
pub const MSR_IA32_MC0_MISC: ::std::os::raw::c_uint = 1027;
pub const MSR_PKG_C3_RESIDENCY: ::std::os::raw::c_uint = 1016;
pub const MSR_PKG_C6_RESIDENCY: ::std::os::raw::c_uint = 1017;
pub const MSR_PKG_C7_RESIDENCY: ::std::os::raw::c_uint = 1018;
pub const MSR_CORE_C3_RESIDENCY: ::std::os::raw::c_uint = 1020;
pub const MSR_CORE_C6_RESIDENCY: ::std::os::raw::c_uint = 1021;
pub const MSR_CORE_C7_RESIDENCY: ::std::os::raw::c_uint = 1022;
pub const MSR_KNL_CORE_C6_RESIDENCY: ::std::os::raw::c_uint = 1023;
pub const MSR_PKG_C2_RESIDENCY: ::std::os::raw::c_uint = 1549;
pub const MSR_PKG_C8_RESIDENCY: ::std::os::raw::c_uint = 1584;
pub const MSR_PKG_C9_RESIDENCY: ::std::os::raw::c_uint = 1585;
pub const MSR_PKG_C10_RESIDENCY: ::std::os::raw::c_uint = 1586;
pub const MSR_RAPL_POWER_UNIT: ::std::os::raw::c_uint = 1542;
pub const MSR_PKG_POWER_LIMIT: ::std::os::raw::c_uint = 1552;
pub const MSR_PKG_ENERGY_STATUS: ::std::os::raw::c_uint = 1553;
pub const MSR_PKG_PERF_STATUS: ::std::os::raw::c_uint = 1555;
pub const MSR_PKG_POWER_INFO: ::std::os::raw::c_uint = 1556;
pub const MSR_DRAM_POWER_LIMIT: ::std::os::raw::c_uint = 1560;
pub const MSR_DRAM_ENERGY_STATUS: ::std::os::raw::c_uint = 1561;
pub const MSR_DRAM_PERF_STATUS: ::std::os::raw::c_uint = 1563;
pub const MSR_DRAM_POWER_INFO: ::std::os::raw::c_uint = 1564;
pub const MSR_PP0_POWER_LIMIT: ::std::os::raw::c_uint = 1592;
pub const MSR_PP0_ENERGY_STATUS: ::std::os::raw::c_uint = 1593;
pub const MSR_PP0_POLICY: ::std::os::raw::c_uint = 1594;
pub const MSR_PP0_PERF_STATUS: ::std::os::raw::c_uint = 1595;
pub const MSR_PP1_POWER_LIMIT: ::std::os::raw::c_uint = 1600;
pub const MSR_PP1_ENERGY_STATUS: ::std::os::raw::c_uint = 1601;
pub const MSR_PP1_POLICY: ::std::os::raw::c_uint = 1602;
pub const MSR_PKG_WEIGHTED_CORE_C0_RES: ::std::os::raw::c_uint = 1624;
pub const MSR_PKG_ANY_CORE_C0_RES: ::std::os::raw::c_uint = 1625;
pub const MSR_PKG_ANY_GFXE_C0_RES: ::std::os::raw::c_uint = 1626;
pub const MSR_PKG_BOTH_CORE_GFXE_C0_RES: ::std::os::raw::c_uint = 1627;
pub const MSR_CORE_C1_RES: ::std::os::raw::c_uint = 1632;
pub const MSR_CC6_DEMOTION_POLICY_CONFIG: ::std::os::raw::c_uint = 1640;
pub const MSR_MC6_DEMOTION_POLICY_CONFIG: ::std::os::raw::c_uint = 1641;
pub const MSR_CORE_PERF_LIMIT_REASONS: ::std::os::raw::c_uint = 1680;
pub const MSR_GFX_PERF_LIMIT_REASONS: ::std::os::raw::c_uint = 1712;
pub const MSR_RING_PERF_LIMIT_REASONS: ::std::os::raw::c_uint = 1713;
pub const MSR_PPERF: ::std::os::raw::c_uint = 1614;
pub const MSR_PERF_LIMIT_REASONS: ::std::os::raw::c_uint = 1615;
pub const MSR_PM_ENABLE: ::std::os::raw::c_uint = 1904;
pub const MSR_HWP_CAPABILITIES: ::std::os::raw::c_uint = 1905;
pub const MSR_HWP_REQUEST_PKG: ::std::os::raw::c_uint = 1906;
pub const MSR_HWP_INTERRUPT: ::std::os::raw::c_uint = 1907;
pub const MSR_HWP_REQUEST: ::std::os::raw::c_uint = 1908;
pub const MSR_HWP_STATUS: ::std::os::raw::c_uint = 1911;
pub const HWP_BASE_BIT: ::std::os::raw::c_uint = 128;
pub const HWP_NOTIFICATIONS_BIT: ::std::os::raw::c_uint = 256;
pub const HWP_ACTIVITY_WINDOW_BIT: ::std::os::raw::c_uint = 512;
pub const HWP_ENERGY_PERF_PREFERENCE_BIT: ::std::os::raw::c_uint = 1024;
pub const HWP_PACKAGE_LEVEL_REQUEST_BIT: ::std::os::raw::c_uint = 2048;
pub const MSR_AMD64_MC0_MASK: ::std::os::raw::c_uint = 3221291076;
pub const MSR_IA32_MC0_CTL2: ::std::os::raw::c_uint = 640;
pub const MSR_P6_PERFCTR0: ::std::os::raw::c_uint = 193;
pub const MSR_P6_PERFCTR1: ::std::os::raw::c_uint = 194;
pub const MSR_P6_EVNTSEL0: ::std::os::raw::c_uint = 390;
pub const MSR_P6_EVNTSEL1: ::std::os::raw::c_uint = 391;
pub const MSR_KNC_PERFCTR0: ::std::os::raw::c_uint = 32;
pub const MSR_KNC_PERFCTR1: ::std::os::raw::c_uint = 33;
pub const MSR_KNC_EVNTSEL0: ::std::os::raw::c_uint = 40;
pub const MSR_KNC_EVNTSEL1: ::std::os::raw::c_uint = 41;
pub const MSR_IA32_PMC0: ::std::os::raw::c_uint = 1217;
pub const MSR_AMD64_PATCH_LEVEL: ::std::os::raw::c_uint = 139;
pub const MSR_AMD64_TSC_RATIO: ::std::os::raw::c_uint = 3221225732;
pub const MSR_AMD64_NB_CFG: ::std::os::raw::c_uint = 3221291039;
pub const MSR_AMD64_PATCH_LOADER: ::std::os::raw::c_uint = 3221291040;
pub const MSR_AMD64_OSVW_ID_LENGTH: ::std::os::raw::c_uint = 3221291328;
pub const MSR_AMD64_OSVW_STATUS: ::std::os::raw::c_uint = 3221291329;
pub const MSR_AMD64_LS_CFG: ::std::os::raw::c_uint = 3221295136;
pub const MSR_AMD64_DC_CFG: ::std::os::raw::c_uint = 3221295138;
pub const MSR_AMD64_BU_CFG2: ::std::os::raw::c_uint = 3221295146;
pub const MSR_AMD64_IBSFETCHCTL: ::std::os::raw::c_uint = 3221295152;
pub const MSR_AMD64_IBSFETCHLINAD: ::std::os::raw::c_uint = 3221295153;
pub const MSR_AMD64_IBSFETCHPHYSAD: ::std::os::raw::c_uint = 3221295154;
pub const MSR_AMD64_IBSFETCH_REG_COUNT: ::std::os::raw::c_uint = 3;
pub const MSR_AMD64_IBSFETCH_REG_MASK: ::std::os::raw::c_uint = 7;
pub const MSR_AMD64_IBSOPCTL: ::std::os::raw::c_uint = 3221295155;
pub const MSR_AMD64_IBSOPRIP: ::std::os::raw::c_uint = 3221295156;
pub const MSR_AMD64_IBSOPDATA: ::std::os::raw::c_uint = 3221295157;
pub const MSR_AMD64_IBSOPDATA2: ::std::os::raw::c_uint = 3221295158;
pub const MSR_AMD64_IBSOPDATA3: ::std::os::raw::c_uint = 3221295159;
pub const MSR_AMD64_IBSDCLINAD: ::std::os::raw::c_uint = 3221295160;
pub const MSR_AMD64_IBSDCPHYSAD: ::std::os::raw::c_uint = 3221295161;
pub const MSR_AMD64_IBSOP_REG_COUNT: ::std::os::raw::c_uint = 7;
pub const MSR_AMD64_IBSOP_REG_MASK: ::std::os::raw::c_uint = 127;
pub const MSR_AMD64_IBSCTL: ::std::os::raw::c_uint = 3221295162;
pub const MSR_AMD64_IBSBRTARGET: ::std::os::raw::c_uint = 3221295163;
pub const MSR_AMD64_IBSOPDATA4: ::std::os::raw::c_uint = 3221295165;
pub const MSR_AMD64_IBS_REG_COUNT_MAX: ::std::os::raw::c_uint = 8;
pub const MSR_F16H_L2I_PERF_CTL: ::std::os::raw::c_uint = 3221291568;
pub const MSR_F16H_L2I_PERF_CTR: ::std::os::raw::c_uint = 3221291569;
pub const MSR_F16H_DR1_ADDR_MASK: ::std::os::raw::c_uint = 3221295129;
pub const MSR_F16H_DR2_ADDR_MASK: ::std::os::raw::c_uint = 3221295130;
pub const MSR_F16H_DR3_ADDR_MASK: ::std::os::raw::c_uint = 3221295131;
pub const MSR_F16H_DR0_ADDR_MASK: ::std::os::raw::c_uint = 3221295143;
pub const MSR_F15H_PERF_CTL: ::std::os::raw::c_uint = 3221291520;
pub const MSR_F15H_PERF_CTR: ::std::os::raw::c_uint = 3221291521;
pub const MSR_F15H_NB_PERF_CTL: ::std::os::raw::c_uint = 3221291584;
pub const MSR_F15H_NB_PERF_CTR: ::std::os::raw::c_uint = 3221291585;
pub const MSR_FAM10H_MMIO_CONF_BASE: ::std::os::raw::c_uint = 3221291096;
pub const FAM10H_MMIO_CONF_ENABLE: ::std::os::raw::c_uint = 1;
pub const FAM10H_MMIO_CONF_BUSRANGE_MASK: ::std::os::raw::c_uint = 15;
pub const FAM10H_MMIO_CONF_BUSRANGE_SHIFT: ::std::os::raw::c_uint = 2;
pub const FAM10H_MMIO_CONF_BASE_MASK: ::std::os::raw::c_uint = 268435455;
pub const FAM10H_MMIO_CONF_BASE_SHIFT: ::std::os::raw::c_uint = 20;
pub const MSR_FAM10H_NODE_ID: ::std::os::raw::c_uint = 3221295116;
pub const MSR_K8_TOP_MEM1: ::std::os::raw::c_uint = 3221291034;
pub const MSR_K8_TOP_MEM2: ::std::os::raw::c_uint = 3221291037;
pub const MSR_K8_SYSCFG: ::std::os::raw::c_uint = 3221291024;
pub const MSR_K8_INT_PENDING_MSG: ::std::os::raw::c_uint = 3221291093;
pub const K8_INTP_C1E_ACTIVE_MASK: ::std::os::raw::c_uint = 402653184;
pub const MSR_K8_TSEG_ADDR: ::std::os::raw::c_uint = 3221291282;
pub const MSR_K8_TSEG_MASK: ::std::os::raw::c_uint = 3221291283;
pub const K8_MTRRFIXRANGE_DRAM_ENABLE: ::std::os::raw::c_uint = 262144;
pub const K8_MTRRFIXRANGE_DRAM_MODIFY: ::std::os::raw::c_uint = 524288;
pub const K8_MTRR_RDMEM_WRMEM_MASK: ::std::os::raw::c_uint = 404232216;
pub const MSR_K7_EVNTSEL0: ::std::os::raw::c_uint = 3221291008;
pub const MSR_K7_PERFCTR0: ::std::os::raw::c_uint = 3221291012;
pub const MSR_K7_EVNTSEL1: ::std::os::raw::c_uint = 3221291009;
pub const MSR_K7_PERFCTR1: ::std::os::raw::c_uint = 3221291013;
pub const MSR_K7_EVNTSEL2: ::std::os::raw::c_uint = 3221291010;
pub const MSR_K7_PERFCTR2: ::std::os::raw::c_uint = 3221291014;
pub const MSR_K7_EVNTSEL3: ::std::os::raw::c_uint = 3221291011;
pub const MSR_K7_PERFCTR3: ::std::os::raw::c_uint = 3221291015;
pub const MSR_K7_CLK_CTL: ::std::os::raw::c_uint = 3221291035;
pub const MSR_K7_HWCR: ::std::os::raw::c_uint = 3221291029;
pub const MSR_K7_FID_VID_CTL: ::std::os::raw::c_uint = 3221291073;
pub const MSR_K7_FID_VID_STATUS: ::std::os::raw::c_uint = 3221291074;
pub const MSR_K6_WHCR: ::std::os::raw::c_uint = 3221225602;
pub const MSR_K6_UWCCR: ::std::os::raw::c_uint = 3221225605;
pub const MSR_K6_EPMR: ::std::os::raw::c_uint = 3221225606;
pub const MSR_K6_PSOR: ::std::os::raw::c_uint = 3221225607;
pub const MSR_K6_PFIR: ::std::os::raw::c_uint = 3221225608;
pub const MSR_IDT_FCR1: ::std::os::raw::c_uint = 263;
pub const MSR_IDT_FCR2: ::std::os::raw::c_uint = 264;
pub const MSR_IDT_FCR3: ::std::os::raw::c_uint = 265;
pub const MSR_IDT_FCR4: ::std::os::raw::c_uint = 266;
pub const MSR_IDT_MCR0: ::std::os::raw::c_uint = 272;
pub const MSR_IDT_MCR1: ::std::os::raw::c_uint = 273;
pub const MSR_IDT_MCR2: ::std::os::raw::c_uint = 274;
pub const MSR_IDT_MCR3: ::std::os::raw::c_uint = 275;
pub const MSR_IDT_MCR4: ::std::os::raw::c_uint = 276;
pub const MSR_IDT_MCR5: ::std::os::raw::c_uint = 277;
pub const MSR_IDT_MCR6: ::std::os::raw::c_uint = 278;
pub const MSR_IDT_MCR7: ::std::os::raw::c_uint = 279;
pub const MSR_IDT_MCR_CTRL: ::std::os::raw::c_uint = 288;
pub const MSR_VIA_FCR: ::std::os::raw::c_uint = 4359;
pub const MSR_VIA_LONGHAUL: ::std::os::raw::c_uint = 4362;
pub const MSR_VIA_RNG: ::std::os::raw::c_uint = 4363;
pub const MSR_VIA_BCR2: ::std::os::raw::c_uint = 4423;
pub const MSR_TMTA_LONGRUN_CTRL: ::std::os::raw::c_uint = 2156298256;
pub const MSR_TMTA_LONGRUN_FLAGS: ::std::os::raw::c_uint = 2156298257;
pub const MSR_TMTA_LRTI_READOUT: ::std::os::raw::c_uint = 2156298264;
pub const MSR_TMTA_LRTI_VOLT_MHZ: ::std::os::raw::c_uint = 2156298266;
pub const MSR_IA32_P5_MC_ADDR: ::std::os::raw::c_uint = 0;
pub const MSR_IA32_P5_MC_TYPE: ::std::os::raw::c_uint = 1;
pub const MSR_IA32_TSC: ::std::os::raw::c_uint = 16;
pub const MSR_IA32_PLATFORM_ID: ::std::os::raw::c_uint = 23;
pub const MSR_IA32_EBL_CR_POWERON: ::std::os::raw::c_uint = 42;
pub const MSR_EBC_FREQUENCY_ID: ::std::os::raw::c_uint = 44;
pub const MSR_SMI_COUNT: ::std::os::raw::c_uint = 52;
pub const MSR_IA32_FEATURE_CONTROL: ::std::os::raw::c_uint = 58;
pub const MSR_IA32_TSC_ADJUST: ::std::os::raw::c_uint = 59;
pub const MSR_IA32_BNDCFGS: ::std::os::raw::c_uint = 3472;
pub const MSR_IA32_XSS: ::std::os::raw::c_uint = 3488;
pub const FEATURE_CONTROL_LOCKED: ::std::os::raw::c_uint = 1;
pub const FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX: ::std::os::raw::c_uint =
    2;
pub const FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX: ::std::os::raw::c_uint =
    4;
pub const FEATURE_CONTROL_LMCE: ::std::os::raw::c_uint = 1048576;
pub const MSR_IA32_APICBASE: ::std::os::raw::c_uint = 27;
pub const MSR_IA32_APICBASE_BSP: ::std::os::raw::c_uint = 256;
pub const MSR_IA32_APICBASE_ENABLE: ::std::os::raw::c_uint = 2048;
pub const MSR_IA32_APICBASE_BASE: ::std::os::raw::c_uint = 4294963200;
pub const MSR_IA32_TSCDEADLINE: ::std::os::raw::c_uint = 1760;
pub const MSR_IA32_UCODE_WRITE: ::std::os::raw::c_uint = 121;
pub const MSR_IA32_UCODE_REV: ::std::os::raw::c_uint = 139;
pub const MSR_IA32_SMM_MONITOR_CTL: ::std::os::raw::c_uint = 155;
pub const MSR_IA32_SMBASE: ::std::os::raw::c_uint = 158;
pub const MSR_IA32_PERF_STATUS: ::std::os::raw::c_uint = 408;
pub const MSR_IA32_PERF_CTL: ::std::os::raw::c_uint = 409;
pub const INTEL_PERF_CTL_MASK: ::std::os::raw::c_uint = 65535;
pub const MSR_AMD_PSTATE_DEF_BASE: ::std::os::raw::c_uint = 3221291108;
pub const MSR_AMD_PERF_STATUS: ::std::os::raw::c_uint = 3221291107;
pub const MSR_AMD_PERF_CTL: ::std::os::raw::c_uint = 3221291106;
pub const MSR_IA32_MPERF: ::std::os::raw::c_uint = 231;
pub const MSR_IA32_APERF: ::std::os::raw::c_uint = 232;
pub const MSR_IA32_THERM_CONTROL: ::std::os::raw::c_uint = 410;
pub const MSR_IA32_THERM_INTERRUPT: ::std::os::raw::c_uint = 411;
pub const THERM_INT_HIGH_ENABLE: ::std::os::raw::c_uint = 1;
pub const THERM_INT_LOW_ENABLE: ::std::os::raw::c_uint = 2;
pub const THERM_INT_PLN_ENABLE: ::std::os::raw::c_uint = 16777216;
pub const MSR_IA32_THERM_STATUS: ::std::os::raw::c_uint = 412;
pub const THERM_STATUS_PROCHOT: ::std::os::raw::c_uint = 1;
pub const THERM_STATUS_POWER_LIMIT: ::std::os::raw::c_uint = 1024;
pub const MSR_THERM2_CTL: ::std::os::raw::c_uint = 413;
pub const MSR_THERM2_CTL_TM_SELECT: ::std::os::raw::c_uint = 65536;
pub const MSR_IA32_MISC_ENABLE: ::std::os::raw::c_uint = 416;
pub const MSR_IA32_TEMPERATURE_TARGET: ::std::os::raw::c_uint = 418;
pub const MSR_MISC_PWR_MGMT: ::std::os::raw::c_uint = 426;
pub const MSR_IA32_ENERGY_PERF_BIAS: ::std::os::raw::c_uint = 432;
pub const ENERGY_PERF_BIAS_PERFORMANCE: ::std::os::raw::c_uint = 0;
pub const ENERGY_PERF_BIAS_NORMAL: ::std::os::raw::c_uint = 6;
pub const ENERGY_PERF_BIAS_POWERSAVE: ::std::os::raw::c_uint = 15;
pub const MSR_IA32_PACKAGE_THERM_STATUS: ::std::os::raw::c_uint = 433;
pub const PACKAGE_THERM_STATUS_PROCHOT: ::std::os::raw::c_uint = 1;
pub const PACKAGE_THERM_STATUS_POWER_LIMIT: ::std::os::raw::c_uint = 1024;
pub const MSR_IA32_PACKAGE_THERM_INTERRUPT: ::std::os::raw::c_uint = 434;
pub const PACKAGE_THERM_INT_HIGH_ENABLE: ::std::os::raw::c_uint = 1;
pub const PACKAGE_THERM_INT_LOW_ENABLE: ::std::os::raw::c_uint = 2;
pub const PACKAGE_THERM_INT_PLN_ENABLE: ::std::os::raw::c_uint = 16777216;
pub const THERM_INT_THRESHOLD0_ENABLE: ::std::os::raw::c_uint = 32768;
pub const THERM_SHIFT_THRESHOLD0: ::std::os::raw::c_uint = 8;
pub const THERM_MASK_THRESHOLD0: ::std::os::raw::c_uint = 32512;
pub const THERM_INT_THRESHOLD1_ENABLE: ::std::os::raw::c_uint = 8388608;
pub const THERM_SHIFT_THRESHOLD1: ::std::os::raw::c_uint = 16;
pub const THERM_MASK_THRESHOLD1: ::std::os::raw::c_uint = 8323072;
pub const THERM_STATUS_THRESHOLD0: ::std::os::raw::c_uint = 64;
pub const THERM_LOG_THRESHOLD0: ::std::os::raw::c_uint = 128;
pub const THERM_STATUS_THRESHOLD1: ::std::os::raw::c_uint = 256;
pub const THERM_LOG_THRESHOLD1: ::std::os::raw::c_uint = 512;
pub const MSR_IA32_MISC_ENABLE_FAST_STRING_BIT: ::std::os::raw::c_uint = 0;
pub const MSR_IA32_MISC_ENABLE_FAST_STRING: ::std::os::raw::c_uint = 1;
pub const MSR_IA32_MISC_ENABLE_TCC_BIT: ::std::os::raw::c_uint = 1;
pub const MSR_IA32_MISC_ENABLE_TCC: ::std::os::raw::c_uint = 2;
pub const MSR_IA32_MISC_ENABLE_EMON_BIT: ::std::os::raw::c_uint = 7;
pub const MSR_IA32_MISC_ENABLE_EMON: ::std::os::raw::c_uint = 128;
pub const MSR_IA32_MISC_ENABLE_BTS_UNAVAIL_BIT: ::std::os::raw::c_uint = 11;
pub const MSR_IA32_MISC_ENABLE_BTS_UNAVAIL: ::std::os::raw::c_uint = 2048;
pub const MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL_BIT: ::std::os::raw::c_uint = 12;
pub const MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL: ::std::os::raw::c_uint = 4096;
pub const MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP_BIT: ::std::os::raw::c_uint
          =
    16;
pub const MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP: ::std::os::raw::c_uint =
    65536;
pub const MSR_IA32_MISC_ENABLE_MWAIT_BIT: ::std::os::raw::c_uint = 18;
pub const MSR_IA32_MISC_ENABLE_MWAIT: ::std::os::raw::c_uint = 262144;
pub const MSR_IA32_MISC_ENABLE_LIMIT_CPUID_BIT: ::std::os::raw::c_uint = 22;
pub const MSR_IA32_MISC_ENABLE_LIMIT_CPUID: ::std::os::raw::c_uint = 4194304;
pub const MSR_IA32_MISC_ENABLE_XTPR_DISABLE_BIT: ::std::os::raw::c_uint = 23;
pub const MSR_IA32_MISC_ENABLE_XTPR_DISABLE: ::std::os::raw::c_uint = 8388608;
pub const MSR_IA32_MISC_ENABLE_XD_DISABLE_BIT: ::std::os::raw::c_uint = 34;
pub const MSR_IA32_MISC_ENABLE_XD_DISABLE: ::std::os::raw::c_ulonglong =
    17179869184;
pub const MSR_IA32_MISC_ENABLE_X87_COMPAT_BIT: ::std::os::raw::c_uint = 2;
pub const MSR_IA32_MISC_ENABLE_X87_COMPAT: ::std::os::raw::c_uint = 4;
pub const MSR_IA32_MISC_ENABLE_TM1_BIT: ::std::os::raw::c_uint = 3;
pub const MSR_IA32_MISC_ENABLE_TM1: ::std::os::raw::c_uint = 8;
pub const MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE_BIT: ::std::os::raw::c_uint
          =
    4;
pub const MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE: ::std::os::raw::c_uint =
    16;
pub const MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE_BIT: ::std::os::raw::c_uint =
    6;
pub const MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE: ::std::os::raw::c_uint = 64;
pub const MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK_BIT: ::std::os::raw::c_uint = 8;
pub const MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK: ::std::os::raw::c_uint = 256;
pub const MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE_BIT: ::std::os::raw::c_uint =
    9;
pub const MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE: ::std::os::raw::c_uint = 512;
pub const MSR_IA32_MISC_ENABLE_FERR_BIT: ::std::os::raw::c_uint = 10;
pub const MSR_IA32_MISC_ENABLE_FERR: ::std::os::raw::c_uint = 1024;
pub const MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX_BIT: ::std::os::raw::c_uint =
    10;
pub const MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX: ::std::os::raw::c_uint = 1024;
pub const MSR_IA32_MISC_ENABLE_TM2_BIT: ::std::os::raw::c_uint = 13;
pub const MSR_IA32_MISC_ENABLE_TM2: ::std::os::raw::c_uint = 8192;
pub const MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE_BIT: ::std::os::raw::c_uint =
    19;
pub const MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE: ::std::os::raw::c_uint =
    524288;
pub const MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK_BIT: ::std::os::raw::c_uint =
    20;
pub const MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK: ::std::os::raw::c_uint =
    1048576;
pub const MSR_IA32_MISC_ENABLE_L1D_CONTEXT_BIT: ::std::os::raw::c_uint = 24;
pub const MSR_IA32_MISC_ENABLE_L1D_CONTEXT: ::std::os::raw::c_uint = 16777216;
pub const MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE_BIT: ::std::os::raw::c_uint =
    37;
pub const MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE: ::std::os::raw::c_ulonglong =
    137438953472;
pub const MSR_IA32_MISC_ENABLE_TURBO_DISABLE_BIT: ::std::os::raw::c_uint = 38;
pub const MSR_IA32_MISC_ENABLE_TURBO_DISABLE: ::std::os::raw::c_ulonglong =
    274877906944;
pub const MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE_BIT: ::std::os::raw::c_uint =
    39;
pub const MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE: ::std::os::raw::c_ulonglong =
    549755813888;
pub const MSR_IA32_TSC_DEADLINE: ::std::os::raw::c_uint = 1760;
pub const MSR_IA32_MCG_EAX: ::std::os::raw::c_uint = 384;
pub const MSR_IA32_MCG_EBX: ::std::os::raw::c_uint = 385;
pub const MSR_IA32_MCG_ECX: ::std::os::raw::c_uint = 386;
pub const MSR_IA32_MCG_EDX: ::std::os::raw::c_uint = 387;
pub const MSR_IA32_MCG_ESI: ::std::os::raw::c_uint = 388;
pub const MSR_IA32_MCG_EDI: ::std::os::raw::c_uint = 389;
pub const MSR_IA32_MCG_EBP: ::std::os::raw::c_uint = 390;
pub const MSR_IA32_MCG_ESP: ::std::os::raw::c_uint = 391;
pub const MSR_IA32_MCG_EFLAGS: ::std::os::raw::c_uint = 392;
pub const MSR_IA32_MCG_EIP: ::std::os::raw::c_uint = 393;
pub const MSR_IA32_MCG_RESERVED: ::std::os::raw::c_uint = 394;
pub const MSR_P4_BPU_PERFCTR0: ::std::os::raw::c_uint = 768;
pub const MSR_P4_BPU_PERFCTR1: ::std::os::raw::c_uint = 769;
pub const MSR_P4_BPU_PERFCTR2: ::std::os::raw::c_uint = 770;
pub const MSR_P4_BPU_PERFCTR3: ::std::os::raw::c_uint = 771;
pub const MSR_P4_MS_PERFCTR0: ::std::os::raw::c_uint = 772;
pub const MSR_P4_MS_PERFCTR1: ::std::os::raw::c_uint = 773;
pub const MSR_P4_MS_PERFCTR2: ::std::os::raw::c_uint = 774;
pub const MSR_P4_MS_PERFCTR3: ::std::os::raw::c_uint = 775;
pub const MSR_P4_FLAME_PERFCTR0: ::std::os::raw::c_uint = 776;
pub const MSR_P4_FLAME_PERFCTR1: ::std::os::raw::c_uint = 777;
pub const MSR_P4_FLAME_PERFCTR2: ::std::os::raw::c_uint = 778;
pub const MSR_P4_FLAME_PERFCTR3: ::std::os::raw::c_uint = 779;
pub const MSR_P4_IQ_PERFCTR0: ::std::os::raw::c_uint = 780;
pub const MSR_P4_IQ_PERFCTR1: ::std::os::raw::c_uint = 781;
pub const MSR_P4_IQ_PERFCTR2: ::std::os::raw::c_uint = 782;
pub const MSR_P4_IQ_PERFCTR3: ::std::os::raw::c_uint = 783;
pub const MSR_P4_IQ_PERFCTR4: ::std::os::raw::c_uint = 784;
pub const MSR_P4_IQ_PERFCTR5: ::std::os::raw::c_uint = 785;
pub const MSR_P4_BPU_CCCR0: ::std::os::raw::c_uint = 864;
pub const MSR_P4_BPU_CCCR1: ::std::os::raw::c_uint = 865;
pub const MSR_P4_BPU_CCCR2: ::std::os::raw::c_uint = 866;
pub const MSR_P4_BPU_CCCR3: ::std::os::raw::c_uint = 867;
pub const MSR_P4_MS_CCCR0: ::std::os::raw::c_uint = 868;
pub const MSR_P4_MS_CCCR1: ::std::os::raw::c_uint = 869;
pub const MSR_P4_MS_CCCR2: ::std::os::raw::c_uint = 870;
pub const MSR_P4_MS_CCCR3: ::std::os::raw::c_uint = 871;
pub const MSR_P4_FLAME_CCCR0: ::std::os::raw::c_uint = 872;
pub const MSR_P4_FLAME_CCCR1: ::std::os::raw::c_uint = 873;
pub const MSR_P4_FLAME_CCCR2: ::std::os::raw::c_uint = 874;
pub const MSR_P4_FLAME_CCCR3: ::std::os::raw::c_uint = 875;
pub const MSR_P4_IQ_CCCR0: ::std::os::raw::c_uint = 876;
pub const MSR_P4_IQ_CCCR1: ::std::os::raw::c_uint = 877;
pub const MSR_P4_IQ_CCCR2: ::std::os::raw::c_uint = 878;
pub const MSR_P4_IQ_CCCR3: ::std::os::raw::c_uint = 879;
pub const MSR_P4_IQ_CCCR4: ::std::os::raw::c_uint = 880;
pub const MSR_P4_IQ_CCCR5: ::std::os::raw::c_uint = 881;
pub const MSR_P4_ALF_ESCR0: ::std::os::raw::c_uint = 970;
pub const MSR_P4_ALF_ESCR1: ::std::os::raw::c_uint = 971;
pub const MSR_P4_BPU_ESCR0: ::std::os::raw::c_uint = 946;
pub const MSR_P4_BPU_ESCR1: ::std::os::raw::c_uint = 947;
pub const MSR_P4_BSU_ESCR0: ::std::os::raw::c_uint = 928;
pub const MSR_P4_BSU_ESCR1: ::std::os::raw::c_uint = 929;
pub const MSR_P4_CRU_ESCR0: ::std::os::raw::c_uint = 952;
pub const MSR_P4_CRU_ESCR1: ::std::os::raw::c_uint = 953;
pub const MSR_P4_CRU_ESCR2: ::std::os::raw::c_uint = 972;
pub const MSR_P4_CRU_ESCR3: ::std::os::raw::c_uint = 973;
pub const MSR_P4_CRU_ESCR4: ::std::os::raw::c_uint = 992;
pub const MSR_P4_CRU_ESCR5: ::std::os::raw::c_uint = 993;
pub const MSR_P4_DAC_ESCR0: ::std::os::raw::c_uint = 936;
pub const MSR_P4_DAC_ESCR1: ::std::os::raw::c_uint = 937;
pub const MSR_P4_FIRM_ESCR0: ::std::os::raw::c_uint = 932;
pub const MSR_P4_FIRM_ESCR1: ::std::os::raw::c_uint = 933;
pub const MSR_P4_FLAME_ESCR0: ::std::os::raw::c_uint = 934;
pub const MSR_P4_FLAME_ESCR1: ::std::os::raw::c_uint = 935;
pub const MSR_P4_FSB_ESCR0: ::std::os::raw::c_uint = 930;
pub const MSR_P4_FSB_ESCR1: ::std::os::raw::c_uint = 931;
pub const MSR_P4_IQ_ESCR0: ::std::os::raw::c_uint = 954;
pub const MSR_P4_IQ_ESCR1: ::std::os::raw::c_uint = 955;
pub const MSR_P4_IS_ESCR0: ::std::os::raw::c_uint = 948;
pub const MSR_P4_IS_ESCR1: ::std::os::raw::c_uint = 949;
pub const MSR_P4_ITLB_ESCR0: ::std::os::raw::c_uint = 950;
pub const MSR_P4_ITLB_ESCR1: ::std::os::raw::c_uint = 951;
pub const MSR_P4_IX_ESCR0: ::std::os::raw::c_uint = 968;
pub const MSR_P4_IX_ESCR1: ::std::os::raw::c_uint = 969;
pub const MSR_P4_MOB_ESCR0: ::std::os::raw::c_uint = 938;
pub const MSR_P4_MOB_ESCR1: ::std::os::raw::c_uint = 939;
pub const MSR_P4_MS_ESCR0: ::std::os::raw::c_uint = 960;
pub const MSR_P4_MS_ESCR1: ::std::os::raw::c_uint = 961;
pub const MSR_P4_PMH_ESCR0: ::std::os::raw::c_uint = 940;
pub const MSR_P4_PMH_ESCR1: ::std::os::raw::c_uint = 941;
pub const MSR_P4_RAT_ESCR0: ::std::os::raw::c_uint = 956;
pub const MSR_P4_RAT_ESCR1: ::std::os::raw::c_uint = 957;
pub const MSR_P4_SAAT_ESCR0: ::std::os::raw::c_uint = 942;
pub const MSR_P4_SAAT_ESCR1: ::std::os::raw::c_uint = 943;
pub const MSR_P4_SSU_ESCR0: ::std::os::raw::c_uint = 958;
pub const MSR_P4_SSU_ESCR1: ::std::os::raw::c_uint = 959;
pub const MSR_P4_TBPU_ESCR0: ::std::os::raw::c_uint = 962;
pub const MSR_P4_TBPU_ESCR1: ::std::os::raw::c_uint = 963;
pub const MSR_P4_TC_ESCR0: ::std::os::raw::c_uint = 964;
pub const MSR_P4_TC_ESCR1: ::std::os::raw::c_uint = 965;
pub const MSR_P4_U2L_ESCR0: ::std::os::raw::c_uint = 944;
pub const MSR_P4_U2L_ESCR1: ::std::os::raw::c_uint = 945;
pub const MSR_P4_PEBS_MATRIX_VERT: ::std::os::raw::c_uint = 1010;
pub const MSR_CORE_PERF_FIXED_CTR0: ::std::os::raw::c_uint = 777;
pub const MSR_CORE_PERF_FIXED_CTR1: ::std::os::raw::c_uint = 778;
pub const MSR_CORE_PERF_FIXED_CTR2: ::std::os::raw::c_uint = 779;
pub const MSR_CORE_PERF_FIXED_CTR_CTRL: ::std::os::raw::c_uint = 909;
pub const MSR_CORE_PERF_GLOBAL_STATUS: ::std::os::raw::c_uint = 910;
pub const MSR_CORE_PERF_GLOBAL_CTRL: ::std::os::raw::c_uint = 911;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL: ::std::os::raw::c_uint = 912;
pub const MSR_GEODE_BUSCONT_CONF0: ::std::os::raw::c_uint = 6400;
pub const MSR_IA32_VMX_BASIC: ::std::os::raw::c_uint = 1152;
pub const MSR_IA32_VMX_PINBASED_CTLS: ::std::os::raw::c_uint = 1153;
pub const MSR_IA32_VMX_PROCBASED_CTLS: ::std::os::raw::c_uint = 1154;
pub const MSR_IA32_VMX_EXIT_CTLS: ::std::os::raw::c_uint = 1155;
pub const MSR_IA32_VMX_ENTRY_CTLS: ::std::os::raw::c_uint = 1156;
pub const MSR_IA32_VMX_MISC: ::std::os::raw::c_uint = 1157;
pub const MSR_IA32_VMX_CR0_FIXED0: ::std::os::raw::c_uint = 1158;
pub const MSR_IA32_VMX_CR0_FIXED1: ::std::os::raw::c_uint = 1159;
pub const MSR_IA32_VMX_CR4_FIXED0: ::std::os::raw::c_uint = 1160;
pub const MSR_IA32_VMX_CR4_FIXED1: ::std::os::raw::c_uint = 1161;
pub const MSR_IA32_VMX_VMCS_ENUM: ::std::os::raw::c_uint = 1162;
pub const MSR_IA32_VMX_PROCBASED_CTLS2: ::std::os::raw::c_uint = 1163;
pub const MSR_IA32_VMX_EPT_VPID_CAP: ::std::os::raw::c_uint = 1164;
pub const MSR_IA32_VMX_TRUE_PINBASED_CTLS: ::std::os::raw::c_uint = 1165;
pub const MSR_IA32_VMX_TRUE_PROCBASED_CTLS: ::std::os::raw::c_uint = 1166;
pub const MSR_IA32_VMX_TRUE_EXIT_CTLS: ::std::os::raw::c_uint = 1167;
pub const MSR_IA32_VMX_TRUE_ENTRY_CTLS: ::std::os::raw::c_uint = 1168;
pub const MSR_IA32_VMX_VMFUNC: ::std::os::raw::c_uint = 1169;
pub const VMX_BASIC_VMCS_SIZE_SHIFT: ::std::os::raw::c_uint = 32;
pub const VMX_BASIC_TRUE_CTLS: ::std::os::raw::c_ulonglong =
    36028797018963968;
pub const VMX_BASIC_64: ::std::os::raw::c_ulonglong = 281474976710656;
pub const VMX_BASIC_MEM_TYPE_SHIFT: ::std::os::raw::c_uint = 50;
pub const VMX_BASIC_MEM_TYPE_MASK: ::std::os::raw::c_ulonglong =
    16888498602639360;
pub const VMX_BASIC_MEM_TYPE_WB: ::std::os::raw::c_uint = 6;
pub const VMX_BASIC_INOUT: ::std::os::raw::c_ulonglong = 18014398509481984;
pub const MSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS: ::std::os::raw::c_uint =
    536870912;
pub const MSR_IA32_VMX_MISC_PREEMPTION_TIMER_SCALE: ::std::os::raw::c_uint =
    31;
pub const MSR_VM_CR: ::std::os::raw::c_uint = 3221291284;
pub const MSR_VM_IGNNE: ::std::os::raw::c_uint = 3221291285;
pub const MSR_VM_HSAVE_PA: ::std::os::raw::c_uint = 3221291287;
pub const EPERM: ::std::os::raw::c_uint = 1;
pub const ENOENT: ::std::os::raw::c_uint = 2;
pub const ESRCH: ::std::os::raw::c_uint = 3;
pub const EINTR: ::std::os::raw::c_uint = 4;
pub const EIO: ::std::os::raw::c_uint = 5;
pub const ENXIO: ::std::os::raw::c_uint = 6;
pub const E2BIG: ::std::os::raw::c_uint = 7;
pub const ENOEXEC: ::std::os::raw::c_uint = 8;
pub const EBADF: ::std::os::raw::c_uint = 9;
pub const ECHILD: ::std::os::raw::c_uint = 10;
pub const EAGAIN: ::std::os::raw::c_uint = 11;
pub const ENOMEM: ::std::os::raw::c_uint = 12;
pub const EACCES: ::std::os::raw::c_uint = 13;
pub const EFAULT: ::std::os::raw::c_uint = 14;
pub const ENOTBLK: ::std::os::raw::c_uint = 15;
pub const EBUSY: ::std::os::raw::c_uint = 16;
pub const EEXIST: ::std::os::raw::c_uint = 17;
pub const EXDEV: ::std::os::raw::c_uint = 18;
pub const ENODEV: ::std::os::raw::c_uint = 19;
pub const ENOTDIR: ::std::os::raw::c_uint = 20;
pub const EISDIR: ::std::os::raw::c_uint = 21;
pub const EINVAL: ::std::os::raw::c_uint = 22;
pub const ENFILE: ::std::os::raw::c_uint = 23;
pub const EMFILE: ::std::os::raw::c_uint = 24;
pub const ENOTTY: ::std::os::raw::c_uint = 25;
pub const ETXTBSY: ::std::os::raw::c_uint = 26;
pub const EFBIG: ::std::os::raw::c_uint = 27;
pub const ENOSPC: ::std::os::raw::c_uint = 28;
pub const ESPIPE: ::std::os::raw::c_uint = 29;
pub const EROFS: ::std::os::raw::c_uint = 30;
pub const EMLINK: ::std::os::raw::c_uint = 31;
pub const EPIPE: ::std::os::raw::c_uint = 32;
pub const EDOM: ::std::os::raw::c_uint = 33;
pub const ERANGE: ::std::os::raw::c_uint = 34;
pub const EDEADLK: ::std::os::raw::c_uint = 35;
pub const ENAMETOOLONG: ::std::os::raw::c_uint = 36;
pub const ENOLCK: ::std::os::raw::c_uint = 37;
pub const ENOSYS: ::std::os::raw::c_uint = 38;
pub const ENOTEMPTY: ::std::os::raw::c_uint = 39;
pub const ELOOP: ::std::os::raw::c_uint = 40;
pub const EWOULDBLOCK: ::std::os::raw::c_uint = 11;
pub const ENOMSG: ::std::os::raw::c_uint = 42;
pub const EIDRM: ::std::os::raw::c_uint = 43;
pub const ECHRNG: ::std::os::raw::c_uint = 44;
pub const EL2NSYNC: ::std::os::raw::c_uint = 45;
pub const EL3HLT: ::std::os::raw::c_uint = 46;
pub const EL3RST: ::std::os::raw::c_uint = 47;
pub const ELNRNG: ::std::os::raw::c_uint = 48;
pub const EUNATCH: ::std::os::raw::c_uint = 49;
pub const ENOCSI: ::std::os::raw::c_uint = 50;
pub const EL2HLT: ::std::os::raw::c_uint = 51;
pub const EBADE: ::std::os::raw::c_uint = 52;
pub const EBADR: ::std::os::raw::c_uint = 53;
pub const EXFULL: ::std::os::raw::c_uint = 54;
pub const ENOANO: ::std::os::raw::c_uint = 55;
pub const EBADRQC: ::std::os::raw::c_uint = 56;
pub const EBADSLT: ::std::os::raw::c_uint = 57;
pub const EDEADLOCK: ::std::os::raw::c_uint = 35;
pub const EBFONT: ::std::os::raw::c_uint = 59;
pub const ENOSTR: ::std::os::raw::c_uint = 60;
pub const ENODATA: ::std::os::raw::c_uint = 61;
pub const ETIME: ::std::os::raw::c_uint = 62;
pub const ENOSR: ::std::os::raw::c_uint = 63;
pub const ENONET: ::std::os::raw::c_uint = 64;
pub const ENOPKG: ::std::os::raw::c_uint = 65;
pub const EREMOTE: ::std::os::raw::c_uint = 66;
pub const ENOLINK: ::std::os::raw::c_uint = 67;
pub const EADV: ::std::os::raw::c_uint = 68;
pub const ESRMNT: ::std::os::raw::c_uint = 69;
pub const ECOMM: ::std::os::raw::c_uint = 70;
pub const EPROTO: ::std::os::raw::c_uint = 71;
pub const EMULTIHOP: ::std::os::raw::c_uint = 72;
pub const EDOTDOT: ::std::os::raw::c_uint = 73;
pub const EBADMSG: ::std::os::raw::c_uint = 74;
pub const EOVERFLOW: ::std::os::raw::c_uint = 75;
pub const ENOTUNIQ: ::std::os::raw::c_uint = 76;
pub const EBADFD: ::std::os::raw::c_uint = 77;
pub const EREMCHG: ::std::os::raw::c_uint = 78;
pub const ELIBACC: ::std::os::raw::c_uint = 79;
pub const ELIBBAD: ::std::os::raw::c_uint = 80;
pub const ELIBSCN: ::std::os::raw::c_uint = 81;
pub const ELIBMAX: ::std::os::raw::c_uint = 82;
pub const ELIBEXEC: ::std::os::raw::c_uint = 83;
pub const EILSEQ: ::std::os::raw::c_uint = 84;
pub const ERESTART: ::std::os::raw::c_uint = 85;
pub const ESTRPIPE: ::std::os::raw::c_uint = 86;
pub const EUSERS: ::std::os::raw::c_uint = 87;
pub const ENOTSOCK: ::std::os::raw::c_uint = 88;
pub const EDESTADDRREQ: ::std::os::raw::c_uint = 89;
pub const EMSGSIZE: ::std::os::raw::c_uint = 90;
pub const EPROTOTYPE: ::std::os::raw::c_uint = 91;
pub const ENOPROTOOPT: ::std::os::raw::c_uint = 92;
pub const EPROTONOSUPPORT: ::std::os::raw::c_uint = 93;
pub const ESOCKTNOSUPPORT: ::std::os::raw::c_uint = 94;
pub const EOPNOTSUPP: ::std::os::raw::c_uint = 95;
pub const EPFNOSUPPORT: ::std::os::raw::c_uint = 96;
pub const EAFNOSUPPORT: ::std::os::raw::c_uint = 97;
pub const EADDRINUSE: ::std::os::raw::c_uint = 98;
pub const EADDRNOTAVAIL: ::std::os::raw::c_uint = 99;
pub const ENETDOWN: ::std::os::raw::c_uint = 100;
pub const ENETUNREACH: ::std::os::raw::c_uint = 101;
pub const ENETRESET: ::std::os::raw::c_uint = 102;
pub const ECONNABORTED: ::std::os::raw::c_uint = 103;
pub const ECONNRESET: ::std::os::raw::c_uint = 104;
pub const ENOBUFS: ::std::os::raw::c_uint = 105;
pub const EISCONN: ::std::os::raw::c_uint = 106;
pub const ENOTCONN: ::std::os::raw::c_uint = 107;
pub const ESHUTDOWN: ::std::os::raw::c_uint = 108;
pub const ETOOMANYREFS: ::std::os::raw::c_uint = 109;
pub const ETIMEDOUT: ::std::os::raw::c_uint = 110;
pub const ECONNREFUSED: ::std::os::raw::c_uint = 111;
pub const EHOSTDOWN: ::std::os::raw::c_uint = 112;
pub const EHOSTUNREACH: ::std::os::raw::c_uint = 113;
pub const EALREADY: ::std::os::raw::c_uint = 114;
pub const EINPROGRESS: ::std::os::raw::c_uint = 115;
pub const ESTALE: ::std::os::raw::c_uint = 116;
pub const EUCLEAN: ::std::os::raw::c_uint = 117;
pub const ENOTNAM: ::std::os::raw::c_uint = 118;
pub const ENAVAIL: ::std::os::raw::c_uint = 119;
pub const EISNAM: ::std::os::raw::c_uint = 120;
pub const EREMOTEIO: ::std::os::raw::c_uint = 121;
pub const EDQUOT: ::std::os::raw::c_uint = 122;
pub const ENOMEDIUM: ::std::os::raw::c_uint = 123;
pub const EMEDIUMTYPE: ::std::os::raw::c_uint = 124;
pub const ECANCELED: ::std::os::raw::c_uint = 125;
pub const ENOKEY: ::std::os::raw::c_uint = 126;
pub const EKEYEXPIRED: ::std::os::raw::c_uint = 127;
pub const EKEYREVOKED: ::std::os::raw::c_uint = 128;
pub const EKEYREJECTED: ::std::os::raw::c_uint = 129;
pub const EOWNERDEAD: ::std::os::raw::c_uint = 130;
pub const ENOTRECOVERABLE: ::std::os::raw::c_uint = 131;
pub const ERFKILL: ::std::os::raw::c_uint = 132;
pub const EHWPOISON: ::std::os::raw::c_uint = 133;
pub const __HAVE_ARCH_MEMCPY: ::std::os::raw::c_uint = 1;
pub const nr_cpumask_bits: ::std::os::raw::c_uint = 256;
pub const _IOC_NRBITS: ::std::os::raw::c_uint = 8;
pub const _IOC_TYPEBITS: ::std::os::raw::c_uint = 8;
pub const _IOC_SIZEBITS: ::std::os::raw::c_uint = 14;
pub const _IOC_DIRBITS: ::std::os::raw::c_uint = 2;
pub const _IOC_NRMASK: ::std::os::raw::c_uint = 255;
pub const _IOC_TYPEMASK: ::std::os::raw::c_uint = 255;
pub const _IOC_SIZEMASK: ::std::os::raw::c_uint = 16383;
pub const _IOC_DIRMASK: ::std::os::raw::c_uint = 3;
pub const _IOC_NRSHIFT: ::std::os::raw::c_uint = 0;
pub const _IOC_TYPESHIFT: ::std::os::raw::c_uint = 8;
pub const _IOC_SIZESHIFT: ::std::os::raw::c_uint = 16;
pub const _IOC_DIRSHIFT: ::std::os::raw::c_uint = 30;
pub const _IOC_NONE: ::std::os::raw::c_uint = 0;
pub const _IOC_WRITE: ::std::os::raw::c_uint = 1;
pub const _IOC_READ: ::std::os::raw::c_uint = 2;
pub const IOC_IN: ::std::os::raw::c_uint = 1073741824;
pub const IOC_OUT: ::std::os::raw::c_uint = 2147483648;
pub const IOC_INOUT: ::std::os::raw::c_uint = 3221225472;
pub const IOCSIZE_MASK: ::std::os::raw::c_uint = 1073676288;
pub const IOCSIZE_SHIFT: ::std::os::raw::c_uint = 16;
pub const PV_SAVE_ALL_CALLER_REGS: &'static [u8; 79usize] =
    b"push %rcx;push %rdx;push %rsi;push %rdi;push %r8;push %r9;push %r10;push %r11;\x00";
pub const PV_RESTORE_ALL_CALLER_REGS: &'static [u8; 71usize] =
    b"pop %r11;pop %r10;pop %r9;pop %r8;pop %rdi;pop %rsi;pop %rdx;pop %rcx;\x00";
pub const PV_SAVE_REGS: &'static [u8; 13usize] = b"pushq %%rdi;\x00";
pub const PV_RESTORE_REGS: &'static [u8; 12usize] = b"popq %%rdi;\x00";
pub const PV_FLAGS_ARG: &'static [u8; 2usize] = b"D\x00";
pub const MXCSR_DEFAULT: ::std::os::raw::c_uint = 8064;
pub const MAX_ERRNO: ::std::os::raw::c_uint = 4095;
pub const NET_IP_ALIGN: ::std::os::raw::c_uint = 0;
pub const HBP_NUM: ::std::os::raw::c_uint = 4;
pub const ARCH_MIN_MMSTRUCT_ALIGN: ::std::os::raw::c_uint = 0;
pub const X86_VENDOR_INTEL: ::std::os::raw::c_uint = 0;
pub const X86_VENDOR_CYRIX: ::std::os::raw::c_uint = 1;
pub const X86_VENDOR_AMD: ::std::os::raw::c_uint = 2;
pub const X86_VENDOR_UMC: ::std::os::raw::c_uint = 3;
pub const X86_VENDOR_CENTAUR: ::std::os::raw::c_uint = 5;
pub const X86_VENDOR_TRANSMETA: ::std::os::raw::c_uint = 7;
pub const X86_VENDOR_NSC: ::std::os::raw::c_uint = 8;
pub const X86_VENDOR_NUM: ::std::os::raw::c_uint = 9;
pub const X86_VENDOR_UNKNOWN: ::std::os::raw::c_uint = 255;
pub const IO_BITMAP_BITS: ::std::os::raw::c_uint = 65536;
pub const IO_BITMAP_BYTES: ::std::os::raw::c_uint = 8192;
pub const INVALID_IO_BITMAP_OFFSET: ::std::os::raw::c_uint = 32768;
pub const HAVE_ARCH_PICK_MMAP_LAYOUT: ::std::os::raw::c_uint = 1;
pub const BASE_PREFETCH: &'static [u8; 15usize] = b"prefetcht0 %P1\x00";
pub const __X86_CASE_B: ::std::os::raw::c_uint = 1;
pub const __X86_CASE_W: ::std::os::raw::c_uint = 2;
pub const __X86_CASE_L: ::std::os::raw::c_uint = 4;
pub const __X86_CASE_Q: ::std::os::raw::c_uint = 8;
pub const TIF_SYSCALL_TRACE: ::std::os::raw::c_uint = 0;
pub const TIF_NOTIFY_RESUME: ::std::os::raw::c_uint = 1;
pub const TIF_SIGPENDING: ::std::os::raw::c_uint = 2;
pub const TIF_NEED_RESCHED: ::std::os::raw::c_uint = 3;
pub const TIF_SINGLESTEP: ::std::os::raw::c_uint = 4;
pub const TIF_SYSCALL_EMU: ::std::os::raw::c_uint = 6;
pub const TIF_SYSCALL_AUDIT: ::std::os::raw::c_uint = 7;
pub const TIF_SECCOMP: ::std::os::raw::c_uint = 8;
pub const TIF_USER_RETURN_NOTIFY: ::std::os::raw::c_uint = 11;
pub const TIF_UPROBE: ::std::os::raw::c_uint = 12;
pub const TIF_NOTSC: ::std::os::raw::c_uint = 16;
pub const TIF_IA32: ::std::os::raw::c_uint = 17;
pub const TIF_FORK: ::std::os::raw::c_uint = 18;
pub const TIF_NOHZ: ::std::os::raw::c_uint = 19;
pub const TIF_MEMDIE: ::std::os::raw::c_uint = 20;
pub const TIF_POLLING_NRFLAG: ::std::os::raw::c_uint = 21;
pub const TIF_IO_BITMAP: ::std::os::raw::c_uint = 22;
pub const TIF_FORCED_TF: ::std::os::raw::c_uint = 24;
pub const TIF_BLOCKSTEP: ::std::os::raw::c_uint = 25;
pub const TIF_LAZY_MMU_UPDATES: ::std::os::raw::c_uint = 27;
pub const TIF_SYSCALL_TRACEPOINT: ::std::os::raw::c_uint = 28;
pub const TIF_ADDR32: ::std::os::raw::c_uint = 29;
pub const TIF_X32: ::std::os::raw::c_uint = 30;
pub const _TIF_SYSCALL_TRACE: ::std::os::raw::c_uint = 1;
pub const _TIF_NOTIFY_RESUME: ::std::os::raw::c_uint = 2;
pub const _TIF_SIGPENDING: ::std::os::raw::c_uint = 4;
pub const _TIF_SINGLESTEP: ::std::os::raw::c_uint = 16;
pub const _TIF_NEED_RESCHED: ::std::os::raw::c_uint = 8;
pub const _TIF_SYSCALL_EMU: ::std::os::raw::c_uint = 64;
pub const _TIF_SYSCALL_AUDIT: ::std::os::raw::c_uint = 128;
pub const _TIF_SECCOMP: ::std::os::raw::c_uint = 256;
pub const _TIF_USER_RETURN_NOTIFY: ::std::os::raw::c_uint = 2048;
pub const _TIF_UPROBE: ::std::os::raw::c_uint = 4096;
pub const _TIF_NOTSC: ::std::os::raw::c_uint = 65536;
pub const _TIF_IA32: ::std::os::raw::c_uint = 131072;
pub const _TIF_FORK: ::std::os::raw::c_uint = 262144;
pub const _TIF_NOHZ: ::std::os::raw::c_uint = 524288;
pub const _TIF_POLLING_NRFLAG: ::std::os::raw::c_uint = 2097152;
pub const _TIF_IO_BITMAP: ::std::os::raw::c_uint = 4194304;
pub const _TIF_FORCED_TF: ::std::os::raw::c_uint = 16777216;
pub const _TIF_BLOCKSTEP: ::std::os::raw::c_uint = 33554432;
pub const _TIF_LAZY_MMU_UPDATES: ::std::os::raw::c_uint = 134217728;
pub const _TIF_SYSCALL_TRACEPOINT: ::std::os::raw::c_uint = 268435456;
pub const _TIF_ADDR32: ::std::os::raw::c_uint = 536870912;
pub const _TIF_X32: ::std::os::raw::c_uint = 1073741824;
pub const _TIF_WORK_SYSCALL_ENTRY: ::std::os::raw::c_uint = 268960209;
pub const _TIF_WORK_SYSCALL_EXIT: ::std::os::raw::c_uint = 268959889;
pub const _TIF_WORK_MASK: ::std::os::raw::c_uint = 65070;
pub const _TIF_ALLWORK_MASK: ::std::os::raw::c_uint = 269025023;
pub const _TIF_DO_NOTIFY_MASK: ::std::os::raw::c_uint = 6150;
pub const _TIF_WORK_CTXSW: ::std::os::raw::c_uint = 37814272;
pub const _TIF_WORK_CTXSW_PREV: ::std::os::raw::c_uint = 37816320;
pub const _TIF_WORK_CTXSW_NEXT: ::std::os::raw::c_uint = 37814272;
pub const TS_COMPAT: ::std::os::raw::c_uint = 2;
pub const TS_RESTORE_SIGMASK: ::std::os::raw::c_uint = 8;
pub const HAVE_SET_RESTORE_SIGMASK: ::std::os::raw::c_uint = 1;
pub const PREEMPT_ENABLED: ::std::os::raw::c_uint = 2147483648;
pub const PREEMPT_DISABLE_OFFSET: ::std::os::raw::c_uint = 0;
pub const PREEMPT_LOCK_OFFSET: ::std::os::raw::c_uint = 0;
pub const SOFTIRQ_LOCK_OFFSET: ::std::os::raw::c_uint = 512;
pub const LOCK_SECTION_END: &'static [u8; 14usize] = b".previous\\n\\t\x00";
pub const SINGLE_DEPTH_NESTING: ::std::os::raw::c_uint = 1;
pub const SPINLOCK_MAGIC: ::std::os::raw::c_uint = 3735899821;
pub const RWLOCK_MAGIC: ::std::os::raw::c_uint = 3736018669;
pub const LOCK_PTR_REG: &'static [u8; 2usize] = b"D\x00";
pub const SPIN_THRESHOLD: ::std::os::raw::c_uint = 32768;
pub const _QW_WAITING: ::std::os::raw::c_uint = 1;
pub const _QW_LOCKED: ::std::os::raw::c_uint = 255;
pub const _QW_WMASK: ::std::os::raw::c_uint = 255;
pub const _QR_SHIFT: ::std::os::raw::c_uint = 8;
pub const _QR_BIAS: ::std::os::raw::c_uint = 256;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const P_ALL: ::std::os::raw::c_uint = 0;
pub const P_PID: ::std::os::raw::c_uint = 1;
pub const P_PGID: ::std::os::raw::c_uint = 2;
pub const WQ_FLAG_EXCLUSIVE: ::std::os::raw::c_uint = 1;
pub const WQ_FLAG_WOKEN: ::std::os::raw::c_uint = 2;
pub const WAIT_ATOMIC_T_BIT_NR: ::std::os::raw::c_int = -1;
pub const NODES_SHIFT: ::std::os::raw::c_uint = 6;
pub const MAX_NUMNODES: ::std::os::raw::c_uint = 64;
pub const NUMA_NO_NODE: ::std::os::raw::c_int = -1;
pub const NR_PAGEFLAGS: ::std::os::raw::c_uint = 25;
pub const MAX_NR_ZONES: ::std::os::raw::c_uint = 4;
pub const NR_CPUS_BITS: ::std::os::raw::c_uint = 8;
pub const SPINLOCK_SIZE: ::std::os::raw::c_uint = 4;
pub const ZONES_SHIFT: ::std::os::raw::c_uint = 2;
pub const SECTIONS_SHIFT: ::std::os::raw::c_uint = 19;
pub const SECTIONS_WIDTH: ::std::os::raw::c_uint = 0;
pub const ZONES_WIDTH: ::std::os::raw::c_uint = 2;
pub const NODES_WIDTH: ::std::os::raw::c_uint = 6;
pub const LAST__PID_SHIFT: ::std::os::raw::c_uint = 8;
pub const LAST__PID_MASK: ::std::os::raw::c_uint = 255;
pub const LAST__CPU_SHIFT: ::std::os::raw::c_uint = 8;
pub const LAST__CPU_MASK: ::std::os::raw::c_uint = 255;
pub const LAST_CPUPID_SHIFT: ::std::os::raw::c_uint = 16;
pub const LAST_CPUPID_WIDTH: ::std::os::raw::c_uint = 16;
pub const MAX_ORDER: ::std::os::raw::c_uint = 11;
pub const MAX_ORDER_NR_PAGES: ::std::os::raw::c_uint = 1024;
pub const PAGE_ALLOC_COSTLY_ORDER: ::std::os::raw::c_uint = 3;
pub const LRU_BASE: ::std::os::raw::c_uint = 0;
pub const LRU_ACTIVE: ::std::os::raw::c_uint = 1;
pub const LRU_FILE: ::std::os::raw::c_uint = 2;
pub const DEF_PRIORITY: ::std::os::raw::c_uint = 12;
pub const MAX_ZONES_PER_ZONELIST: ::std::os::raw::c_uint = 256;
pub const MAX_ZONELISTS: ::std::os::raw::c_uint = 2;
pub const ERESTARTSYS: ::std::os::raw::c_uint = 512;
pub const ERESTARTNOINTR: ::std::os::raw::c_uint = 513;
pub const ERESTARTNOHAND: ::std::os::raw::c_uint = 514;
pub const ENOIOCTLCMD: ::std::os::raw::c_uint = 515;
pub const ERESTART_RESTARTBLOCK: ::std::os::raw::c_uint = 516;
pub const EPROBE_DEFER: ::std::os::raw::c_uint = 517;
pub const EOPENSTALE: ::std::os::raw::c_uint = 518;
pub const EBADHANDLE: ::std::os::raw::c_uint = 521;
pub const ENOTSYNC: ::std::os::raw::c_uint = 522;
pub const EBADCOOKIE: ::std::os::raw::c_uint = 523;
pub const ENOTSUPP: ::std::os::raw::c_uint = 524;
pub const ETOOSMALL: ::std::os::raw::c_uint = 525;
pub const ESERVERFAULT: ::std::os::raw::c_uint = 526;
pub const EBADTYPE: ::std::os::raw::c_uint = 527;
pub const EJUKEBOX: ::std::os::raw::c_uint = 528;
pub const EIOCBQUEUED: ::std::os::raw::c_uint = 529;
pub const OSQ_UNLOCKED_VAL: ::std::os::raw::c_uint = 0;
pub const RWSEM_ACTIVE_MASK: ::std::os::raw::c_uint = 4294967295;
pub const RWSEM_UNLOCKED_VALUE: ::std::os::raw::c_uint = 0;
pub const RWSEM_ACTIVE_BIAS: ::std::os::raw::c_uint = 1;
pub const RWSEM_WAITING_BIAS: ::std::os::raw::c_longlong = -4294967296;
pub const RWSEM_ACTIVE_READ_BIAS: ::std::os::raw::c_uint = 1;
pub const RWSEM_ACTIVE_WRITE_BIAS: ::std::os::raw::c_longlong = -4294967295;
pub const ITIMER_REAL: ::std::os::raw::c_uint = 0;
pub const ITIMER_VIRTUAL: ::std::os::raw::c_uint = 1;
pub const ITIMER_PROF: ::std::os::raw::c_uint = 2;
pub const CLOCK_REALTIME: ::std::os::raw::c_uint = 0;
pub const CLOCK_MONOTONIC: ::std::os::raw::c_uint = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: ::std::os::raw::c_uint = 2;
pub const CLOCK_THREAD_CPUTIME_ID: ::std::os::raw::c_uint = 3;
pub const CLOCK_MONOTONIC_RAW: ::std::os::raw::c_uint = 4;
pub const CLOCK_REALTIME_COARSE: ::std::os::raw::c_uint = 5;
pub const CLOCK_MONOTONIC_COARSE: ::std::os::raw::c_uint = 6;
pub const CLOCK_BOOTTIME: ::std::os::raw::c_uint = 7;
pub const CLOCK_REALTIME_ALARM: ::std::os::raw::c_uint = 8;
pub const CLOCK_BOOTTIME_ALARM: ::std::os::raw::c_uint = 9;
pub const CLOCK_SGI_CYCLE: ::std::os::raw::c_uint = 10;
pub const CLOCK_TAI: ::std::os::raw::c_uint = 11;
pub const MAX_CLOCKS: ::std::os::raw::c_uint = 16;
pub const CLOCKS_MASK: ::std::os::raw::c_uint = 1;
pub const CLOCKS_MONO: ::std::os::raw::c_uint = 1;
pub const TIMER_ABSTIME: ::std::os::raw::c_uint = 1;
pub const MSEC_PER_SEC: ::std::os::raw::c_uint = 1000;
pub const USEC_PER_MSEC: ::std::os::raw::c_uint = 1000;
pub const NSEC_PER_USEC: ::std::os::raw::c_uint = 1000;
pub const NSEC_PER_MSEC: ::std::os::raw::c_uint = 1000000;
pub const USEC_PER_SEC: ::std::os::raw::c_uint = 1000000;
pub const NSEC_PER_SEC: ::std::os::raw::c_uint = 1000000000;
pub const FSEC_PER_SEC: ::std::os::raw::c_ulonglong = 1000000000000000;
pub const NTP_API: ::std::os::raw::c_uint = 4;
pub const ADJ_OFFSET: ::std::os::raw::c_uint = 1;
pub const ADJ_FREQUENCY: ::std::os::raw::c_uint = 2;
pub const ADJ_MAXERROR: ::std::os::raw::c_uint = 4;
pub const ADJ_ESTERROR: ::std::os::raw::c_uint = 8;
pub const ADJ_STATUS: ::std::os::raw::c_uint = 16;
pub const ADJ_TIMECONST: ::std::os::raw::c_uint = 32;
pub const ADJ_TAI: ::std::os::raw::c_uint = 128;
pub const ADJ_SETOFFSET: ::std::os::raw::c_uint = 256;
pub const ADJ_MICRO: ::std::os::raw::c_uint = 4096;
pub const ADJ_NANO: ::std::os::raw::c_uint = 8192;
pub const ADJ_TICK: ::std::os::raw::c_uint = 16384;
pub const MOD_OFFSET: ::std::os::raw::c_uint = 1;
pub const MOD_FREQUENCY: ::std::os::raw::c_uint = 2;
pub const MOD_MAXERROR: ::std::os::raw::c_uint = 4;
pub const MOD_ESTERROR: ::std::os::raw::c_uint = 8;
pub const MOD_STATUS: ::std::os::raw::c_uint = 16;
pub const MOD_TIMECONST: ::std::os::raw::c_uint = 32;
pub const MOD_TAI: ::std::os::raw::c_uint = 128;
pub const MOD_MICRO: ::std::os::raw::c_uint = 4096;
pub const MOD_NANO: ::std::os::raw::c_uint = 8192;
pub const STA_PLL: ::std::os::raw::c_uint = 1;
pub const STA_PPSFREQ: ::std::os::raw::c_uint = 2;
pub const STA_PPSTIME: ::std::os::raw::c_uint = 4;
pub const STA_FLL: ::std::os::raw::c_uint = 8;
pub const STA_INS: ::std::os::raw::c_uint = 16;
pub const STA_DEL: ::std::os::raw::c_uint = 32;
pub const STA_UNSYNC: ::std::os::raw::c_uint = 64;
pub const STA_FREQHOLD: ::std::os::raw::c_uint = 128;
pub const STA_PPSSIGNAL: ::std::os::raw::c_uint = 256;
pub const STA_PPSJITTER: ::std::os::raw::c_uint = 512;
pub const STA_PPSWANDER: ::std::os::raw::c_uint = 1024;
pub const STA_PPSERROR: ::std::os::raw::c_uint = 2048;
pub const STA_CLOCKERR: ::std::os::raw::c_uint = 4096;
pub const STA_NANO: ::std::os::raw::c_uint = 8192;
pub const STA_MODE: ::std::os::raw::c_uint = 16384;
pub const STA_CLK: ::std::os::raw::c_uint = 32768;
pub const STA_RONLY: ::std::os::raw::c_uint = 65280;
pub const TIME_OK: ::std::os::raw::c_uint = 0;
pub const TIME_INS: ::std::os::raw::c_uint = 1;
pub const TIME_DEL: ::std::os::raw::c_uint = 2;
pub const TIME_OOP: ::std::os::raw::c_uint = 3;
pub const TIME_WAIT: ::std::os::raw::c_uint = 4;
pub const TIME_ERROR: ::std::os::raw::c_uint = 5;
pub const TIME_BAD: ::std::os::raw::c_uint = 5;
pub const ADJ_ADJTIME: ::std::os::raw::c_uint = 32768;
pub const ADJ_OFFSET_SINGLESHOT: ::std::os::raw::c_uint = 1;
pub const ADJ_OFFSET_READONLY: ::std::os::raw::c_uint = 8192;
pub const HZ: ::std::os::raw::c_uint = 100;
pub const EXEC_PAGESIZE: ::std::os::raw::c_uint = 4096;
pub const NOGROUP: ::std::os::raw::c_int = -1;
pub const MAXHOSTNAMELEN: ::std::os::raw::c_uint = 64;
pub const USER_HZ: ::std::os::raw::c_uint = 100;
pub const CLOCKS_PER_SEC: ::std::os::raw::c_uint = 100;
pub const NS_SCALE: ::std::os::raw::c_uint = 10;
pub const US_SCALE: ::std::os::raw::c_uint = 32;
pub const SHIFT_PLL: ::std::os::raw::c_uint = 2;
pub const SHIFT_FLL: ::std::os::raw::c_uint = 2;
pub const MAXTC: ::std::os::raw::c_uint = 10;
pub const SHIFT_USEC: ::std::os::raw::c_uint = 16;
pub const PPM_SCALE_INV_SHIFT: ::std::os::raw::c_uint = 19;
pub const MAXPHASE: ::std::os::raw::c_uint = 500000000;
pub const MAXFREQ: ::std::os::raw::c_uint = 500000;
pub const MINSEC: ::std::os::raw::c_uint = 256;
pub const MAXSEC: ::std::os::raw::c_uint = 2048;
pub const NTP_PHASE_LIMIT: ::std::os::raw::c_uint = 16000000;
pub const NTP_SCALE_SHIFT: ::std::os::raw::c_uint = 32;
pub const NTP_INTERVAL_FREQ: ::std::os::raw::c_uint = 250;
pub const NTP_INTERVAL_LENGTH: ::std::os::raw::c_uint = 4000000;
pub const PIT_TICK_RATE: ::std::os::raw::c_uint = 1193182;
pub const HZ_TO_MSEC_SHR32: ::std::os::raw::c_uint = 29;
pub const MSEC_TO_HZ_SHR32: ::std::os::raw::c_uint = 33;
pub const HZ_TO_MSEC_NUM: ::std::os::raw::c_uint = 4;
pub const HZ_TO_MSEC_DEN: ::std::os::raw::c_uint = 1;
pub const MSEC_TO_HZ_NUM: ::std::os::raw::c_uint = 1;
pub const MSEC_TO_HZ_DEN: ::std::os::raw::c_uint = 4;
pub const HZ_TO_USEC_SHR32: ::std::os::raw::c_uint = 20;
pub const USEC_TO_HZ_SHR32: ::std::os::raw::c_uint = 43;
pub const HZ_TO_USEC_NUM: ::std::os::raw::c_uint = 4000;
pub const HZ_TO_USEC_DEN: ::std::os::raw::c_uint = 1;
pub const USEC_TO_HZ_NUM: ::std::os::raw::c_uint = 1;
pub const USEC_TO_HZ_DEN: ::std::os::raw::c_uint = 4000;
pub const SHIFT_HZ: ::std::os::raw::c_uint = 8;
pub const SEC_JIFFIE_SC: ::std::os::raw::c_uint = 23;
pub const NSEC_JIFFIE_SC: ::std::os::raw::c_uint = 53;
pub const TIMESTAMP_SIZE: ::std::os::raw::c_uint = 30;
pub const TIMER_CPUMASK: ::std::os::raw::c_uint = 524287;
pub const TIMER_MIGRATING: ::std::os::raw::c_uint = 524288;
pub const TIMER_BASEMASK: ::std::os::raw::c_uint = 1048575;
pub const TIMER_DEFERRABLE: ::std::os::raw::c_uint = 1048576;
pub const TIMER_IRQSAFE: ::std::os::raw::c_uint = 2097152;
pub const TIMER_NOT_PINNED: ::std::os::raw::c_uint = 0;
pub const TIMER_PINNED: ::std::os::raw::c_uint = 1;
pub const NEXT_TIMER_MAX_DELTA: ::std::os::raw::c_uint = 1073741823;
pub const CTL_MAXNAME: ::std::os::raw::c_uint = 10;
pub const NOTIFY_DONE: ::std::os::raw::c_uint = 0;
pub const NOTIFY_OK: ::std::os::raw::c_uint = 1;
pub const NOTIFY_STOP_MASK: ::std::os::raw::c_uint = 32768;
pub const NOTIFY_BAD: ::std::os::raw::c_uint = 32770;
pub const NOTIFY_STOP: ::std::os::raw::c_uint = 32769;
pub const NETLINK_URELEASE: ::std::os::raw::c_uint = 1;
pub const KBD_KEYCODE: ::std::os::raw::c_uint = 1;
pub const KBD_UNBOUND_KEYCODE: ::std::os::raw::c_uint = 2;
pub const KBD_UNICODE: ::std::os::raw::c_uint = 3;
pub const KBD_KEYSYM: ::std::os::raw::c_uint = 4;
pub const KBD_POST_KEYSYM: ::std::os::raw::c_uint = 5;
pub const NUMA_ZONELIST_ORDER_LEN: ::std::os::raw::c_uint = 16;
pub const MPC_SIGNATURE: &'static [u8; 5usize] = b"PCMP\x00";
pub const MP_PROCESSOR: ::std::os::raw::c_uint = 0;
pub const MP_BUS: ::std::os::raw::c_uint = 1;
pub const MP_IOAPIC: ::std::os::raw::c_uint = 2;
pub const MP_INTSRC: ::std::os::raw::c_uint = 3;
pub const MP_LINTSRC: ::std::os::raw::c_uint = 4;
pub const MP_TRANSLATION: ::std::os::raw::c_uint = 192;
pub const CPU_ENABLED: ::std::os::raw::c_uint = 1;
pub const CPU_BOOTPROCESSOR: ::std::os::raw::c_uint = 2;
pub const CPU_STEPPING_MASK: ::std::os::raw::c_uint = 15;
pub const CPU_MODEL_MASK: ::std::os::raw::c_uint = 240;
pub const CPU_FAMILY_MASK: ::std::os::raw::c_uint = 3840;
pub const BUSTYPE_EISA: &'static [u8; 5usize] = b"EISA\x00";
pub const BUSTYPE_ISA: &'static [u8; 4usize] = b"ISA\x00";
pub const BUSTYPE_INTERN: &'static [u8; 7usize] = b"INTERN\x00";
pub const BUSTYPE_MCA: &'static [u8; 4usize] = b"MCA\x00";
pub const BUSTYPE_VL: &'static [u8; 3usize] = b"VL\x00";
pub const BUSTYPE_PCI: &'static [u8; 4usize] = b"PCI\x00";
pub const BUSTYPE_PCMCIA: &'static [u8; 7usize] = b"PCMCIA\x00";
pub const BUSTYPE_CBUS: &'static [u8; 5usize] = b"CBUS\x00";
pub const BUSTYPE_CBUSII: &'static [u8; 7usize] = b"CBUSII\x00";
pub const BUSTYPE_FUTURE: &'static [u8; 7usize] = b"FUTURE\x00";
pub const BUSTYPE_MBI: &'static [u8; 4usize] = b"MBI\x00";
pub const BUSTYPE_MBII: &'static [u8; 5usize] = b"MBII\x00";
pub const BUSTYPE_MPI: &'static [u8; 4usize] = b"MPI\x00";
pub const BUSTYPE_MPSA: &'static [u8; 5usize] = b"MPSA\x00";
pub const BUSTYPE_NUBUS: &'static [u8; 6usize] = b"NUBUS\x00";
pub const BUSTYPE_TC: &'static [u8; 3usize] = b"TC\x00";
pub const BUSTYPE_VME: &'static [u8; 4usize] = b"VME\x00";
pub const BUSTYPE_XPRESS: &'static [u8; 7usize] = b"XPRESS\x00";
pub const MPC_APIC_USABLE: ::std::os::raw::c_uint = 1;
pub const MP_IRQDIR_DEFAULT: ::std::os::raw::c_uint = 0;
pub const MP_IRQDIR_HIGH: ::std::os::raw::c_uint = 1;
pub const MP_IRQDIR_LOW: ::std::os::raw::c_uint = 3;
pub const MP_APIC_ALL: ::std::os::raw::c_uint = 255;
pub const MPC_OEM_SIGNATURE: &'static [u8; 5usize] = b"_OEM\x00";
pub const SETUP_NONE: ::std::os::raw::c_uint = 0;
pub const SETUP_E820_EXT: ::std::os::raw::c_uint = 1;
pub const SETUP_DTB: ::std::os::raw::c_uint = 2;
pub const SETUP_PCI: ::std::os::raw::c_uint = 3;
pub const SETUP_EFI: ::std::os::raw::c_uint = 4;
pub const RAMDISK_IMAGE_START_MASK: ::std::os::raw::c_uint = 2047;
pub const RAMDISK_PROMPT_FLAG: ::std::os::raw::c_uint = 32768;
pub const RAMDISK_LOAD_FLAG: ::std::os::raw::c_uint = 16384;
pub const LOADED_HIGH: ::std::os::raw::c_uint = 1;
pub const KASLR_FLAG: ::std::os::raw::c_uint = 2;
pub const QUIET_FLAG: ::std::os::raw::c_uint = 32;
pub const KEEP_SEGMENTS: ::std::os::raw::c_uint = 64;
pub const CAN_USE_HEAP: ::std::os::raw::c_uint = 128;
pub const XLF_KERNEL_64: ::std::os::raw::c_uint = 1;
pub const XLF_CAN_BE_LOADED_ABOVE_4G: ::std::os::raw::c_uint = 2;
pub const XLF_EFI_HANDOVER_32: ::std::os::raw::c_uint = 4;
pub const XLF_EFI_HANDOVER_64: ::std::os::raw::c_uint = 8;
pub const XLF_EFI_KEXEC: ::std::os::raw::c_uint = 16;
pub const VIDEO_TYPE_MDA: ::std::os::raw::c_uint = 16;
pub const VIDEO_TYPE_CGA: ::std::os::raw::c_uint = 17;
pub const VIDEO_TYPE_EGAM: ::std::os::raw::c_uint = 32;
pub const VIDEO_TYPE_EGAC: ::std::os::raw::c_uint = 33;
pub const VIDEO_TYPE_VGAC: ::std::os::raw::c_uint = 34;
pub const VIDEO_TYPE_VLFB: ::std::os::raw::c_uint = 35;
pub const VIDEO_TYPE_PICA_S3: ::std::os::raw::c_uint = 48;
pub const VIDEO_TYPE_MIPS_G364: ::std::os::raw::c_uint = 49;
pub const VIDEO_TYPE_SGI: ::std::os::raw::c_uint = 51;
pub const VIDEO_TYPE_TGAC: ::std::os::raw::c_uint = 64;
pub const VIDEO_TYPE_SUN: ::std::os::raw::c_uint = 80;
pub const VIDEO_TYPE_SUNPCI: ::std::os::raw::c_uint = 81;
pub const VIDEO_TYPE_PMAC: ::std::os::raw::c_uint = 96;
pub const VIDEO_TYPE_EFI: ::std::os::raw::c_uint = 112;
pub const VIDEO_FLAGS_NOCURSOR: ::std::os::raw::c_uint = 1;
pub const VIDEO_CAPABILITY_SKIP_QUIRKS: ::std::os::raw::c_uint = 1;
pub const APM_STATE_READY: ::std::os::raw::c_uint = 0;
pub const APM_STATE_STANDBY: ::std::os::raw::c_uint = 1;
pub const APM_STATE_SUSPEND: ::std::os::raw::c_uint = 2;
pub const APM_STATE_OFF: ::std::os::raw::c_uint = 3;
pub const APM_STATE_BUSY: ::std::os::raw::c_uint = 4;
pub const APM_STATE_REJECT: ::std::os::raw::c_uint = 5;
pub const APM_STATE_OEM_SYS: ::std::os::raw::c_uint = 32;
pub const APM_STATE_OEM_DEV: ::std::os::raw::c_uint = 64;
pub const APM_STATE_DISABLE: ::std::os::raw::c_uint = 0;
pub const APM_STATE_ENABLE: ::std::os::raw::c_uint = 1;
pub const APM_STATE_DISENGAGE: ::std::os::raw::c_uint = 0;
pub const APM_STATE_ENGAGE: ::std::os::raw::c_uint = 1;
pub const APM_SYS_STANDBY: ::std::os::raw::c_uint = 1;
pub const APM_SYS_SUSPEND: ::std::os::raw::c_uint = 2;
pub const APM_NORMAL_RESUME: ::std::os::raw::c_uint = 3;
pub const APM_CRITICAL_RESUME: ::std::os::raw::c_uint = 4;
pub const APM_LOW_BATTERY: ::std::os::raw::c_uint = 5;
pub const APM_POWER_STATUS_CHANGE: ::std::os::raw::c_uint = 6;
pub const APM_UPDATE_TIME: ::std::os::raw::c_uint = 7;
pub const APM_CRITICAL_SUSPEND: ::std::os::raw::c_uint = 8;
pub const APM_USER_STANDBY: ::std::os::raw::c_uint = 9;
pub const APM_USER_SUSPEND: ::std::os::raw::c_uint = 10;
pub const APM_STANDBY_RESUME: ::std::os::raw::c_uint = 11;
pub const APM_CAPABILITY_CHANGE: ::std::os::raw::c_uint = 12;
pub const APM_USER_HIBERNATION: ::std::os::raw::c_uint = 13;
pub const APM_HIBERNATION_RESUME: ::std::os::raw::c_uint = 14;
pub const APM_SUCCESS: ::std::os::raw::c_uint = 0;
pub const APM_DISABLED: ::std::os::raw::c_uint = 1;
pub const APM_CONNECTED: ::std::os::raw::c_uint = 2;
pub const APM_NOT_CONNECTED: ::std::os::raw::c_uint = 3;
pub const APM_16_CONNECTED: ::std::os::raw::c_uint = 5;
pub const APM_16_UNSUPPORTED: ::std::os::raw::c_uint = 6;
pub const APM_32_CONNECTED: ::std::os::raw::c_uint = 7;
pub const APM_32_UNSUPPORTED: ::std::os::raw::c_uint = 8;
pub const APM_BAD_DEVICE: ::std::os::raw::c_uint = 9;
pub const APM_BAD_PARAM: ::std::os::raw::c_uint = 10;
pub const APM_NOT_ENGAGED: ::std::os::raw::c_uint = 11;
pub const APM_BAD_FUNCTION: ::std::os::raw::c_uint = 12;
pub const APM_RESUME_DISABLED: ::std::os::raw::c_uint = 13;
pub const APM_NO_ERROR: ::std::os::raw::c_uint = 83;
pub const APM_BAD_STATE: ::std::os::raw::c_uint = 96;
pub const APM_NO_EVENTS: ::std::os::raw::c_uint = 128;
pub const APM_NOT_PRESENT: ::std::os::raw::c_uint = 134;
pub const APM_DEVICE_BIOS: ::std::os::raw::c_uint = 0;
pub const APM_DEVICE_ALL: ::std::os::raw::c_uint = 1;
pub const APM_DEVICE_DISPLAY: ::std::os::raw::c_uint = 256;
pub const APM_DEVICE_STORAGE: ::std::os::raw::c_uint = 512;
pub const APM_DEVICE_PARALLEL: ::std::os::raw::c_uint = 768;
pub const APM_DEVICE_SERIAL: ::std::os::raw::c_uint = 1024;
pub const APM_DEVICE_NETWORK: ::std::os::raw::c_uint = 1280;
pub const APM_DEVICE_PCMCIA: ::std::os::raw::c_uint = 1536;
pub const APM_DEVICE_BATTERY: ::std::os::raw::c_uint = 32768;
pub const APM_DEVICE_OEM: ::std::os::raw::c_uint = 57344;
pub const APM_DEVICE_OLD_ALL: ::std::os::raw::c_uint = 65535;
pub const APM_DEVICE_CLASS: ::std::os::raw::c_uint = 255;
pub const APM_DEVICE_MASK: ::std::os::raw::c_uint = 65280;
pub const APM_MAX_BATTERIES: ::std::os::raw::c_uint = 2;
pub const APM_CAP_GLOBAL_STANDBY: ::std::os::raw::c_uint = 1;
pub const APM_CAP_GLOBAL_SUSPEND: ::std::os::raw::c_uint = 2;
pub const APM_CAP_RESUME_STANDBY_TIMER: ::std::os::raw::c_uint = 4;
pub const APM_CAP_RESUME_SUSPEND_TIMER: ::std::os::raw::c_uint = 8;
pub const APM_CAP_RESUME_STANDBY_RING: ::std::os::raw::c_uint = 16;
pub const APM_CAP_RESUME_SUSPEND_RING: ::std::os::raw::c_uint = 32;
pub const APM_CAP_RESUME_STANDBY_PCMCIA: ::std::os::raw::c_uint = 64;
pub const APM_CAP_RESUME_SUSPEND_PCMCIA: ::std::os::raw::c_uint = 128;
pub const APM_16_BIT_SUPPORT: ::std::os::raw::c_uint = 1;
pub const APM_32_BIT_SUPPORT: ::std::os::raw::c_uint = 2;
pub const APM_IDLE_SLOWS_CLOCK: ::std::os::raw::c_uint = 4;
pub const APM_BIOS_DISABLED: ::std::os::raw::c_uint = 8;
pub const APM_BIOS_DISENGAGED: ::std::os::raw::c_uint = 16;
pub const APM_FUNC_INST_CHECK: ::std::os::raw::c_uint = 21248;
pub const APM_FUNC_REAL_CONN: ::std::os::raw::c_uint = 21249;
pub const APM_FUNC_16BIT_CONN: ::std::os::raw::c_uint = 21250;
pub const APM_FUNC_32BIT_CONN: ::std::os::raw::c_uint = 21251;
pub const APM_FUNC_DISCONN: ::std::os::raw::c_uint = 21252;
pub const APM_FUNC_IDLE: ::std::os::raw::c_uint = 21253;
pub const APM_FUNC_BUSY: ::std::os::raw::c_uint = 21254;
pub const APM_FUNC_SET_STATE: ::std::os::raw::c_uint = 21255;
pub const APM_FUNC_ENABLE_PM: ::std::os::raw::c_uint = 21256;
pub const APM_FUNC_RESTORE_BIOS: ::std::os::raw::c_uint = 21257;
pub const APM_FUNC_GET_STATUS: ::std::os::raw::c_uint = 21258;
pub const APM_FUNC_GET_EVENT: ::std::os::raw::c_uint = 21259;
pub const APM_FUNC_GET_STATE: ::std::os::raw::c_uint = 21260;
pub const APM_FUNC_ENABLE_DEV_PM: ::std::os::raw::c_uint = 21261;
pub const APM_FUNC_VERSION: ::std::os::raw::c_uint = 21262;
pub const APM_FUNC_ENGAGE_PM: ::std::os::raw::c_uint = 21263;
pub const APM_FUNC_GET_CAP: ::std::os::raw::c_uint = 21264;
pub const APM_FUNC_RESUME_TIMER: ::std::os::raw::c_uint = 21265;
pub const APM_FUNC_RESUME_ON_RING: ::std::os::raw::c_uint = 21266;
pub const APM_FUNC_TIMER: ::std::os::raw::c_uint = 21267;
pub const APM_FUNC_DISABLE_TIMER: ::std::os::raw::c_uint = 0;
pub const APM_FUNC_GET_TIMER: ::std::os::raw::c_uint = 1;
pub const APM_FUNC_SET_TIMER: ::std::os::raw::c_uint = 2;
pub const APM_FUNC_DISABLE_RING: ::std::os::raw::c_uint = 0;
pub const APM_FUNC_ENABLE_RING: ::std::os::raw::c_uint = 1;
pub const APM_FUNC_GET_RING: ::std::os::raw::c_uint = 2;
pub const APM_FUNC_TIMER_DISABLE: ::std::os::raw::c_uint = 0;
pub const APM_FUNC_TIMER_ENABLE: ::std::os::raw::c_uint = 1;
pub const APM_FUNC_TIMER_GET: ::std::os::raw::c_uint = 2;
pub const EDDNR: ::std::os::raw::c_uint = 489;
pub const EDDBUF: ::std::os::raw::c_uint = 3328;
pub const EDDMAXNR: ::std::os::raw::c_uint = 6;
pub const EDDEXTSIZE: ::std::os::raw::c_uint = 8;
pub const EDDPARMSIZE: ::std::os::raw::c_uint = 74;
pub const CHECKEXTENSIONSPRESENT: ::std::os::raw::c_uint = 65;
pub const GETDEVICEPARAMETERS: ::std::os::raw::c_uint = 72;
pub const LEGACYGETDEVICEPARAMETERS: ::std::os::raw::c_uint = 8;
pub const EDDMAGIC1: ::std::os::raw::c_uint = 21930;
pub const EDDMAGIC2: ::std::os::raw::c_uint = 43605;
pub const READ_SECTORS: ::std::os::raw::c_uint = 2;
pub const EDD_MBR_SIG_OFFSET: ::std::os::raw::c_uint = 440;
pub const EDD_MBR_SIG_BUF: ::std::os::raw::c_uint = 656;
pub const EDD_MBR_SIG_MAX: ::std::os::raw::c_uint = 16;
pub const EDD_MBR_SIG_NR_BUF: ::std::os::raw::c_uint = 490;
pub const EDD_EXT_FIXED_DISK_ACCESS: ::std::os::raw::c_uint = 1;
pub const EDD_EXT_DEVICE_LOCKING_AND_EJECTING: ::std::os::raw::c_uint = 2;
pub const EDD_EXT_ENHANCED_DISK_DRIVE_SUPPORT: ::std::os::raw::c_uint = 4;
pub const EDD_EXT_64BIT_EXTENSIONS: ::std::os::raw::c_uint = 8;
pub const EDD_INFO_DMA_BOUNDARY_ERROR_TRANSPARENT: ::std::os::raw::c_uint = 1;
pub const EDD_INFO_GEOMETRY_VALID: ::std::os::raw::c_uint = 2;
pub const EDD_INFO_REMOVABLE: ::std::os::raw::c_uint = 4;
pub const EDD_INFO_WRITE_VERIFY: ::std::os::raw::c_uint = 8;
pub const EDD_INFO_MEDIA_CHANGE_NOTIFICATION: ::std::os::raw::c_uint = 16;
pub const EDD_INFO_LOCKABLE: ::std::os::raw::c_uint = 32;
pub const EDD_INFO_NO_MEDIA_PRESENT: ::std::os::raw::c_uint = 64;
pub const EDD_INFO_USE_INT13_FN50: ::std::os::raw::c_uint = 128;
pub const E820MAP: ::std::os::raw::c_uint = 720;
pub const E820MAX: ::std::os::raw::c_uint = 128;
pub const E820NR: ::std::os::raw::c_uint = 488;
pub const E820_RAM: ::std::os::raw::c_uint = 1;
pub const E820_RESERVED: ::std::os::raw::c_uint = 2;
pub const E820_ACPI: ::std::os::raw::c_uint = 3;
pub const E820_NVS: ::std::os::raw::c_uint = 4;
pub const E820_UNUSABLE: ::std::os::raw::c_uint = 5;
pub const E820_PMEM: ::std::os::raw::c_uint = 7;
pub const E820_PRAM: ::std::os::raw::c_uint = 12;
pub const E820_RESERVED_KERN: ::std::os::raw::c_uint = 128;
pub const ISA_START_ADDRESS: ::std::os::raw::c_uint = 655360;
pub const ISA_END_ADDRESS: ::std::os::raw::c_uint = 1048576;
pub const BIOS_BEGIN: ::std::os::raw::c_uint = 655360;
pub const BIOS_END: ::std::os::raw::c_uint = 1048576;
pub const BIOS_ROM_BASE: ::std::os::raw::c_uint = 4292870144;
pub const BIOS_ROM_END: ::std::os::raw::c_uint = 4294967295;
pub const IORESOURCE_BITS: ::std::os::raw::c_uint = 255;
pub const IORESOURCE_TYPE_BITS: ::std::os::raw::c_uint = 7936;
pub const IORESOURCE_IO: ::std::os::raw::c_uint = 256;
pub const IORESOURCE_MEM: ::std::os::raw::c_uint = 512;
pub const IORESOURCE_REG: ::std::os::raw::c_uint = 768;
pub const IORESOURCE_IRQ: ::std::os::raw::c_uint = 1024;
pub const IORESOURCE_DMA: ::std::os::raw::c_uint = 2048;
pub const IORESOURCE_BUS: ::std::os::raw::c_uint = 4096;
pub const IORESOURCE_PREFETCH: ::std::os::raw::c_uint = 8192;
pub const IORESOURCE_READONLY: ::std::os::raw::c_uint = 16384;
pub const IORESOURCE_CACHEABLE: ::std::os::raw::c_uint = 32768;
pub const IORESOURCE_RANGELENGTH: ::std::os::raw::c_uint = 65536;
pub const IORESOURCE_SHADOWABLE: ::std::os::raw::c_uint = 131072;
pub const IORESOURCE_SIZEALIGN: ::std::os::raw::c_uint = 262144;
pub const IORESOURCE_STARTALIGN: ::std::os::raw::c_uint = 524288;
pub const IORESOURCE_MEM_64: ::std::os::raw::c_uint = 1048576;
pub const IORESOURCE_WINDOW: ::std::os::raw::c_uint = 2097152;
pub const IORESOURCE_MUXED: ::std::os::raw::c_uint = 4194304;
pub const IORESOURCE_EXCLUSIVE: ::std::os::raw::c_uint = 134217728;
pub const IORESOURCE_DISABLED: ::std::os::raw::c_uint = 268435456;
pub const IORESOURCE_UNSET: ::std::os::raw::c_uint = 536870912;
pub const IORESOURCE_AUTO: ::std::os::raw::c_uint = 1073741824;
pub const IORESOURCE_BUSY: ::std::os::raw::c_uint = 2147483648;
pub const IORESOURCE_IRQ_HIGHEDGE: ::std::os::raw::c_uint = 1;
pub const IORESOURCE_IRQ_LOWEDGE: ::std::os::raw::c_uint = 2;
pub const IORESOURCE_IRQ_HIGHLEVEL: ::std::os::raw::c_uint = 4;
pub const IORESOURCE_IRQ_LOWLEVEL: ::std::os::raw::c_uint = 8;
pub const IORESOURCE_IRQ_SHAREABLE: ::std::os::raw::c_uint = 16;
pub const IORESOURCE_IRQ_OPTIONAL: ::std::os::raw::c_uint = 32;
pub const IORESOURCE_DMA_TYPE_MASK: ::std::os::raw::c_uint = 3;
pub const IORESOURCE_DMA_8BIT: ::std::os::raw::c_uint = 0;
pub const IORESOURCE_DMA_8AND16BIT: ::std::os::raw::c_uint = 1;
pub const IORESOURCE_DMA_16BIT: ::std::os::raw::c_uint = 2;
pub const IORESOURCE_DMA_MASTER: ::std::os::raw::c_uint = 4;
pub const IORESOURCE_DMA_BYTE: ::std::os::raw::c_uint = 8;
pub const IORESOURCE_DMA_WORD: ::std::os::raw::c_uint = 16;
pub const IORESOURCE_DMA_SPEED_MASK: ::std::os::raw::c_uint = 192;
pub const IORESOURCE_DMA_COMPATIBLE: ::std::os::raw::c_uint = 0;
pub const IORESOURCE_DMA_TYPEA: ::std::os::raw::c_uint = 64;
pub const IORESOURCE_DMA_TYPEB: ::std::os::raw::c_uint = 128;
pub const IORESOURCE_DMA_TYPEF: ::std::os::raw::c_uint = 192;
pub const IORESOURCE_MEM_WRITEABLE: ::std::os::raw::c_uint = 1;
pub const IORESOURCE_MEM_CACHEABLE: ::std::os::raw::c_uint = 2;
pub const IORESOURCE_MEM_RANGELENGTH: ::std::os::raw::c_uint = 4;
pub const IORESOURCE_MEM_TYPE_MASK: ::std::os::raw::c_uint = 24;
pub const IORESOURCE_MEM_8BIT: ::std::os::raw::c_uint = 0;
pub const IORESOURCE_MEM_16BIT: ::std::os::raw::c_uint = 8;
pub const IORESOURCE_MEM_8AND16BIT: ::std::os::raw::c_uint = 16;
pub const IORESOURCE_MEM_32BIT: ::std::os::raw::c_uint = 24;
pub const IORESOURCE_MEM_SHADOWABLE: ::std::os::raw::c_uint = 32;
pub const IORESOURCE_MEM_EXPANSIONROM: ::std::os::raw::c_uint = 64;
pub const IORESOURCE_IO_16BIT_ADDR: ::std::os::raw::c_uint = 1;
pub const IORESOURCE_IO_FIXED: ::std::os::raw::c_uint = 2;
pub const IORESOURCE_ROM_ENABLE: ::std::os::raw::c_uint = 1;
pub const IORESOURCE_ROM_SHADOW: ::std::os::raw::c_uint = 2;
pub const IORESOURCE_ROM_COPY: ::std::os::raw::c_uint = 4;
pub const IORESOURCE_ROM_BIOS_COPY: ::std::os::raw::c_uint = 8;
pub const IORESOURCE_PCI_FIXED: ::std::os::raw::c_uint = 16;
pub const HIGH_MEMORY: ::std::os::raw::c_uint = 1048576;
pub const IO_APIC_DEFAULT_PHYS_BASE: ::std::os::raw::c_uint = 4273995776;
pub const APIC_DEFAULT_PHYS_BASE: ::std::os::raw::c_uint = 4276092928;
pub const IO_APIC_SLOT_SIZE: ::std::os::raw::c_uint = 1024;
pub const APIC_ID: ::std::os::raw::c_uint = 32;
pub const APIC_LVR: ::std::os::raw::c_uint = 48;
pub const APIC_LVR_MASK: ::std::os::raw::c_uint = 16711935;
pub const APIC_LVR_DIRECTED_EOI: ::std::os::raw::c_uint = 16777216;
pub const APIC_TASKPRI: ::std::os::raw::c_uint = 128;
pub const APIC_TPRI_MASK: ::std::os::raw::c_uint = 255;
pub const APIC_ARBPRI: ::std::os::raw::c_uint = 144;
pub const APIC_ARBPRI_MASK: ::std::os::raw::c_uint = 255;
pub const APIC_PROCPRI: ::std::os::raw::c_uint = 160;
pub const APIC_EOI: ::std::os::raw::c_uint = 176;
pub const APIC_EOI_ACK: ::std::os::raw::c_uint = 0;
pub const APIC_RRR: ::std::os::raw::c_uint = 192;
pub const APIC_LDR: ::std::os::raw::c_uint = 208;
pub const APIC_LDR_MASK: ::std::os::raw::c_uint = 4278190080;
pub const APIC_ALL_CPUS: ::std::os::raw::c_uint = 255;
pub const APIC_DFR: ::std::os::raw::c_uint = 224;
pub const APIC_DFR_CLUSTER: ::std::os::raw::c_uint = 268435455;
pub const APIC_DFR_FLAT: ::std::os::raw::c_uint = 4294967295;
pub const APIC_SPIV: ::std::os::raw::c_uint = 240;
pub const APIC_SPIV_DIRECTED_EOI: ::std::os::raw::c_uint = 4096;
pub const APIC_SPIV_FOCUS_DISABLED: ::std::os::raw::c_uint = 512;
pub const APIC_SPIV_APIC_ENABLED: ::std::os::raw::c_uint = 256;
pub const APIC_ISR: ::std::os::raw::c_uint = 256;
pub const APIC_ISR_NR: ::std::os::raw::c_uint = 8;
pub const APIC_TMR: ::std::os::raw::c_uint = 384;
pub const APIC_IRR: ::std::os::raw::c_uint = 512;
pub const APIC_ESR: ::std::os::raw::c_uint = 640;
pub const APIC_ESR_SEND_CS: ::std::os::raw::c_uint = 1;
pub const APIC_ESR_RECV_CS: ::std::os::raw::c_uint = 2;
pub const APIC_ESR_SEND_ACC: ::std::os::raw::c_uint = 4;
pub const APIC_ESR_RECV_ACC: ::std::os::raw::c_uint = 8;
pub const APIC_ESR_SENDILL: ::std::os::raw::c_uint = 32;
pub const APIC_ESR_RECVILL: ::std::os::raw::c_uint = 64;
pub const APIC_ESR_ILLREGA: ::std::os::raw::c_uint = 128;
pub const APIC_LVTCMCI: ::std::os::raw::c_uint = 752;
pub const APIC_ICR: ::std::os::raw::c_uint = 768;
pub const APIC_DEST_SELF: ::std::os::raw::c_uint = 262144;
pub const APIC_DEST_ALLINC: ::std::os::raw::c_uint = 524288;
pub const APIC_DEST_ALLBUT: ::std::os::raw::c_uint = 786432;
pub const APIC_ICR_RR_MASK: ::std::os::raw::c_uint = 196608;
pub const APIC_ICR_RR_INVALID: ::std::os::raw::c_uint = 0;
pub const APIC_ICR_RR_INPROG: ::std::os::raw::c_uint = 65536;
pub const APIC_ICR_RR_VALID: ::std::os::raw::c_uint = 131072;
pub const APIC_INT_LEVELTRIG: ::std::os::raw::c_uint = 32768;
pub const APIC_INT_ASSERT: ::std::os::raw::c_uint = 16384;
pub const APIC_ICR_BUSY: ::std::os::raw::c_uint = 4096;
pub const APIC_DEST_LOGICAL: ::std::os::raw::c_uint = 2048;
pub const APIC_DEST_PHYSICAL: ::std::os::raw::c_uint = 0;
pub const APIC_DM_FIXED: ::std::os::raw::c_uint = 0;
pub const APIC_DM_FIXED_MASK: ::std::os::raw::c_uint = 1792;
pub const APIC_DM_LOWEST: ::std::os::raw::c_uint = 256;
pub const APIC_DM_SMI: ::std::os::raw::c_uint = 512;
pub const APIC_DM_REMRD: ::std::os::raw::c_uint = 768;
pub const APIC_DM_NMI: ::std::os::raw::c_uint = 1024;
pub const APIC_DM_INIT: ::std::os::raw::c_uint = 1280;
pub const APIC_DM_STARTUP: ::std::os::raw::c_uint = 1536;
pub const APIC_DM_EXTINT: ::std::os::raw::c_uint = 1792;
pub const APIC_VECTOR_MASK: ::std::os::raw::c_uint = 255;
pub const APIC_ICR2: ::std::os::raw::c_uint = 784;
pub const APIC_LVTT: ::std::os::raw::c_uint = 800;
pub const APIC_LVTTHMR: ::std::os::raw::c_uint = 816;
pub const APIC_LVTPC: ::std::os::raw::c_uint = 832;
pub const APIC_LVT0: ::std::os::raw::c_uint = 848;
pub const APIC_LVT_TIMER_BASE_MASK: ::std::os::raw::c_uint = 786432;
pub const APIC_TIMER_BASE_CLKIN: ::std::os::raw::c_uint = 0;
pub const APIC_TIMER_BASE_TMBASE: ::std::os::raw::c_uint = 1;
pub const APIC_TIMER_BASE_DIV: ::std::os::raw::c_uint = 2;
pub const APIC_LVT_TIMER_ONESHOT: ::std::os::raw::c_uint = 0;
pub const APIC_LVT_TIMER_PERIODIC: ::std::os::raw::c_uint = 131072;
pub const APIC_LVT_TIMER_TSCDEADLINE: ::std::os::raw::c_uint = 262144;
pub const APIC_LVT_MASKED: ::std::os::raw::c_uint = 65536;
pub const APIC_LVT_LEVEL_TRIGGER: ::std::os::raw::c_uint = 32768;
pub const APIC_LVT_REMOTE_IRR: ::std::os::raw::c_uint = 16384;
pub const APIC_INPUT_POLARITY: ::std::os::raw::c_uint = 8192;
pub const APIC_SEND_PENDING: ::std::os::raw::c_uint = 4096;
pub const APIC_MODE_MASK: ::std::os::raw::c_uint = 1792;
pub const APIC_MODE_FIXED: ::std::os::raw::c_uint = 0;
pub const APIC_MODE_NMI: ::std::os::raw::c_uint = 4;
pub const APIC_MODE_EXTINT: ::std::os::raw::c_uint = 7;
pub const APIC_LVT1: ::std::os::raw::c_uint = 864;
pub const APIC_LVTERR: ::std::os::raw::c_uint = 880;
pub const APIC_TMICT: ::std::os::raw::c_uint = 896;
pub const APIC_TMCCT: ::std::os::raw::c_uint = 912;
pub const APIC_TDCR: ::std::os::raw::c_uint = 992;
pub const APIC_SELF_IPI: ::std::os::raw::c_uint = 1008;
pub const APIC_TDR_DIV_TMBASE: ::std::os::raw::c_uint = 4;
pub const APIC_TDR_DIV_1: ::std::os::raw::c_uint = 11;
pub const APIC_TDR_DIV_2: ::std::os::raw::c_uint = 0;
pub const APIC_TDR_DIV_4: ::std::os::raw::c_uint = 1;
pub const APIC_TDR_DIV_8: ::std::os::raw::c_uint = 2;
pub const APIC_TDR_DIV_16: ::std::os::raw::c_uint = 3;
pub const APIC_TDR_DIV_32: ::std::os::raw::c_uint = 8;
pub const APIC_TDR_DIV_64: ::std::os::raw::c_uint = 9;
pub const APIC_TDR_DIV_128: ::std::os::raw::c_uint = 10;
pub const APIC_EFEAT: ::std::os::raw::c_uint = 1024;
pub const APIC_ECTRL: ::std::os::raw::c_uint = 1040;
pub const APIC_EILVT_NR_AMD_K8: ::std::os::raw::c_uint = 1;
pub const APIC_EILVT_NR_AMD_10H: ::std::os::raw::c_uint = 4;
pub const APIC_EILVT_NR_MAX: ::std::os::raw::c_uint = 4;
pub const APIC_EILVT_MSG_FIX: ::std::os::raw::c_uint = 0;
pub const APIC_EILVT_MSG_SMI: ::std::os::raw::c_uint = 2;
pub const APIC_EILVT_MSG_NMI: ::std::os::raw::c_uint = 4;
pub const APIC_EILVT_MSG_EXT: ::std::os::raw::c_uint = 7;
pub const APIC_EILVT_MASKED: ::std::os::raw::c_uint = 65536;
pub const APIC_BASE_MSR: ::std::os::raw::c_uint = 2048;
pub const XAPIC_ENABLE: ::std::os::raw::c_uint = 2048;
pub const X2APIC_ENABLE: ::std::os::raw::c_uint = 1024;
pub const MAX_IO_APICS: ::std::os::raw::c_uint = 128;
pub const MAX_LOCAL_APIC: ::std::os::raw::c_uint = 32768;
pub const XAPIC_DEST_CPUS_SHIFT: ::std::os::raw::c_uint = 4;
pub const XAPIC_DEST_CPUS_MASK: ::std::os::raw::c_uint = 15;
pub const XAPIC_DEST_CLUSTER_MASK: ::std::os::raw::c_uint = 240;
pub const BAD_APICID: ::std::os::raw::c_uint = 65535;
pub const MAX_MP_BUSSES: ::std::os::raw::c_uint = 256;
pub const MAX_IRQ_SOURCES: ::std::os::raw::c_uint = 1024;
pub const PM_EVENT_INVALID: ::std::os::raw::c_int = -1;
pub const PM_EVENT_ON: ::std::os::raw::c_uint = 0;
pub const PM_EVENT_FREEZE: ::std::os::raw::c_uint = 1;
pub const PM_EVENT_SUSPEND: ::std::os::raw::c_uint = 2;
pub const PM_EVENT_HIBERNATE: ::std::os::raw::c_uint = 4;
pub const PM_EVENT_QUIESCE: ::std::os::raw::c_uint = 8;
pub const PM_EVENT_RESUME: ::std::os::raw::c_uint = 16;
pub const PM_EVENT_THAW: ::std::os::raw::c_uint = 32;
pub const PM_EVENT_RESTORE: ::std::os::raw::c_uint = 64;
pub const PM_EVENT_RECOVER: ::std::os::raw::c_uint = 128;
pub const PM_EVENT_USER: ::std::os::raw::c_uint = 256;
pub const PM_EVENT_REMOTE: ::std::os::raw::c_uint = 512;
pub const PM_EVENT_AUTO: ::std::os::raw::c_uint = 1024;
pub const PM_EVENT_SLEEP: ::std::os::raw::c_uint = 6;
pub const PM_EVENT_USER_SUSPEND: ::std::os::raw::c_uint = 258;
pub const PM_EVENT_USER_RESUME: ::std::os::raw::c_uint = 272;
pub const PM_EVENT_REMOTE_RESUME: ::std::os::raw::c_uint = 528;
pub const PM_EVENT_AUTO_SUSPEND: ::std::os::raw::c_uint = 1026;
pub const PM_EVENT_AUTO_RESUME: ::std::os::raw::c_uint = 1040;
pub const PM_EVENT_PRETHAW: ::std::os::raw::c_uint = 8;
pub const ACPI_PDC_P_FFH: ::std::os::raw::c_uint = 1;
pub const ACPI_PDC_C_C1_HALT: ::std::os::raw::c_uint = 2;
pub const ACPI_PDC_T_FFH: ::std::os::raw::c_uint = 4;
pub const ACPI_PDC_SMP_C1PT: ::std::os::raw::c_uint = 8;
pub const ACPI_PDC_SMP_C2C3: ::std::os::raw::c_uint = 16;
pub const ACPI_PDC_SMP_P_SWCOORD: ::std::os::raw::c_uint = 32;
pub const ACPI_PDC_SMP_C_SWCOORD: ::std::os::raw::c_uint = 64;
pub const ACPI_PDC_SMP_T_SWCOORD: ::std::os::raw::c_uint = 128;
pub const ACPI_PDC_C_C1_FFH: ::std::os::raw::c_uint = 256;
pub const ACPI_PDC_C_C2C3_FFH: ::std::os::raw::c_uint = 512;
pub const ACPI_PDC_SMP_P_HWCOORD: ::std::os::raw::c_uint = 2048;
pub const ACPI_PDC_EST_CAPABILITY_SMP: ::std::os::raw::c_uint = 11;
pub const ACPI_PDC_EST_CAPABILITY_SWSMP: ::std::os::raw::c_uint = 2091;
pub const ACPI_PDC_C_CAPABILITY_SMP: ::std::os::raw::c_uint = 794;
pub const NR_NODE_MEMBLKS: ::std::os::raw::c_uint = 128;
pub const NODE_MIN_SIZE: ::std::os::raw::c_uint = 4194304;
pub const PRI_xen_pfn: &'static [u8; 3usize] = b"lx\x00";
pub const PRI_xen_ulong: &'static [u8; 3usize] = b"lx\x00";
pub const PRI_xen_long: &'static [u8; 3usize] = b"lx\x00";
pub const MAX_VIRT_CPUS: ::std::os::raw::c_uint = 32;
pub const FIRST_RESERVED_GDT_PAGE: ::std::os::raw::c_uint = 14;
pub const FIRST_RESERVED_GDT_BYTE: ::std::os::raw::c_uint = 57344;
pub const FIRST_RESERVED_GDT_ENTRY: ::std::os::raw::c_uint = 7168;
pub const FLAT_RING3_CS32: ::std::os::raw::c_uint = 57379;
pub const FLAT_RING3_CS64: ::std::os::raw::c_uint = 57395;
pub const FLAT_RING3_DS32: ::std::os::raw::c_uint = 57387;
pub const FLAT_RING3_DS64: ::std::os::raw::c_uint = 0;
pub const FLAT_RING3_SS32: ::std::os::raw::c_uint = 57387;
pub const FLAT_RING3_SS64: ::std::os::raw::c_uint = 57387;
pub const FLAT_KERNEL_DS64: ::std::os::raw::c_uint = 0;
pub const FLAT_KERNEL_DS32: ::std::os::raw::c_uint = 57387;
pub const FLAT_KERNEL_DS: ::std::os::raw::c_uint = 0;
pub const FLAT_KERNEL_CS64: ::std::os::raw::c_uint = 57395;
pub const FLAT_KERNEL_CS32: ::std::os::raw::c_uint = 57379;
pub const FLAT_KERNEL_CS: ::std::os::raw::c_uint = 57395;
pub const FLAT_KERNEL_SS64: ::std::os::raw::c_uint = 57387;
pub const FLAT_KERNEL_SS32: ::std::os::raw::c_uint = 57387;
pub const FLAT_KERNEL_SS: ::std::os::raw::c_uint = 57387;
pub const FLAT_USER_DS64: ::std::os::raw::c_uint = 0;
pub const FLAT_USER_DS32: ::std::os::raw::c_uint = 57387;
pub const FLAT_USER_DS: ::std::os::raw::c_uint = 0;
pub const FLAT_USER_CS64: ::std::os::raw::c_uint = 57395;
pub const FLAT_USER_CS32: ::std::os::raw::c_uint = 57379;
pub const FLAT_USER_CS: ::std::os::raw::c_uint = 57395;
pub const FLAT_USER_SS64: ::std::os::raw::c_uint = 57387;
pub const FLAT_USER_SS32: ::std::os::raw::c_uint = 57387;
pub const FLAT_USER_SS: ::std::os::raw::c_uint = 57387;
pub const __HYPERVISOR_VIRT_START: ::std::os::raw::c_longlong =
    -140737488355328;
pub const __HYPERVISOR_VIRT_END: ::std::os::raw::c_longlong =
    -131941395333120;
pub const __MACH2PHYS_VIRT_START: ::std::os::raw::c_longlong =
    -140737488355328;
pub const __MACH2PHYS_VIRT_END: ::std::os::raw::c_longlong = -140462610448384;
pub const __MACH2PHYS_SHIFT: ::std::os::raw::c_uint = 3;
pub const SEGBASE_FS: ::std::os::raw::c_uint = 0;
pub const SEGBASE_GS_USER: ::std::os::raw::c_uint = 1;
pub const SEGBASE_GS_KERNEL: ::std::os::raw::c_uint = 2;
pub const SEGBASE_GS_USER_SEL: ::std::os::raw::c_uint = 3;
pub const _VGCF_in_syscall: ::std::os::raw::c_uint = 8;
pub const VGCF_in_syscall: ::std::os::raw::c_uint = 256;
pub const VGCF_IN_SYSCALL: ::std::os::raw::c_uint = 256;
pub const PVCLOCK_TSC_STABLE_BIT: ::std::os::raw::c_uint = 1;
pub const PVCLOCK_GUEST_STOPPED: ::std::os::raw::c_uint = 2;
pub const PVCLOCK_COUNTS_FROM_ZERO: ::std::os::raw::c_uint = 4;
pub const VGCF_I387_VALID: ::std::os::raw::c_uint = 1;
pub const VGCF_HVM_GUEST: ::std::os::raw::c_uint = 2;
pub const VGCF_IN_KERNEL: ::std::os::raw::c_uint = 4;
pub const XEN_EMULATE_PREFIX: &'static [u8; 34usize] =
    b".byte 0x0f,0x0b,0x78,0x65,0x6e ; \x00";
pub const XEN_CPUID: &'static [u8; 39usize] =
    b".byte 0x0f,0x0b,0x78,0x65,0x6e ; cpuid\x00";
pub const __HYPERVISOR_set_trap_table: ::std::os::raw::c_uint = 0;
pub const __HYPERVISOR_mmu_update: ::std::os::raw::c_uint = 1;
pub const __HYPERVISOR_set_gdt: ::std::os::raw::c_uint = 2;
pub const __HYPERVISOR_stack_switch: ::std::os::raw::c_uint = 3;
pub const __HYPERVISOR_set_callbacks: ::std::os::raw::c_uint = 4;
pub const __HYPERVISOR_fpu_taskswitch: ::std::os::raw::c_uint = 5;
pub const __HYPERVISOR_sched_op_compat: ::std::os::raw::c_uint = 6;
pub const __HYPERVISOR_dom0_op: ::std::os::raw::c_uint = 7;
pub const __HYPERVISOR_set_debugreg: ::std::os::raw::c_uint = 8;
pub const __HYPERVISOR_get_debugreg: ::std::os::raw::c_uint = 9;
pub const __HYPERVISOR_update_descriptor: ::std::os::raw::c_uint = 10;
pub const __HYPERVISOR_memory_op: ::std::os::raw::c_uint = 12;
pub const __HYPERVISOR_multicall: ::std::os::raw::c_uint = 13;
pub const __HYPERVISOR_update_va_mapping: ::std::os::raw::c_uint = 14;
pub const __HYPERVISOR_set_timer_op: ::std::os::raw::c_uint = 15;
pub const __HYPERVISOR_event_channel_op_compat: ::std::os::raw::c_uint = 16;
pub const __HYPERVISOR_xen_version: ::std::os::raw::c_uint = 17;
pub const __HYPERVISOR_console_io: ::std::os::raw::c_uint = 18;
pub const __HYPERVISOR_physdev_op_compat: ::std::os::raw::c_uint = 19;
pub const __HYPERVISOR_grant_table_op: ::std::os::raw::c_uint = 20;
pub const __HYPERVISOR_vm_assist: ::std::os::raw::c_uint = 21;
pub const __HYPERVISOR_update_va_mapping_otherdomain: ::std::os::raw::c_uint =
    22;
pub const __HYPERVISOR_iret: ::std::os::raw::c_uint = 23;
pub const __HYPERVISOR_vcpu_op: ::std::os::raw::c_uint = 24;
pub const __HYPERVISOR_set_segment_base: ::std::os::raw::c_uint = 25;
pub const __HYPERVISOR_mmuext_op: ::std::os::raw::c_uint = 26;
pub const __HYPERVISOR_xsm_op: ::std::os::raw::c_uint = 27;
pub const __HYPERVISOR_nmi_op: ::std::os::raw::c_uint = 28;
pub const __HYPERVISOR_sched_op: ::std::os::raw::c_uint = 29;
pub const __HYPERVISOR_callback_op: ::std::os::raw::c_uint = 30;
pub const __HYPERVISOR_xenoprof_op: ::std::os::raw::c_uint = 31;
pub const __HYPERVISOR_event_channel_op: ::std::os::raw::c_uint = 32;
pub const __HYPERVISOR_physdev_op: ::std::os::raw::c_uint = 33;
pub const __HYPERVISOR_hvm_op: ::std::os::raw::c_uint = 34;
pub const __HYPERVISOR_sysctl: ::std::os::raw::c_uint = 35;
pub const __HYPERVISOR_domctl: ::std::os::raw::c_uint = 36;
pub const __HYPERVISOR_kexec_op: ::std::os::raw::c_uint = 37;
pub const __HYPERVISOR_tmem_op: ::std::os::raw::c_uint = 38;
pub const __HYPERVISOR_xc_reserved_op: ::std::os::raw::c_uint = 39;
pub const __HYPERVISOR_arch_0: ::std::os::raw::c_uint = 48;
pub const __HYPERVISOR_arch_1: ::std::os::raw::c_uint = 49;
pub const __HYPERVISOR_arch_2: ::std::os::raw::c_uint = 50;
pub const __HYPERVISOR_arch_3: ::std::os::raw::c_uint = 51;
pub const __HYPERVISOR_arch_4: ::std::os::raw::c_uint = 52;
pub const __HYPERVISOR_arch_5: ::std::os::raw::c_uint = 53;
pub const __HYPERVISOR_arch_6: ::std::os::raw::c_uint = 54;
pub const __HYPERVISOR_arch_7: ::std::os::raw::c_uint = 55;
pub const VIRQ_TIMER: ::std::os::raw::c_uint = 0;
pub const VIRQ_DEBUG: ::std::os::raw::c_uint = 1;
pub const VIRQ_CONSOLE: ::std::os::raw::c_uint = 2;
pub const VIRQ_DOM_EXC: ::std::os::raw::c_uint = 3;
pub const VIRQ_TBUF: ::std::os::raw::c_uint = 4;
pub const VIRQ_DEBUGGER: ::std::os::raw::c_uint = 6;
pub const VIRQ_XENOPROF: ::std::os::raw::c_uint = 7;
pub const VIRQ_CON_RING: ::std::os::raw::c_uint = 8;
pub const VIRQ_PCPU_STATE: ::std::os::raw::c_uint = 9;
pub const VIRQ_MEM_EVENT: ::std::os::raw::c_uint = 10;
pub const VIRQ_XC_RESERVED: ::std::os::raw::c_uint = 11;
pub const VIRQ_ENOMEM: ::std::os::raw::c_uint = 12;
pub const VIRQ_ARCH_0: ::std::os::raw::c_uint = 16;
pub const VIRQ_ARCH_1: ::std::os::raw::c_uint = 17;
pub const VIRQ_ARCH_2: ::std::os::raw::c_uint = 18;
pub const VIRQ_ARCH_3: ::std::os::raw::c_uint = 19;
pub const VIRQ_ARCH_4: ::std::os::raw::c_uint = 20;
pub const VIRQ_ARCH_5: ::std::os::raw::c_uint = 21;
pub const VIRQ_ARCH_6: ::std::os::raw::c_uint = 22;
pub const VIRQ_ARCH_7: ::std::os::raw::c_uint = 23;
pub const NR_VIRQS: ::std::os::raw::c_uint = 24;
pub const MMU_NORMAL_PT_UPDATE: ::std::os::raw::c_uint = 0;
pub const MMU_MACHPHYS_UPDATE: ::std::os::raw::c_uint = 1;
pub const MMU_PT_UPDATE_PRESERVE_AD: ::std::os::raw::c_uint = 2;
pub const MMUEXT_PIN_L1_TABLE: ::std::os::raw::c_uint = 0;
pub const MMUEXT_PIN_L2_TABLE: ::std::os::raw::c_uint = 1;
pub const MMUEXT_PIN_L3_TABLE: ::std::os::raw::c_uint = 2;
pub const MMUEXT_PIN_L4_TABLE: ::std::os::raw::c_uint = 3;
pub const MMUEXT_UNPIN_TABLE: ::std::os::raw::c_uint = 4;
pub const MMUEXT_NEW_BASEPTR: ::std::os::raw::c_uint = 5;
pub const MMUEXT_TLB_FLUSH_LOCAL: ::std::os::raw::c_uint = 6;
pub const MMUEXT_INVLPG_LOCAL: ::std::os::raw::c_uint = 7;
pub const MMUEXT_TLB_FLUSH_MULTI: ::std::os::raw::c_uint = 8;
pub const MMUEXT_INVLPG_MULTI: ::std::os::raw::c_uint = 9;
pub const MMUEXT_TLB_FLUSH_ALL: ::std::os::raw::c_uint = 10;
pub const MMUEXT_INVLPG_ALL: ::std::os::raw::c_uint = 11;
pub const MMUEXT_FLUSH_CACHE: ::std::os::raw::c_uint = 12;
pub const MMUEXT_SET_LDT: ::std::os::raw::c_uint = 13;
pub const MMUEXT_NEW_USER_BASEPTR: ::std::os::raw::c_uint = 15;
pub const MMUEXT_CLEAR_PAGE: ::std::os::raw::c_uint = 16;
pub const MMUEXT_COPY_PAGE: ::std::os::raw::c_uint = 17;
pub const MMUEXT_FLUSH_CACHE_GLOBAL: ::std::os::raw::c_uint = 18;
pub const MMUEXT_MARK_SUPER: ::std::os::raw::c_uint = 19;
pub const MMUEXT_UNMARK_SUPER: ::std::os::raw::c_uint = 20;
pub const UVMF_NONE: ::std::os::raw::c_uint = 0;
pub const UVMF_TLB_FLUSH: ::std::os::raw::c_uint = 1;
pub const UVMF_INVLPG: ::std::os::raw::c_uint = 2;
pub const UVMF_FLUSHTYPE_MASK: ::std::os::raw::c_uint = 3;
pub const UVMF_MULTI: ::std::os::raw::c_uint = 0;
pub const UVMF_LOCAL: ::std::os::raw::c_uint = 0;
pub const UVMF_ALL: ::std::os::raw::c_uint = 4;
pub const CONSOLEIO_write: ::std::os::raw::c_uint = 0;
pub const CONSOLEIO_read: ::std::os::raw::c_uint = 1;
pub const VMASST_CMD_enable: ::std::os::raw::c_uint = 0;
pub const VMASST_CMD_disable: ::std::os::raw::c_uint = 1;
pub const VMASST_TYPE_4gb_segments: ::std::os::raw::c_uint = 0;
pub const VMASST_TYPE_4gb_segments_notify: ::std::os::raw::c_uint = 1;
pub const VMASST_TYPE_writable_pagetables: ::std::os::raw::c_uint = 2;
pub const VMASST_TYPE_pae_extended_cr3: ::std::os::raw::c_uint = 3;
pub const MAX_VMASST_TYPE: ::std::os::raw::c_uint = 3;
pub const DOMID_FIRST_RESERVED: ::std::os::raw::c_uint = 32752;
pub const DOMID_SELF: ::std::os::raw::c_uint = 32752;
pub const DOMID_IO: ::std::os::raw::c_uint = 32753;
pub const DOMID_XEN: ::std::os::raw::c_uint = 32754;
pub const DOMID_COW: ::std::os::raw::c_uint = 32755;
pub const DOMID_INVALID: ::std::os::raw::c_uint = 32756;
pub const DOMID_IDLE: ::std::os::raw::c_uint = 32767;
pub const MAX_GUEST_CMDLINE: ::std::os::raw::c_uint = 1024;
pub const SIF_PRIVILEGED: ::std::os::raw::c_uint = 1;
pub const SIF_INITDOMAIN: ::std::os::raw::c_uint = 2;
pub const SIF_MULTIBOOT_MOD: ::std::os::raw::c_uint = 4;
pub const SIF_MOD_START_PFN: ::std::os::raw::c_uint = 8;
pub const SIF_PM_MASK: ::std::os::raw::c_uint = 65280;
pub const XEN_VGATYPE_TEXT_MODE_3: ::std::os::raw::c_uint = 3;
pub const XEN_VGATYPE_VESA_LFB: ::std::os::raw::c_uint = 35;
pub const XEN_VGATYPE_EFI_LFB: ::std::os::raw::c_uint = 112;
pub const TMEM_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const XENFEAT_writable_page_tables: ::std::os::raw::c_uint = 0;
pub const XENFEAT_writable_descriptor_tables: ::std::os::raw::c_uint = 1;
pub const XENFEAT_auto_translated_physmap: ::std::os::raw::c_uint = 2;
pub const XENFEAT_supervisor_mode_kernel: ::std::os::raw::c_uint = 3;
pub const XENFEAT_pae_pgdir_above_4gb: ::std::os::raw::c_uint = 4;
pub const XENFEAT_mmu_pt_update_preserve_ad: ::std::os::raw::c_uint = 5;
pub const XENFEAT_gnttab_map_avail_bits: ::std::os::raw::c_uint = 7;
pub const XENFEAT_hvm_callback_vector: ::std::os::raw::c_uint = 8;
pub const XENFEAT_hvm_safe_pvclock: ::std::os::raw::c_uint = 9;
pub const XENFEAT_hvm_pirqs: ::std::os::raw::c_uint = 10;
pub const XENFEAT_dom0: ::std::os::raw::c_uint = 11;
pub const XENFEAT_NR_SUBMAPS: ::std::os::raw::c_uint = 1;
pub const IO_SPACE_LIMIT: ::std::os::raw::c_uint = 65535;
pub const ARCH_HAS_POWER_INIT: ::std::os::raw::c_uint = 1;
pub const VCLOCK_NONE: ::std::os::raw::c_uint = 0;
pub const VCLOCK_TSC: ::std::os::raw::c_uint = 1;
pub const VCLOCK_HPET: ::std::os::raw::c_uint = 2;
pub const VCLOCK_PVCLOCK: ::std::os::raw::c_uint = 3;
pub const CLOCK_SOURCE_IS_CONTINUOUS: ::std::os::raw::c_uint = 1;
pub const CLOCK_SOURCE_MUST_VERIFY: ::std::os::raw::c_uint = 2;
pub const CLOCK_SOURCE_WATCHDOG: ::std::os::raw::c_uint = 16;
pub const CLOCK_SOURCE_VALID_FOR_HRES: ::std::os::raw::c_uint = 32;
pub const CLOCK_SOURCE_UNSTABLE: ::std::os::raw::c_uint = 64;
pub const CLOCK_SOURCE_SUSPEND_NONSTOP: ::std::os::raw::c_uint = 128;
pub const CLOCK_SOURCE_RESELECT: ::std::os::raw::c_uint = 256;
pub const VSYSCALL_ADDR: ::std::os::raw::c_int = -10485760;
pub const NR_FIX_BTMAPS: ::std::os::raw::c_uint = 64;
pub const FIX_BTMAPS_SLOTS: ::std::os::raw::c_uint = 8;
pub const TOTAL_FIX_BTMAPS: ::std::os::raw::c_uint = 512;
pub const IDLE_START: ::std::os::raw::c_uint = 1;
pub const IDLE_END: ::std::os::raw::c_uint = 2;
pub const ARCH_APICTIMER_STOPS_ON_C3: ::std::os::raw::c_uint = 1;
pub const APIC_QUIET: ::std::os::raw::c_uint = 0;
pub const APIC_VERBOSE: ::std::os::raw::c_uint = 1;
pub const APIC_DEBUG: ::std::os::raw::c_uint = 2;
pub const TRAMPOLINE_PHYS_LOW: ::std::os::raw::c_uint = 1127;
pub const TRAMPOLINE_PHYS_HIGH: ::std::os::raw::c_uint = 1129;
pub const APIC_DFR_VALUE: ::std::os::raw::c_uint = 4294967295;
pub const NMI_VECTOR: ::std::os::raw::c_uint = 2;
pub const MCE_VECTOR: ::std::os::raw::c_uint = 18;
pub const FIRST_EXTERNAL_VECTOR: ::std::os::raw::c_uint = 32;
pub const VECTOR_OFFSET_START: ::std::os::raw::c_uint = 1;
pub const IRQ_MOVE_CLEANUP_VECTOR: ::std::os::raw::c_uint = 32;
pub const IA32_SYSCALL_VECTOR: ::std::os::raw::c_uint = 128;
pub const SPURIOUS_APIC_VECTOR: ::std::os::raw::c_uint = 255;
pub const ERROR_APIC_VECTOR: ::std::os::raw::c_uint = 254;
pub const RESCHEDULE_VECTOR: ::std::os::raw::c_uint = 253;
pub const CALL_FUNCTION_VECTOR: ::std::os::raw::c_uint = 252;
pub const CALL_FUNCTION_SINGLE_VECTOR: ::std::os::raw::c_uint = 251;
pub const THERMAL_APIC_VECTOR: ::std::os::raw::c_uint = 250;
pub const THRESHOLD_APIC_VECTOR: ::std::os::raw::c_uint = 249;
pub const REBOOT_VECTOR: ::std::os::raw::c_uint = 248;
pub const X86_PLATFORM_IPI_VECTOR: ::std::os::raw::c_uint = 247;
pub const POSTED_INTR_WAKEUP_VECTOR: ::std::os::raw::c_uint = 241;
pub const IRQ_WORK_VECTOR: ::std::os::raw::c_uint = 246;
pub const UV_BAU_MESSAGE: ::std::os::raw::c_uint = 245;
pub const DEFERRED_ERROR_VECTOR: ::std::os::raw::c_uint = 244;
pub const HYPERVISOR_CALLBACK_VECTOR: ::std::os::raw::c_uint = 243;
pub const POSTED_INTR_VECTOR: ::std::os::raw::c_uint = 242;
pub const LOCAL_TIMER_VECTOR: ::std::os::raw::c_uint = 239;
pub const NR_VECTORS: ::std::os::raw::c_uint = 256;
pub const FIRST_SYSTEM_VECTOR: ::std::os::raw::c_uint = 239;
pub const FPU_IRQ: ::std::os::raw::c_uint = 13;
pub const NR_IRQS_LEGACY: ::std::os::raw::c_uint = 16;
pub const CPU_VECTOR_LIMIT: ::std::os::raw::c_uint = 16384;
pub const IO_APIC_VECTOR_LIMIT: ::std::os::raw::c_uint = 4096;
pub const IO_APIC_REDIR_VECTOR_MASK: ::std::os::raw::c_uint = 255;
pub const IO_APIC_REDIR_DEST_LOGICAL: ::std::os::raw::c_uint = 2048;
pub const IO_APIC_REDIR_DEST_PHYSICAL: ::std::os::raw::c_uint = 0;
pub const IO_APIC_REDIR_SEND_PENDING: ::std::os::raw::c_uint = 4096;
pub const IO_APIC_REDIR_REMOTE_IRR: ::std::os::raw::c_uint = 16384;
pub const IO_APIC_REDIR_LEVEL_TRIGGER: ::std::os::raw::c_uint = 32768;
pub const IO_APIC_REDIR_MASKED: ::std::os::raw::c_uint = 65536;
pub const IOAPIC_AUTO: ::std::os::raw::c_int = -1;
pub const IOAPIC_EDGE: ::std::os::raw::c_uint = 0;
pub const IOAPIC_LEVEL: ::std::os::raw::c_uint = 1;
pub const IOAPIC_MASKED: ::std::os::raw::c_uint = 1;
pub const IOAPIC_UNMASKED: ::std::os::raw::c_uint = 0;
pub const IOAPIC_POL_HIGH: ::std::os::raw::c_uint = 0;
pub const IOAPIC_POL_LOW: ::std::os::raw::c_uint = 1;
pub const IOAPIC_DEST_MODE_PHYSICAL: ::std::os::raw::c_uint = 0;
pub const IOAPIC_DEST_MODE_LOGICAL: ::std::os::raw::c_uint = 1;
pub const IOAPIC_MAP_ALLOC: ::std::os::raw::c_uint = 1;
pub const IOAPIC_MAP_CHECK: ::std::os::raw::c_uint = 2;
pub const PA_SECTION_SHIFT: ::std::os::raw::c_uint = 27;
pub const PFN_SECTION_SHIFT: ::std::os::raw::c_uint = 15;
pub const NR_MEM_SECTIONS: ::std::os::raw::c_uint = 524288;
pub const PAGES_PER_SECTION: ::std::os::raw::c_uint = 32768;
pub const PAGE_SECTION_MASK: ::std::os::raw::c_int = -32768;
pub const SECTION_MARKED_PRESENT: ::std::os::raw::c_uint = 1;
pub const SECTION_HAS_MEM_MAP: ::std::os::raw::c_uint = 2;
pub const SECTION_MAP_LAST_BIT: ::std::os::raw::c_uint = 4;
pub const SECTION_MAP_MASK: ::std::os::raw::c_int = -4;
pub const SECTION_NID_SHIFT: ::std::os::raw::c_uint = 2;
pub const PERCPU_MODULE_RESERVE: ::std::os::raw::c_uint = 8192;
pub const PERCPU_DYNAMIC_EARLY_SLOTS: ::std::os::raw::c_uint = 128;
pub const PERCPU_DYNAMIC_EARLY_SIZE: ::std::os::raw::c_uint = 12288;
pub const PERCPU_DYNAMIC_RESERVE: ::std::os::raw::c_uint = 28672;
pub const LOCAL_DISTANCE: ::std::os::raw::c_uint = 10;
pub const REMOTE_DISTANCE: ::std::os::raw::c_uint = 20;
pub const RECLAIM_DISTANCE: ::std::os::raw::c_uint = 30;
pub const PENALTY_FOR_NODE_WITH_CPUS: ::std::os::raw::c_uint = 1;
pub const ___GFP_DMA: ::std::os::raw::c_uint = 1;
pub const ___GFP_HIGHMEM: ::std::os::raw::c_uint = 2;
pub const ___GFP_DMA32: ::std::os::raw::c_uint = 4;
pub const ___GFP_MOVABLE: ::std::os::raw::c_uint = 8;
pub const ___GFP_WAIT: ::std::os::raw::c_uint = 16;
pub const ___GFP_HIGH: ::std::os::raw::c_uint = 32;
pub const ___GFP_IO: ::std::os::raw::c_uint = 64;
pub const ___GFP_FS: ::std::os::raw::c_uint = 128;
pub const ___GFP_COLD: ::std::os::raw::c_uint = 256;
pub const ___GFP_NOWARN: ::std::os::raw::c_uint = 512;
pub const ___GFP_REPEAT: ::std::os::raw::c_uint = 1024;
pub const ___GFP_NOFAIL: ::std::os::raw::c_uint = 2048;
pub const ___GFP_NORETRY: ::std::os::raw::c_uint = 4096;
pub const ___GFP_MEMALLOC: ::std::os::raw::c_uint = 8192;
pub const ___GFP_COMP: ::std::os::raw::c_uint = 16384;
pub const ___GFP_ZERO: ::std::os::raw::c_uint = 32768;
pub const ___GFP_NOMEMALLOC: ::std::os::raw::c_uint = 65536;
pub const ___GFP_HARDWALL: ::std::os::raw::c_uint = 131072;
pub const ___GFP_THISNODE: ::std::os::raw::c_uint = 262144;
pub const ___GFP_RECLAIMABLE: ::std::os::raw::c_uint = 524288;
pub const ___GFP_NOACCOUNT: ::std::os::raw::c_uint = 1048576;
pub const ___GFP_NOTRACK: ::std::os::raw::c_uint = 2097152;
pub const ___GFP_NO_KSWAPD: ::std::os::raw::c_uint = 4194304;
pub const ___GFP_OTHER_NODE: ::std::os::raw::c_uint = 8388608;
pub const ___GFP_WRITE: ::std::os::raw::c_uint = 16777216;
pub const __GFP_BITS_SHIFT: ::std::os::raw::c_uint = 25;
pub const SLAB_DEBUG_FREE: ::std::os::raw::c_uint = 256;
pub const SLAB_RED_ZONE: ::std::os::raw::c_uint = 1024;
pub const SLAB_POISON: ::std::os::raw::c_uint = 2048;
pub const SLAB_HWCACHE_ALIGN: ::std::os::raw::c_uint = 8192;
pub const SLAB_CACHE_DMA: ::std::os::raw::c_uint = 16384;
pub const SLAB_STORE_USER: ::std::os::raw::c_uint = 65536;
pub const SLAB_PANIC: ::std::os::raw::c_uint = 262144;
pub const SLAB_DESTROY_BY_RCU: ::std::os::raw::c_uint = 524288;
pub const SLAB_MEM_SPREAD: ::std::os::raw::c_uint = 1048576;
pub const SLAB_TRACE: ::std::os::raw::c_uint = 2097152;
pub const SLAB_DEBUG_OBJECTS: ::std::os::raw::c_uint = 0;
pub const SLAB_NOLEAKTRACE: ::std::os::raw::c_uint = 8388608;
pub const SLAB_NOTRACK: ::std::os::raw::c_uint = 0;
pub const SLAB_FAILSLAB: ::std::os::raw::c_uint = 0;
pub const SLAB_RECLAIM_ACCOUNT: ::std::os::raw::c_uint = 131072;
pub const SLAB_TEMPORARY: ::std::os::raw::c_uint = 131072;
pub const KMALLOC_SHIFT_HIGH: ::std::os::raw::c_uint = 13;
pub const KMALLOC_SHIFT_MAX: ::std::os::raw::c_uint = 23;
pub const KMALLOC_SHIFT_LOW: ::std::os::raw::c_uint = 3;
pub const KMALLOC_MAX_SIZE: ::std::os::raw::c_uint = 8388608;
pub const KMALLOC_MAX_CACHE_SIZE: ::std::os::raw::c_uint = 8192;
pub const KMALLOC_MAX_ORDER: ::std::os::raw::c_uint = 11;
pub const KMALLOC_MIN_SIZE: ::std::os::raw::c_uint = 8;
pub const HRTIMER_STATE_INACTIVE: ::std::os::raw::c_uint = 0;
pub const HRTIMER_STATE_ENQUEUED: ::std::os::raw::c_uint = 1;
pub const HRTIMER_CLOCK_BASE_ALIGN: ::std::os::raw::c_uint = 64;
pub const HIGH_RES_NSEC: ::std::os::raw::c_uint = 1;
pub const MONOTONIC_RES_NSEC: ::std::os::raw::c_uint = 1;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
#[repr(C)]
#[derive(Copy)]
pub struct ftrace_branch_data {
    pub func: *const ::std::os::raw::c_char,
    pub file: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: ftrace_branch_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct ftrace_branch_data__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>,
    pub miss_hit: __BindgenUnionField<[::std::os::raw::c_ulong; 2usize]>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct ftrace_branch_data__bindgen_ty_1__bindgen_ty_1 {
    pub correct: ::std::os::raw::c_ulong,
    pub incorrect: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ftrace_branch_data__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               ftrace_branch_data__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                ftrace_branch_data__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ftrace_branch_data__bindgen_ty_1__bindgen_ty_1 )
                ) . correct as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ftrace_branch_data__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( correct ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ftrace_branch_data__bindgen_ty_1__bindgen_ty_1 )
                ) . incorrect as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                ftrace_branch_data__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( incorrect ) ));
}
impl Clone for ftrace_branch_data__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ftrace_branch_data__bindgen_ty_1__bindgen_ty_2 {
    pub miss: ::std::os::raw::c_ulong,
    pub hit: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ftrace_branch_data__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               ftrace_branch_data__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                ftrace_branch_data__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ftrace_branch_data__bindgen_ty_1__bindgen_ty_2 )
                ) . miss as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ftrace_branch_data__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( miss ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ftrace_branch_data__bindgen_ty_1__bindgen_ty_2 )
                ) . hit as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                ftrace_branch_data__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( hit ) ));
}
impl Clone for ftrace_branch_data__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ftrace_branch_data__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ftrace_branch_data__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( ftrace_branch_data__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<ftrace_branch_data__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                ftrace_branch_data__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ftrace_branch_data__bindgen_ty_1 ) ) .
                miss_hit as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ftrace_branch_data__bindgen_ty_1 ) , "::" , stringify ! (
                miss_hit ) ));
}
impl Clone for ftrace_branch_data__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ftrace_branch_data() {
    assert_eq!(::std::mem::size_of::<ftrace_branch_data>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( ftrace_branch_data ) ));
    assert_eq! (::std::mem::align_of::<ftrace_branch_data>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ftrace_branch_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ftrace_branch_data ) ) . func as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ftrace_branch_data ) ,
                "::" , stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ftrace_branch_data ) ) . file as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ftrace_branch_data ) ,
                "::" , stringify ! ( file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ftrace_branch_data ) ) . line as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ftrace_branch_data ) ,
                "::" , stringify ! ( line ) ));
}
impl Clone for ftrace_branch_data {
    fn clone(&self) -> Self { *self }
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type s8 = ::std::os::raw::c_schar;
pub type u8 = ::std::os::raw::c_uchar;
pub type s16 = ::std::os::raw::c_short;
pub type u16 = ::std::os::raw::c_ushort;
pub type s32 = ::std::os::raw::c_int;
pub type u32 = ::std::os::raw::c_uint;
pub type s64 = ::std::os::raw::c_longlong;
pub type u64 = ::std::os::raw::c_ulonglong;
pub const false_: _bindgen_ty_1 = _bindgen_ty_1::false_;
pub const true_: _bindgen_ty_1 = _bindgen_ty_1::true_;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 { false_ = 0, true_ = 1, }
#[repr(C)]
#[derive(Copy)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(::std::mem::size_of::<__kernel_fd_set>() , 128usize , concat !
               ( "Size of: " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fd_set>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fd_set ) ) . fds_bits as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fd_set ) ,
                "::" , stringify ! ( fds_bits ) ));
}
impl Clone for __kernel_fd_set {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Copy)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(::std::mem::size_of::<__kernel_fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fsid_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fsid_t ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fsid_t ) ,
                "::" , stringify ! ( val ) ));
}
impl Clone for __kernel_fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __kernel_dev_t = __u32;
pub type fd_set = __kernel_fd_set;
pub type dev_t = __kernel_dev_t;
pub type ino_t = __kernel_ino_t;
pub type mode_t = __kernel_mode_t;
pub type umode_t = ::std::os::raw::c_ushort;
pub type nlink_t = __u32;
pub type off_t = __kernel_off_t;
pub type pid_t = __kernel_pid_t;
pub type daddr_t = __kernel_daddr_t;
pub type key_t = __kernel_key_t;
pub type suseconds_t = __kernel_suseconds_t;
pub type timer_t = __kernel_timer_t;
pub type clockid_t = __kernel_clockid_t;
pub type mqd_t = __kernel_mqd_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type uid16_t = __kernel_uid16_t;
pub type gid16_t = __kernel_gid16_t;
pub type old_uid_t = __kernel_old_uid_t;
pub type old_gid_t = __kernel_old_gid_t;
pub type loff_t = __kernel_loff_t;
pub type time_t = __kernel_time_t;
pub type clock_t = __kernel_clock_t;
pub type caddr_t = __kernel_caddr_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type unchar = ::std::os::raw::c_uchar;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type ulong = ::std::os::raw::c_ulong;
pub type u_int8_t = __u8;
pub type u_int16_t = __u16;
pub type u_int32_t = __u32;
pub type u_int64_t = __u64;
pub type sector_t = ::std::os::raw::c_ulong;
pub type blkcnt_t = ::std::os::raw::c_ulong;
pub type dma_addr_t = u64;
pub type gfp_t = ::std::os::raw::c_uint;
pub type fmode_t = ::std::os::raw::c_uint;
pub type oom_flags_t = ::std::os::raw::c_uint;
pub type phys_addr_t = u64;
pub type resource_size_t = phys_addr_t;
pub type irq_hw_number_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct atomic_t {
    pub counter: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_atomic_t() {
    assert_eq!(::std::mem::size_of::<atomic_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( atomic_t ) ));
    assert_eq! (::std::mem::align_of::<atomic_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( atomic_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const atomic_t ) ) . counter as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( atomic_t ) , "::" ,
                stringify ! ( counter ) ));
}
impl Clone for atomic_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct atomic64_t {
    pub counter: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_atomic64_t() {
    assert_eq!(::std::mem::size_of::<atomic64_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( atomic64_t ) ));
    assert_eq! (::std::mem::align_of::<atomic64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( atomic64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const atomic64_t ) ) . counter as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( atomic64_t ) , "::" ,
                stringify ! ( counter ) ));
}
impl Clone for atomic64_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[test]
fn bindgen_test_layout_list_head() {
    assert_eq!(::std::mem::size_of::<list_head>() , 16usize , concat ! (
               "Size of: " , stringify ! ( list_head ) ));
    assert_eq! (::std::mem::align_of::<list_head>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( list_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const list_head ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( list_head ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const list_head ) ) . prev as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( list_head ) , "::" ,
                stringify ! ( prev ) ));
}
impl Clone for list_head {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_head() {
    assert_eq!(::std::mem::size_of::<hlist_head>() , 8usize , concat ! (
               "Size of: " , stringify ! ( hlist_head ) ));
    assert_eq! (::std::mem::align_of::<hlist_head>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( hlist_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hlist_head ) ) . first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hlist_head ) , "::" ,
                stringify ! ( first ) ));
}
impl Clone for hlist_head {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_node() {
    assert_eq!(::std::mem::size_of::<hlist_node>() , 16usize , concat ! (
               "Size of: " , stringify ! ( hlist_node ) ));
    assert_eq! (::std::mem::align_of::<hlist_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( hlist_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hlist_node ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hlist_node ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hlist_node ) ) . pprev as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( hlist_node ) , "::" ,
                stringify ! ( pprev ) ));
}
impl Clone for hlist_node {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ustat {
    pub f_tfree: __kernel_daddr_t,
    pub f_tinode: __kernel_ino_t,
    pub f_fname: [::std::os::raw::c_char; 6usize],
    pub f_fpack: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout_ustat() {
    assert_eq!(::std::mem::size_of::<ustat>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ustat ) ));
    assert_eq! (::std::mem::align_of::<ustat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ustat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ustat ) ) . f_tfree as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ustat ) , "::" ,
                stringify ! ( f_tfree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ustat ) ) . f_tinode as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ustat ) , "::" ,
                stringify ! ( f_tinode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ustat ) ) . f_fname as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ustat ) , "::" ,
                stringify ! ( f_fname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ustat ) ) . f_fpack as * const _ as usize
                } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( ustat ) , "::" ,
                stringify ! ( f_fpack ) ));
}
impl Clone for ustat {
    fn clone(&self) -> Self { *self }
}
/// struct callback_head - callback structure for use with RCU and task_work
/// @next: next update requests in a list
/// @func: actual update function to call after the grace period.
#[repr(C)]
#[derive(Copy)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::std::option::Option<unsafe extern "C" fn(head:
                                                             *mut callback_head)>,
}
#[test]
fn bindgen_test_layout_callback_head() {
    assert_eq!(::std::mem::size_of::<callback_head>() , 16usize , concat ! (
               "Size of: " , stringify ! ( callback_head ) ));
    assert_eq! (::std::mem::align_of::<callback_head>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callback_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callback_head ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callback_head ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callback_head ) ) . func as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( callback_head ) , "::"
                , stringify ! ( func ) ));
}
impl Clone for callback_head {
    fn clone(&self) -> Self { *self }
}
pub type cycle_t = u64;
pub type initcall_t =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type exitcall_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "__con_initcall_start"]
    pub static mut __con_initcall_start: [initcall_t; 0usize];
}
extern "C" {
    #[link_name = "__con_initcall_end"]
    pub static mut __con_initcall_end: [initcall_t; 0usize];
}
extern "C" {
    #[link_name = "__security_initcall_start"]
    pub static mut __security_initcall_start: [initcall_t; 0usize];
}
extern "C" {
    #[link_name = "__security_initcall_end"]
    pub static mut __security_initcall_end: [initcall_t; 0usize];
}
pub type ctor_fn_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn do_one_initcall(fn_: initcall_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "boot_command_line"]
    pub static mut boot_command_line: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "saved_command_line"]
    pub static mut saved_command_line: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "reset_devices"]
    pub static mut reset_devices: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn setup_arch(arg1: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn prepare_namespace();
}
extern "C" {
    pub fn load_default_modules();
}
extern "C" {
    pub fn init_rootfs() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "late_time_init"]
    pub static mut late_time_init:
               ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    #[link_name = "initcall_debug"]
    pub static mut initcall_debug: bool_;
}
#[repr(C)]
#[derive(Copy)]
pub struct kernel_symbol {
    pub value: ::std::os::raw::c_ulong,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_kernel_symbol() {
    assert_eq!(::std::mem::size_of::<kernel_symbol>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kernel_symbol ) ));
    assert_eq! (::std::mem::align_of::<kernel_symbol>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kernel_symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kernel_symbol ) ) . value as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kernel_symbol ) , "::"
                , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kernel_symbol ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kernel_symbol ) , "::"
                , stringify ! ( name ) ));
}
impl Clone for kernel_symbol {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "__this_module"]
    pub static mut __this_module: module;
}
#[repr(C)]
#[derive(Copy)]
pub struct sysinfo {
    pub uptime: __kernel_long_t,
    pub loads: [__kernel_ulong_t; 3usize],
    pub totalram: __kernel_ulong_t,
    pub freeram: __kernel_ulong_t,
    pub sharedram: __kernel_ulong_t,
    pub bufferram: __kernel_ulong_t,
    pub totalswap: __kernel_ulong_t,
    pub freeswap: __kernel_ulong_t,
    pub procs: __u16,
    pub pad: __u16,
    pub totalhigh: __kernel_ulong_t,
    pub freehigh: __kernel_ulong_t,
    pub mem_unit: __u32,
    pub _f: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_sysinfo() {
    assert_eq!(::std::mem::size_of::<sysinfo>() , 112usize , concat ! (
               "Size of: " , stringify ! ( sysinfo ) ));
    assert_eq! (::std::mem::align_of::<sysinfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sysinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinfo ) ) . uptime as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinfo ) , "::" ,
                stringify ! ( uptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinfo ) ) . loads as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinfo ) , "::" ,
                stringify ! ( loads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinfo ) ) . totalram as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinfo ) , "::" ,
                stringify ! ( totalram ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinfo ) ) . freeram as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinfo ) , "::" ,
                stringify ! ( freeram ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinfo ) ) . sharedram as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinfo ) , "::" ,
                stringify ! ( sharedram ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinfo ) ) . bufferram as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinfo ) , "::" ,
                stringify ! ( bufferram ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinfo ) ) . totalswap as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinfo ) , "::" ,
                stringify ! ( totalswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinfo ) ) . freeswap as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinfo ) , "::" ,
                stringify ! ( freeswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinfo ) ) . procs as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinfo ) , "::" ,
                stringify ! ( procs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinfo ) ) . pad as * const _ as usize }
                , 82usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinfo ) , "::" ,
                stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinfo ) ) . totalhigh as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinfo ) , "::" ,
                stringify ! ( totalhigh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinfo ) ) . freehigh as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinfo ) , "::" ,
                stringify ! ( freehigh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinfo ) ) . mem_unit as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinfo ) , "::" ,
                stringify ! ( mem_unit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinfo ) ) . _f as * const _ as usize }
                , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinfo ) , "::" ,
                stringify ! ( _f ) ));
}
impl Clone for sysinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "linux_banner"]
    pub static mut linux_banner: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "linux_proc_banner"]
    pub static mut linux_proc_banner: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "console_printk"]
    pub static mut console_printk: [::std::os::raw::c_int; 0usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct va_format {
    pub fmt: *const ::std::os::raw::c_char,
    pub va: *mut va_list,
}
#[test]
fn bindgen_test_layout_va_format() {
    assert_eq!(::std::mem::size_of::<va_format>() , 16usize , concat ! (
               "Size of: " , stringify ! ( va_format ) ));
    assert_eq! (::std::mem::align_of::<va_format>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( va_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const va_format ) ) . fmt as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( va_format ) , "::" ,
                stringify ! ( fmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const va_format ) ) . va as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( va_format ) , "::" ,
                stringify ! ( va ) ));
}
impl Clone for va_format {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn early_printk(fmt: *const ::std::os::raw::c_char, ...);
}
pub type printk_func_t =
    ::std::option::Option<unsafe extern "C" fn(fmt:
                                                   *const ::std::os::raw::c_char,
                                               args: *mut __va_list_tag)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn vprintk_emit(facility: ::std::os::raw::c_int,
                        level: ::std::os::raw::c_int,
                        dict: *const ::std::os::raw::c_char, dictlen: usize,
                        fmt: *const ::std::os::raw::c_char,
                        args: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintk(fmt: *const ::std::os::raw::c_char,
                   args: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printk_emit(facility: ::std::os::raw::c_int,
                       level: ::std::os::raw::c_int,
                       dict: *const ::std::os::raw::c_char, dictlen: usize,
                       fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printk(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printk_deferred(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __printk_ratelimit(func: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printk_timed_ratelimit(caller_jiffies:
                                      *mut ::std::os::raw::c_ulong,
                                  interval_msec: ::std::os::raw::c_uint)
     -> bool_;
}
extern "C" {
    #[link_name = "printk_delay_msec"]
    pub static mut printk_delay_msec: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "dmesg_restrict"]
    pub static mut dmesg_restrict: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "kptr_restrict"]
    pub static mut kptr_restrict: ::std::os::raw::c_int;
}
extern "C" {
    pub fn wake_up_klogd();
}
extern "C" {
    pub fn log_buf_addr_get() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn log_buf_len_get() -> u32;
}
extern "C" {
    pub fn log_buf_kexec_setup();
}
extern "C" {
    pub fn setup_log_buf(early: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dump_stack_set_arch_desc(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn dump_stack_print_info(log_lvl: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn show_regs_print_info(log_lvl: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn dump_stack();
}
#[repr(C)]
#[derive(Copy)]
pub struct _ddebug {
    pub modname: *const ::std::os::raw::c_char,
    pub function: *const ::std::os::raw::c_char,
    pub filename: *const ::std::os::raw::c_char,
    pub format: *const ::std::os::raw::c_char,
    pub _bitfield_1: u32,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout__ddebug() {
    assert_eq!(::std::mem::size_of::<_ddebug>() , 40usize , concat ! (
               "Size of: " , stringify ! ( _ddebug ) ));
    assert_eq! (::std::mem::align_of::<_ddebug>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _ddebug ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ddebug ) ) . modname as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _ddebug ) , "::" ,
                stringify ! ( modname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ddebug ) ) . function as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _ddebug ) , "::" ,
                stringify ! ( function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ddebug ) ) . filename as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _ddebug ) , "::" ,
                stringify ! ( filename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ddebug ) ) . format as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _ddebug ) , "::" ,
                stringify ! ( format ) ));
}
impl Clone for _ddebug {
    fn clone(&self) -> Self { *self }
}
impl _ddebug {
    #[inline]
    pub fn lineno(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 262143u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_lineno(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 262143u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 66846720u64 as u32;
        let val = (unit_field_val & mask) >> 18usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 66846720u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 18usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(lineno: ::std::os::raw::c_uint,
                          flags: ::std::os::raw::c_uint) -> u32 {
        ({ ({ 0 } | ((lineno as u32 as u32) << 0usize) & (262143u64 as u32)) }
             | ((flags as u32 as u32) << 18usize) & (66846720u64 as u32))
    }
}
extern "C" {
    pub fn ddebug_add_module(tab: *mut _ddebug, n: ::std::os::raw::c_uint,
                             modname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ddebug_remove_module(mod_name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __dynamic_pr_debug(descriptor: *mut _ddebug,
                              fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn ddebug_dyndbg_module_param_cb(param: *mut ::std::os::raw::c_char,
                                         val: *mut ::std::os::raw::c_char,
                                         modname:
                                             *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __dynamic_dev_dbg(descriptor: *mut _ddebug, dev: *const device,
                             fmt: *const ::std::os::raw::c_char, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __dynamic_netdev_dbg(descriptor: *mut _ddebug,
                                dev: *const net_device,
                                fmt: *const ::std::os::raw::c_char, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_operations {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "kmsg_fops"]
    pub static kmsg_fops: file_operations;
}
pub const DUMP_PREFIX_NONE: _bindgen_ty_2 = _bindgen_ty_2::DUMP_PREFIX_NONE;
pub const DUMP_PREFIX_ADDRESS: _bindgen_ty_2 =
    _bindgen_ty_2::DUMP_PREFIX_ADDRESS;
pub const DUMP_PREFIX_OFFSET: _bindgen_ty_2 =
    _bindgen_ty_2::DUMP_PREFIX_OFFSET;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    DUMP_PREFIX_NONE = 0,
    DUMP_PREFIX_ADDRESS = 1,
    DUMP_PREFIX_OFFSET = 2,
}
extern "C" {
    pub fn hex_dump_to_buffer(buf: *const ::std::os::raw::c_void, len: usize,
                              rowsize: ::std::os::raw::c_int,
                              groupsize: ::std::os::raw::c_int,
                              linebuf: *mut ::std::os::raw::c_char,
                              linebuflen: usize, ascii: bool_)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn print_hex_dump(level: *const ::std::os::raw::c_char,
                          prefix_str: *const ::std::os::raw::c_char,
                          prefix_type: ::std::os::raw::c_int,
                          rowsize: ::std::os::raw::c_int,
                          groupsize: ::std::os::raw::c_int,
                          buf: *const ::std::os::raw::c_void, len: usize,
                          ascii: bool_);
}
extern "C" {
    pub fn __sw_hweight8(w: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __sw_hweight16(w: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __sw_hweight32(w: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __sw_hweight64(w: __u64) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "early_idt_handler_array"]
    pub static mut early_idt_handler_array:
               [[::std::os::raw::c_char; 9usize]; 32usize];
}
extern "C" {
    pub fn devmem_is_allowed(pagenr: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "max_low_pfn_mapped"]
    pub static mut max_low_pfn_mapped: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "max_pfn_mapped"]
    pub static mut max_pfn_mapped: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn pfn_range_is_mapped(start_pfn: ::std::os::raw::c_ulong,
                               end_pfn: ::std::os::raw::c_ulong) -> bool_;
}
extern "C" {
    pub fn init_memory_mapping(start: ::std::os::raw::c_ulong,
                               end: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn initmem_init();
}
#[repr(C)]
#[derive(Copy)]
pub struct pt_regs {
    pub r15: ::std::os::raw::c_ulong,
    pub r14: ::std::os::raw::c_ulong,
    pub r13: ::std::os::raw::c_ulong,
    pub r12: ::std::os::raw::c_ulong,
    pub bp: ::std::os::raw::c_ulong,
    pub bx: ::std::os::raw::c_ulong,
    pub r11: ::std::os::raw::c_ulong,
    pub r10: ::std::os::raw::c_ulong,
    pub r9: ::std::os::raw::c_ulong,
    pub r8: ::std::os::raw::c_ulong,
    pub ax: ::std::os::raw::c_ulong,
    pub cx: ::std::os::raw::c_ulong,
    pub dx: ::std::os::raw::c_ulong,
    pub si: ::std::os::raw::c_ulong,
    pub di: ::std::os::raw::c_ulong,
    pub orig_ax: ::std::os::raw::c_ulong,
    pub ip: ::std::os::raw::c_ulong,
    pub cs: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub sp: ::std::os::raw::c_ulong,
    pub ss: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_pt_regs() {
    assert_eq!(::std::mem::size_of::<pt_regs>() , 168usize , concat ! (
               "Size of: " , stringify ! ( pt_regs ) ));
    assert_eq! (::std::mem::align_of::<pt_regs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pt_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . r15 as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . r14 as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . r13 as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . r12 as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . bp as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( bp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . bx as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( bx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . r11 as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . r10 as * const _ as usize }
                , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . r9 as * const _ as usize }
                , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . r8 as * const _ as usize }
                , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . ax as * const _ as usize }
                , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( ax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . cx as * const _ as usize }
                , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( cx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . dx as * const _ as usize }
                , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( dx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . si as * const _ as usize }
                , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( si ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . di as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( di ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . orig_ax as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( orig_ax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . ip as * const _ as usize }
                , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . cs as * const _ as usize }
                , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . flags as * const _ as usize
                } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . sp as * const _ as usize }
                , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . ss as * const _ as usize }
                , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( ss ) ));
}
impl Clone for pt_regs {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct desc_struct {
    pub __bindgen_anon_1: desc_struct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct desc_struct__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<desc_struct__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<desc_struct__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct desc_struct__bindgen_ty_1__bindgen_ty_1 {
    pub a: ::std::os::raw::c_uint,
    pub b: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_desc_struct__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<desc_struct__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               desc_struct__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<desc_struct__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                desc_struct__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const desc_struct__bindgen_ty_1__bindgen_ty_1 )
                ) . a as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                desc_struct__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify !
                ( a ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const desc_struct__bindgen_ty_1__bindgen_ty_1 )
                ) . b as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                desc_struct__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify !
                ( b ) ));
}
impl Clone for desc_struct__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct desc_struct__bindgen_ty_1__bindgen_ty_2 {
    pub limit0: u16,
    pub base0: u16,
    pub _bitfield_1: [u8; 4usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_desc_struct__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<desc_struct__bindgen_ty_1__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               desc_struct__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<desc_struct__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                desc_struct__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const desc_struct__bindgen_ty_1__bindgen_ty_2 )
                ) . limit0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                desc_struct__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify !
                ( limit0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const desc_struct__bindgen_ty_1__bindgen_ty_2 )
                ) . base0 as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                desc_struct__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify !
                ( base0 ) ));
}
impl Clone for desc_struct__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl desc_struct__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn base1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_base1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 3840u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 3840u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn s(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4096u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_s(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4096u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn dpl(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 24576u64 as u32;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 24576u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn p(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32768u64 as u32;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_p(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32768u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn limit(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 983040u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_limit(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 983040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn avl(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1048576u64 as u32;
        let val = (unit_field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_avl(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1048576u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 20usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn l(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2097152u64 as u32;
        let val = (unit_field_val & mask) >> 21usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_l(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2097152u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 21usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn d(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4194304u64 as u32;
        let val = (unit_field_val & mask) >> 22usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_d(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4194304u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 22usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn g(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 8388608u64 as u32;
        let val = (unit_field_val & mask) >> 23usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_g(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8388608u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 23usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn base2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_base2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(base1: ::std::os::raw::c_uint,
                          type_: ::std::os::raw::c_uint,
                          s: ::std::os::raw::c_uint,
                          dpl: ::std::os::raw::c_uint,
                          p: ::std::os::raw::c_uint,
                          limit: ::std::os::raw::c_uint,
                          avl: ::std::os::raw::c_uint,
                          l: ::std::os::raw::c_uint,
                          d: ::std::os::raw::c_uint,
                          g: ::std::os::raw::c_uint,
                          base2: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({
                                                          ({ 0 } |
                                                               ((base1 as u32
                                                                     as u32)
                                                                    << 0usize)
                                                                   &
                                                                   (255u64 as
                                                                        u32))
                                                      } |
                                                          ((type_ as u32 as
                                                                u32) <<
                                                               8usize) &
                                                              (3840u64 as
                                                                   u32))
                                                 } |
                                                     ((s as u32 as u32) <<
                                                          12usize) &
                                                         (4096u64 as u32))
                                            } |
                                                ((dpl as u32 as u32) <<
                                                     13usize) &
                                                    (24576u64 as u32))
                                       } |
                                           ((p as u32 as u32) << 15usize) &
                                               (32768u64 as u32))
                                  } |
                                      ((limit as u32 as u32) << 16usize) &
                                          (983040u64 as u32))
                             } |
                                 ((avl as u32 as u32) << 20usize) &
                                     (1048576u64 as u32))
                        } |
                            ((l as u32 as u32) << 21usize) &
                                (2097152u64 as u32))
                   } | ((d as u32 as u32) << 22usize) & (4194304u64 as u32))
              } | ((g as u32 as u32) << 23usize) & (8388608u64 as u32))
         } | ((base2 as u32 as u32) << 24usize) & (4278190080u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_desc_struct__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<desc_struct__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( desc_struct__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<desc_struct__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( desc_struct__bindgen_ty_1 )
                ));
}
impl Clone for desc_struct__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_desc_struct() {
    assert_eq!(::std::mem::size_of::<desc_struct>() , 8usize , concat ! (
               "Size of: " , stringify ! ( desc_struct ) ));
    assert_eq! (::std::mem::align_of::<desc_struct>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( desc_struct ) ));
}
impl Clone for desc_struct {
    fn clone(&self) -> Self { *self }
}
pub const GATE_INTERRUPT: _bindgen_ty_3 = _bindgen_ty_3::GATE_INTERRUPT;
pub const GATE_TRAP: _bindgen_ty_3 = _bindgen_ty_3::GATE_TRAP;
pub const GATE_CALL: _bindgen_ty_3 = _bindgen_ty_3::GATE_CALL;
pub const GATE_TASK: _bindgen_ty_3 = _bindgen_ty_3::GATE_TASK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    GATE_INTERRUPT = 14,
    GATE_TRAP = 15,
    GATE_CALL = 12,
    GATE_TASK = 5,
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct gate_struct64 {
    pub offset_low: u16,
    pub segment: u16,
    pub _bitfield_1: [u8; 2usize],
    pub offset_middle: u16,
    pub offset_high: u32,
    pub zero1: u32,
}
#[test]
fn bindgen_test_layout_gate_struct64() {
    assert_eq!(::std::mem::size_of::<gate_struct64>() , 16usize , concat ! (
               "Size of: " , stringify ! ( gate_struct64 ) ));
    assert_eq! (::std::mem::align_of::<gate_struct64>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( gate_struct64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gate_struct64 ) ) . offset_low as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( gate_struct64 ) , "::"
                , stringify ! ( offset_low ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gate_struct64 ) ) . segment as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( gate_struct64 ) , "::"
                , stringify ! ( segment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gate_struct64 ) ) . offset_middle as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( gate_struct64 ) , "::"
                , stringify ! ( offset_middle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gate_struct64 ) ) . offset_high as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( gate_struct64 ) , "::"
                , stringify ! ( offset_high ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gate_struct64 ) ) . zero1 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( gate_struct64 ) , "::"
                , stringify ! ( zero1 ) ));
}
impl Clone for gate_struct64 {
    fn clone(&self) -> Self { *self }
}
impl gate_struct64 {
    #[inline]
    pub fn ist(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 7u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ist(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 7u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn zero0(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 248u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_zero0(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 248u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 7936u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 7936u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn dpl(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 24576u64 as u16;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 24576u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn p(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32768u64 as u16;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_p(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32768u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ist: ::std::os::raw::c_uint,
                          zero0: ::std::os::raw::c_uint,
                          type_: ::std::os::raw::c_uint,
                          dpl: ::std::os::raw::c_uint,
                          p: ::std::os::raw::c_uint) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({ 0 } |
                                 ((ist as u32 as u16) << 0usize) &
                                     (7u64 as u16))
                        } |
                            ((zero0 as u32 as u16) << 3usize) &
                                (248u64 as u16))
                   } | ((type_ as u32 as u16) << 8usize) & (7936u64 as u16))
              } | ((dpl as u32 as u16) << 13usize) & (24576u64 as u16))
         } | ((p as u32 as u16) << 15usize) & (32768u64 as u16))
    }
}
pub const DESC_TSS: _bindgen_ty_4 = _bindgen_ty_4::DESC_TSS;
pub const DESC_LDT: _bindgen_ty_4 = _bindgen_ty_4::DESC_LDT;
pub const DESCTYPE_S: _bindgen_ty_4 = _bindgen_ty_4::DESCTYPE_S;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 { DESC_TSS = 9, DESC_LDT = 2, DESCTYPE_S = 16, }
#[repr(C, packed)]
#[derive(Copy)]
pub struct ldttss_desc64 {
    pub limit0: u16,
    pub base0: u16,
    pub _bitfield_1: [u8; 4usize],
    pub base3: u32,
    pub zero1: u32,
}
#[test]
fn bindgen_test_layout_ldttss_desc64() {
    assert_eq!(::std::mem::size_of::<ldttss_desc64>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldttss_desc64 ) ));
    assert_eq! (::std::mem::align_of::<ldttss_desc64>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ldttss_desc64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldttss_desc64 ) ) . limit0 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldttss_desc64 ) , "::"
                , stringify ! ( limit0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldttss_desc64 ) ) . base0 as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ldttss_desc64 ) , "::"
                , stringify ! ( base0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldttss_desc64 ) ) . base3 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldttss_desc64 ) , "::"
                , stringify ! ( base3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldttss_desc64 ) ) . zero1 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ldttss_desc64 ) , "::"
                , stringify ! ( zero1 ) ));
}
impl Clone for ldttss_desc64 {
    fn clone(&self) -> Self { *self }
}
impl ldttss_desc64 {
    #[inline]
    pub fn base1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_base1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 7936u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 7936u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn dpl(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 24576u64 as u32;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 24576u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn p(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32768u64 as u32;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_p(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32768u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn limit1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 983040u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_limit1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 983040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn zero0(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 7340032u64 as u32;
        let val = (unit_field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_zero0(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 7340032u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 20usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn g(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 8388608u64 as u32;
        let val = (unit_field_val & mask) >> 23usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_g(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8388608u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 23usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn base2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_base2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(base1: ::std::os::raw::c_uint,
                          type_: ::std::os::raw::c_uint,
                          dpl: ::std::os::raw::c_uint,
                          p: ::std::os::raw::c_uint,
                          limit1: ::std::os::raw::c_uint,
                          zero0: ::std::os::raw::c_uint,
                          g: ::std::os::raw::c_uint,
                          base2: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({ 0 } |
                                                ((base1 as u32 as u32) <<
                                                     0usize) &
                                                    (255u64 as u32))
                                       } |
                                           ((type_ as u32 as u32) << 8usize) &
                                               (7936u64 as u32))
                                  } |
                                      ((dpl as u32 as u32) << 13usize) &
                                          (24576u64 as u32))
                             } |
                                 ((p as u32 as u32) << 15usize) &
                                     (32768u64 as u32))
                        } |
                            ((limit1 as u32 as u32) << 16usize) &
                                (983040u64 as u32))
                   } |
                       ((zero0 as u32 as u32) << 20usize) &
                           (7340032u64 as u32))
              } | ((g as u32 as u32) << 23usize) & (8388608u64 as u32))
         } | ((base2 as u32 as u32) << 24usize) & (4278190080u64 as u32))
    }
}
pub type gate_desc = gate_struct64;
pub type ldt_desc = ldttss_desc64;
pub type tss_desc = ldttss_desc64;
#[repr(C, packed)]
#[derive(Copy)]
pub struct desc_ptr {
    pub size: ::std::os::raw::c_ushort,
    pub address: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_desc_ptr() {
    assert_eq!(::std::mem::size_of::<desc_ptr>() , 10usize , concat ! (
               "Size of: " , stringify ! ( desc_ptr ) ));
    assert_eq! (::std::mem::align_of::<desc_ptr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( desc_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const desc_ptr ) ) . size as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( desc_ptr ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const desc_ptr ) ) . address as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( desc_ptr ) , "::" ,
                stringify ! ( address ) ));
}
impl Clone for desc_ptr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum page_cache_mode {
    _PAGE_CACHE_MODE_WB = 0,
    _PAGE_CACHE_MODE_WC = 1,
    _PAGE_CACHE_MODE_UC_MINUS = 2,
    _PAGE_CACHE_MODE_UC = 3,
    _PAGE_CACHE_MODE_WT = 4,
    _PAGE_CACHE_MODE_WP = 5,
    _PAGE_CACHE_MODE_NUM = 8,
}
pub type pteval_t = ::std::os::raw::c_ulong;
pub type pmdval_t = ::std::os::raw::c_ulong;
pub type pudval_t = ::std::os::raw::c_ulong;
pub type pgdval_t = ::std::os::raw::c_ulong;
pub type pgprotval_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct pte_t {
    pub pte: pteval_t,
}
#[test]
fn bindgen_test_layout_pte_t() {
    assert_eq!(::std::mem::size_of::<pte_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pte_t ) ));
    assert_eq! (::std::mem::align_of::<pte_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pte_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pte_t ) ) . pte as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( pte_t ) , "::" ,
                stringify ! ( pte ) ));
}
impl Clone for pte_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pgprot {
    pub pgprot: pgprotval_t,
}
#[test]
fn bindgen_test_layout_pgprot() {
    assert_eq!(::std::mem::size_of::<pgprot>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pgprot ) ));
    assert_eq! (::std::mem::align_of::<pgprot>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pgprot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgprot ) ) . pgprot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgprot ) , "::" ,
                stringify ! ( pgprot ) ));
}
impl Clone for pgprot {
    fn clone(&self) -> Self { *self }
}
pub type pgprot_t = pgprot;
#[repr(C)]
#[derive(Copy)]
pub struct pgd_t {
    pub pgd: pgdval_t,
}
#[test]
fn bindgen_test_layout_pgd_t() {
    assert_eq!(::std::mem::size_of::<pgd_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pgd_t ) ));
    assert_eq! (::std::mem::align_of::<pgd_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pgd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgd_t ) ) . pgd as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgd_t ) , "::" ,
                stringify ! ( pgd ) ));
}
impl Clone for pgd_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pud_t {
    pub pud: pudval_t,
}
#[test]
fn bindgen_test_layout_pud_t() {
    assert_eq!(::std::mem::size_of::<pud_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pud_t ) ));
    assert_eq! (::std::mem::align_of::<pud_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pud_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pud_t ) ) . pud as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( pud_t ) , "::" ,
                stringify ! ( pud ) ));
}
impl Clone for pud_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pmd_t {
    pub pmd: pmdval_t,
}
#[test]
fn bindgen_test_layout_pmd_t() {
    assert_eq!(::std::mem::size_of::<pmd_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pmd_t ) ));
    assert_eq! (::std::mem::align_of::<pmd_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmd_t ) ) . pmd as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( pmd_t ) , "::" ,
                stringify ! ( pmd ) ));
}
impl Clone for pmd_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "__cachemode2pte_tbl"]
    pub static mut __cachemode2pte_tbl: [u16; 8usize];
}
extern "C" {
    #[link_name = "__pte2cachemode_tbl"]
    pub static mut __pte2cachemode_tbl: [u8; 8usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page {
    _unused: [u8; 0],
}
pub type pgtable_t = *mut page;
extern "C" {
    #[link_name = "__supported_pte_mask"]
    pub static mut __supported_pte_mask: pteval_t;
}
extern "C" {
    pub fn set_nx();
}
extern "C" {
    #[link_name = "nx_enabled"]
    pub static mut nx_enabled: ::std::os::raw::c_int;
}
extern "C" {
    pub fn pgprot_writecombine(prot: pgprot_t) -> pgprot_t;
}
extern "C" {
    pub fn pgprot_writethrough(prot: pgprot_t) -> pgprot_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file {
    _unused: [u8; 0],
}
extern "C" {
    pub fn phys_mem_access_prot(file: *mut file, pfn: ::std::os::raw::c_ulong,
                                size: ::std::os::raw::c_ulong,
                                vma_prot: pgprot_t) -> pgprot_t;
}
extern "C" {
    pub fn phys_mem_access_prot_allowed(file: *mut file,
                                        pfn: ::std::os::raw::c_ulong,
                                        size: ::std::os::raw::c_ulong,
                                        vma_prot: *mut pgprot_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_pte_vaddr(vaddr: ::std::os::raw::c_ulong, pte: pte_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seq_file {
    _unused: [u8; 0],
}
extern "C" {
    pub fn arch_report_meminfo(m: *mut seq_file);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pg_level {
    PG_LEVEL_NONE = 0,
    PG_LEVEL_4K = 1,
    PG_LEVEL_2M = 2,
    PG_LEVEL_1G = 3,
    PG_LEVEL_NUM = 4,
}
extern "C" {
    pub fn update_page_count(level: ::std::os::raw::c_int,
                             pages: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn lookup_address(address: ::std::os::raw::c_ulong,
                          level: *mut ::std::os::raw::c_uint) -> *mut pte_t;
}
extern "C" {
    pub fn lookup_address_in_pgd(pgd: *mut pgd_t,
                                 address: ::std::os::raw::c_ulong,
                                 level: *mut ::std::os::raw::c_uint)
     -> *mut pte_t;
}
extern "C" {
    pub fn lookup_pmd_address(address: ::std::os::raw::c_ulong) -> *mut pmd_t;
}
extern "C" {
    pub fn slow_virt_to_phys(__address: *mut ::std::os::raw::c_void)
     -> phys_addr_t;
}
extern "C" {
    pub fn kernel_map_pages_in_pgd(pgd: *mut pgd_t, pfn: u64,
                                   address: ::std::os::raw::c_ulong,
                                   numpages: ::std::os::raw::c_uint,
                                   page_flags: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kernel_unmap_pages_in_pgd(root: *mut pgd_t,
                                     address: ::std::os::raw::c_ulong,
                                     numpages: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Copy)]
pub struct thread_struct {
    pub tls_array: [desc_struct; 3usize],
    pub sp0: ::std::os::raw::c_ulong,
    pub sp: ::std::os::raw::c_ulong,
    pub es: ::std::os::raw::c_ushort,
    pub ds: ::std::os::raw::c_ushort,
    pub fsindex: ::std::os::raw::c_ushort,
    pub gsindex: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ulong,
    pub gs: ::std::os::raw::c_ulong,
    pub ptrace_bps: [*mut perf_event; 4usize],
    pub debugreg6: ::std::os::raw::c_ulong,
    pub ptrace_dr7: ::std::os::raw::c_ulong,
    pub cr2: ::std::os::raw::c_ulong,
    pub trap_nr: ::std::os::raw::c_ulong,
    pub error_code: ::std::os::raw::c_ulong,
    pub io_bitmap_ptr: *mut ::std::os::raw::c_ulong,
    pub iopl: ::std::os::raw::c_ulong,
    pub io_bitmap_max: ::std::os::raw::c_uint,
    pub __bindgen_padding_0: [u64; 4usize],
    pub fpu: fpu,
}
#[test]
fn bindgen_test_layout_thread_struct() {
    assert_eq!(::std::mem::size_of::<thread_struct>() , 4352usize , concat ! (
               "Size of: " , stringify ! ( thread_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . tls_array as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( tls_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . sp0 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( sp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . sp as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . es as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . ds as * const _ as
                usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . fsindex as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( fsindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . gsindex as * const _
                as usize } , 46usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( gsindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . fs as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . gs as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . ptrace_bps as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( ptrace_bps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . debugreg6 as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( debugreg6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . ptrace_dr7 as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( ptrace_dr7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . cr2 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( cr2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . trap_nr as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( trap_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . error_code as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( error_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . io_bitmap_ptr as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( io_bitmap_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . iopl as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( iopl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . io_bitmap_max as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( io_bitmap_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_struct ) ) . fpu as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_struct ) , "::"
                , stringify ! ( fpu ) ));
}
impl Clone for thread_struct {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct tss_struct {
    pub x86_tss: x86_hw_tss,
    pub io_bitmap: [::std::os::raw::c_ulong; 1025usize],
    pub SYSENTER_stack: [::std::os::raw::c_ulong; 64usize],
    pub __bindgen_padding_0: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_tss_struct() {
    assert_eq!(::std::mem::size_of::<tss_struct>() , 8896usize , concat ! (
               "Size of: " , stringify ! ( tss_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tss_struct ) ) . x86_tss as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tss_struct ) , "::" ,
                stringify ! ( x86_tss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tss_struct ) ) . io_bitmap as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( tss_struct ) , "::" ,
                stringify ! ( io_bitmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tss_struct ) ) . SYSENTER_stack as *
                const _ as usize } , 8328usize , concat ! (
                "Alignment of field: " , stringify ! ( tss_struct ) , "::" ,
                stringify ! ( SYSENTER_stack ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mm_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct cpumask {
    pub bits: [::std::os::raw::c_ulong; 4usize],
}
#[test]
fn bindgen_test_layout_cpumask() {
    assert_eq!(::std::mem::size_of::<cpumask>() , 32usize , concat ! (
               "Size of: " , stringify ! ( cpumask ) ));
    assert_eq! (::std::mem::align_of::<cpumask>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpumask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpumask ) ) . bits as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpumask ) , "::" ,
                stringify ! ( bits ) ));
}
impl Clone for cpumask {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct paravirt_callee_save {
    pub func: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_paravirt_callee_save() {
    assert_eq!(::std::mem::size_of::<paravirt_callee_save>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( paravirt_callee_save ) ));
    assert_eq! (::std::mem::align_of::<paravirt_callee_save>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( paravirt_callee_save ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const paravirt_callee_save ) ) . func as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( paravirt_callee_save )
                , "::" , stringify ! ( func ) ));
}
impl Clone for paravirt_callee_save {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pv_info {
    pub kernel_rpl: ::std::os::raw::c_uint,
    pub shared_kernel_pmd: ::std::os::raw::c_int,
    pub extra_user_64bit_cs: u16,
    pub paravirt_enabled: ::std::os::raw::c_int,
    pub features: ::std::os::raw::c_uint,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pv_info() {
    assert_eq!(::std::mem::size_of::<pv_info>() , 32usize , concat ! (
               "Size of: " , stringify ! ( pv_info ) ));
    assert_eq! (::std::mem::align_of::<pv_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pv_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_info ) ) . kernel_rpl as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_info ) , "::" ,
                stringify ! ( kernel_rpl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_info ) ) . shared_kernel_pmd as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_info ) , "::" ,
                stringify ! ( shared_kernel_pmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_info ) ) . extra_user_64bit_cs as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_info ) , "::" ,
                stringify ! ( extra_user_64bit_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_info ) ) . paravirt_enabled as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_info ) , "::" ,
                stringify ! ( paravirt_enabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_info ) ) . features as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_info ) , "::" ,
                stringify ! ( features ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_info ) ) . name as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_info ) , "::" ,
                stringify ! ( name ) ));
}
impl Clone for pv_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pv_init_ops {
    pub patch: ::std::option::Option<unsafe extern "C" fn(type_: u8,
                                                          clobber: u16,
                                                          insnbuf:
                                                              *mut ::std::os::raw::c_void,
                                                          addr:
                                                              ::std::os::raw::c_ulong,
                                                          len:
                                                              ::std::os::raw::c_uint)
                                         -> ::std::os::raw::c_uint>,
}
#[test]
fn bindgen_test_layout_pv_init_ops() {
    assert_eq!(::std::mem::size_of::<pv_init_ops>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pv_init_ops ) ));
    assert_eq! (::std::mem::align_of::<pv_init_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pv_init_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_init_ops ) ) . patch as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_init_ops ) , "::" ,
                stringify ! ( patch ) ));
}
impl Clone for pv_init_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pv_lazy_ops {
    pub enter: ::std::option::Option<unsafe extern "C" fn()>,
    pub leave: ::std::option::Option<unsafe extern "C" fn()>,
    pub flush: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_pv_lazy_ops() {
    assert_eq!(::std::mem::size_of::<pv_lazy_ops>() , 24usize , concat ! (
               "Size of: " , stringify ! ( pv_lazy_ops ) ));
    assert_eq! (::std::mem::align_of::<pv_lazy_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pv_lazy_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_lazy_ops ) ) . enter as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_lazy_ops ) , "::" ,
                stringify ! ( enter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_lazy_ops ) ) . leave as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_lazy_ops ) , "::" ,
                stringify ! ( leave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_lazy_ops ) ) . flush as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_lazy_ops ) , "::" ,
                stringify ! ( flush ) ));
}
impl Clone for pv_lazy_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pv_time_ops {
    pub sched_clock: ::std::option::Option<unsafe extern "C" fn()
                                               ->
                                                   ::std::os::raw::c_ulonglong>,
    pub steal_clock: ::std::option::Option<unsafe extern "C" fn(cpu:
                                                                    ::std::os::raw::c_int)
                                               ->
                                                   ::std::os::raw::c_ulonglong>,
    pub get_tsc_khz: ::std::option::Option<unsafe extern "C" fn()
                                               -> ::std::os::raw::c_ulong>,
}
#[test]
fn bindgen_test_layout_pv_time_ops() {
    assert_eq!(::std::mem::size_of::<pv_time_ops>() , 24usize , concat ! (
               "Size of: " , stringify ! ( pv_time_ops ) ));
    assert_eq! (::std::mem::align_of::<pv_time_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pv_time_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_time_ops ) ) . sched_clock as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_time_ops ) , "::" ,
                stringify ! ( sched_clock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_time_ops ) ) . steal_clock as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_time_ops ) , "::" ,
                stringify ! ( steal_clock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_time_ops ) ) . get_tsc_khz as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_time_ops ) , "::" ,
                stringify ! ( get_tsc_khz ) ));
}
impl Clone for pv_time_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pv_cpu_ops {
    pub get_debugreg: ::std::option::Option<unsafe extern "C" fn(regno:
                                                                     ::std::os::raw::c_int)
                                                -> ::std::os::raw::c_ulong>,
    pub set_debugreg: ::std::option::Option<unsafe extern "C" fn(regno:
                                                                     ::std::os::raw::c_int,
                                                                 value:
                                                                     ::std::os::raw::c_ulong)>,
    pub clts: ::std::option::Option<unsafe extern "C" fn()>,
    pub read_cr0: ::std::option::Option<unsafe extern "C" fn()
                                            -> ::std::os::raw::c_ulong>,
    pub write_cr0: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  ::std::os::raw::c_ulong)>,
    pub read_cr4_safe: ::std::option::Option<unsafe extern "C" fn()
                                                 -> ::std::os::raw::c_ulong>,
    pub read_cr4: ::std::option::Option<unsafe extern "C" fn()
                                            -> ::std::os::raw::c_ulong>,
    pub write_cr4: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  ::std::os::raw::c_ulong)>,
    pub read_cr8: ::std::option::Option<unsafe extern "C" fn()
                                            -> ::std::os::raw::c_ulong>,
    pub write_cr8: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  ::std::os::raw::c_ulong)>,
    pub load_tr_desc: ::std::option::Option<unsafe extern "C" fn()>,
    pub load_gdt: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *const desc_ptr)>,
    pub load_idt: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *const desc_ptr)>,
    pub store_idt: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut desc_ptr)>,
    pub set_ldt: ::std::option::Option<unsafe extern "C" fn(desc:
                                                                *const ::std::os::raw::c_void,
                                                            entries:
                                                                ::std::os::raw::c_uint)>,
    pub store_tr: ::std::option::Option<unsafe extern "C" fn()
                                            -> ::std::os::raw::c_ulong>,
    pub load_tls: ::std::option::Option<unsafe extern "C" fn(t:
                                                                 *mut thread_struct,
                                                             cpu:
                                                                 ::std::os::raw::c_uint)>,
    pub load_gs_index: ::std::option::Option<unsafe extern "C" fn(idx:
                                                                      ::std::os::raw::c_uint)>,
    pub write_ldt_entry: ::std::option::Option<unsafe extern "C" fn(ldt:
                                                                        *mut desc_struct,
                                                                    entrynum:
                                                                        ::std::os::raw::c_int,
                                                                    desc:
                                                                        *const ::std::os::raw::c_void)>,
    pub write_gdt_entry: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut desc_struct,
                                                                    entrynum:
                                                                        ::std::os::raw::c_int,
                                                                    desc:
                                                                        *const ::std::os::raw::c_void,
                                                                    size:
                                                                        ::std::os::raw::c_int)>,
    pub write_idt_entry: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut gate_desc,
                                                                    entrynum:
                                                                        ::std::os::raw::c_int,
                                                                    gate:
                                                                        *const gate_desc)>,
    pub alloc_ldt: ::std::option::Option<unsafe extern "C" fn(ldt:
                                                                  *mut desc_struct,
                                                              entries:
                                                                  ::std::os::raw::c_uint)>,
    pub free_ldt: ::std::option::Option<unsafe extern "C" fn(ldt:
                                                                 *mut desc_struct,
                                                             entries:
                                                                 ::std::os::raw::c_uint)>,
    pub load_sp0: ::std::option::Option<unsafe extern "C" fn(tss:
                                                                 *mut tss_struct,
                                                             t:
                                                                 *mut thread_struct)>,
    pub set_iopl_mask: ::std::option::Option<unsafe extern "C" fn(mask:
                                                                      ::std::os::raw::c_uint)>,
    pub wbinvd: ::std::option::Option<unsafe extern "C" fn()>,
    pub io_delay: ::std::option::Option<unsafe extern "C" fn()>,
    pub cpuid: ::std::option::Option<unsafe extern "C" fn(eax:
                                                              *mut ::std::os::raw::c_uint,
                                                          ebx:
                                                              *mut ::std::os::raw::c_uint,
                                                          ecx:
                                                              *mut ::std::os::raw::c_uint,
                                                          edx:
                                                              *mut ::std::os::raw::c_uint)>,
    pub read_msr: ::std::option::Option<unsafe extern "C" fn(msr:
                                                                 ::std::os::raw::c_uint,
                                                             err:
                                                                 *mut ::std::os::raw::c_int)
                                            -> u64>,
    pub write_msr: ::std::option::Option<unsafe extern "C" fn(msr:
                                                                  ::std::os::raw::c_uint,
                                                              low:
                                                                  ::std::os::raw::c_uint,
                                                              high:
                                                                  ::std::os::raw::c_uint)
                                             -> ::std::os::raw::c_int>,
    pub read_tsc: ::std::option::Option<unsafe extern "C" fn() -> u64>,
    pub read_pmc: ::std::option::Option<unsafe extern "C" fn(counter:
                                                                 ::std::os::raw::c_int)
                                            -> u64>,
    pub read_tscp: ::std::option::Option<unsafe extern "C" fn(aux:
                                                                  *mut ::std::os::raw::c_uint)
                                             -> ::std::os::raw::c_ulonglong>,
    pub usergs_sysret64: ::std::option::Option<unsafe extern "C" fn()>,
    pub usergs_sysret32: ::std::option::Option<unsafe extern "C" fn()>,
    pub iret: ::std::option::Option<unsafe extern "C" fn()>,
    pub swapgs: ::std::option::Option<unsafe extern "C" fn()>,
    pub start_context_switch: ::std::option::Option<unsafe extern "C" fn(prev:
                                                                             *mut task_struct)>,
    pub end_context_switch: ::std::option::Option<unsafe extern "C" fn(next:
                                                                           *mut task_struct)>,
}
#[test]
fn bindgen_test_layout_pv_cpu_ops() {
    assert_eq!(::std::mem::size_of::<pv_cpu_ops>() , 312usize , concat ! (
               "Size of: " , stringify ! ( pv_cpu_ops ) ));
    assert_eq! (::std::mem::align_of::<pv_cpu_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pv_cpu_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . get_debugreg as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( get_debugreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . set_debugreg as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( set_debugreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . clts as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( clts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . read_cr0 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( read_cr0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . write_cr0 as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( write_cr0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . read_cr4_safe as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( read_cr4_safe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . read_cr4 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( read_cr4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . write_cr4 as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( write_cr4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . read_cr8 as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( read_cr8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . write_cr8 as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( write_cr8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . load_tr_desc as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( load_tr_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . load_gdt as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( load_gdt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . load_idt as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( load_idt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . store_idt as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( store_idt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . set_ldt as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( set_ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . store_tr as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( store_tr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . load_tls as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( load_tls ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . load_gs_index as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( load_gs_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . write_ldt_entry as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( write_ldt_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . write_gdt_entry as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( write_gdt_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . write_idt_entry as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( write_idt_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . alloc_ldt as * const _
                as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( alloc_ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . free_ldt as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( free_ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . load_sp0 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( load_sp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . set_iopl_mask as * const
                _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( set_iopl_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . wbinvd as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( wbinvd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . io_delay as * const _ as
                usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( io_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . cpuid as * const _ as
                usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( cpuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . read_msr as * const _ as
                usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( read_msr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . write_msr as * const _
                as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( write_msr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . read_tsc as * const _ as
                usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( read_tsc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . read_pmc as * const _ as
                usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( read_pmc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . read_tscp as * const _
                as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( read_tscp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . usergs_sysret64 as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( usergs_sysret64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . usergs_sysret32 as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( usergs_sysret32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . iret as * const _ as
                usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( iret ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . swapgs as * const _ as
                usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( swapgs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . start_context_switch as
                * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( start_context_switch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_cpu_ops ) ) . end_context_switch as *
                const _ as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_cpu_ops ) , "::" ,
                stringify ! ( end_context_switch ) ));
}
impl Clone for pv_cpu_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pv_irq_ops {
    pub save_fl: paravirt_callee_save,
    pub restore_fl: paravirt_callee_save,
    pub irq_disable: paravirt_callee_save,
    pub irq_enable: paravirt_callee_save,
    pub safe_halt: ::std::option::Option<unsafe extern "C" fn()>,
    pub halt: ::std::option::Option<unsafe extern "C" fn()>,
    pub adjust_exception_frame: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_pv_irq_ops() {
    assert_eq!(::std::mem::size_of::<pv_irq_ops>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pv_irq_ops ) ));
    assert_eq! (::std::mem::align_of::<pv_irq_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pv_irq_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_irq_ops ) ) . save_fl as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_irq_ops ) , "::" ,
                stringify ! ( save_fl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_irq_ops ) ) . restore_fl as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_irq_ops ) , "::" ,
                stringify ! ( restore_fl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_irq_ops ) ) . irq_disable as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_irq_ops ) , "::" ,
                stringify ! ( irq_disable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_irq_ops ) ) . irq_enable as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_irq_ops ) , "::" ,
                stringify ! ( irq_enable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_irq_ops ) ) . safe_halt as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_irq_ops ) , "::" ,
                stringify ! ( safe_halt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_irq_ops ) ) . halt as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_irq_ops ) , "::" ,
                stringify ! ( halt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_irq_ops ) ) . adjust_exception_frame
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_irq_ops ) , "::" ,
                stringify ! ( adjust_exception_frame ) ));
}
impl Clone for pv_irq_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pv_apic_ops {
    pub startup_ipi_hook: ::std::option::Option<unsafe extern "C" fn(phys_apicid:
                                                                         ::std::os::raw::c_int,
                                                                     start_eip:
                                                                         ::std::os::raw::c_ulong,
                                                                     start_esp:
                                                                         ::std::os::raw::c_ulong)>,
}
#[test]
fn bindgen_test_layout_pv_apic_ops() {
    assert_eq!(::std::mem::size_of::<pv_apic_ops>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pv_apic_ops ) ));
    assert_eq! (::std::mem::align_of::<pv_apic_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pv_apic_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_apic_ops ) ) . startup_ipi_hook as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_apic_ops ) , "::" ,
                stringify ! ( startup_ipi_hook ) ));
}
impl Clone for pv_apic_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pv_mmu_ops {
    pub read_cr2: ::std::option::Option<unsafe extern "C" fn()
                                            -> ::std::os::raw::c_ulong>,
    pub write_cr2: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  ::std::os::raw::c_ulong)>,
    pub read_cr3: ::std::option::Option<unsafe extern "C" fn()
                                            -> ::std::os::raw::c_ulong>,
    pub write_cr3: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  ::std::os::raw::c_ulong)>,
    pub activate_mm: ::std::option::Option<unsafe extern "C" fn(prev:
                                                                    *mut mm_struct,
                                                                next:
                                                                    *mut mm_struct)>,
    pub dup_mmap: ::std::option::Option<unsafe extern "C" fn(oldmm:
                                                                 *mut mm_struct,
                                                             mm:
                                                                 *mut mm_struct)>,
    pub exit_mmap: ::std::option::Option<unsafe extern "C" fn(mm:
                                                                  *mut mm_struct)>,
    pub flush_tlb_user: ::std::option::Option<unsafe extern "C" fn()>,
    pub flush_tlb_kernel: ::std::option::Option<unsafe extern "C" fn()>,
    pub flush_tlb_single: ::std::option::Option<unsafe extern "C" fn(addr:
                                                                         ::std::os::raw::c_ulong)>,
    pub flush_tlb_others: ::std::option::Option<unsafe extern "C" fn(cpus:
                                                                         *const cpumask,
                                                                     mm:
                                                                         *mut mm_struct,
                                                                     start:
                                                                         ::std::os::raw::c_ulong,
                                                                     end:
                                                                         ::std::os::raw::c_ulong)>,
    pub pgd_alloc: ::std::option::Option<unsafe extern "C" fn(mm:
                                                                  *mut mm_struct)
                                             -> ::std::os::raw::c_int>,
    pub pgd_free: ::std::option::Option<unsafe extern "C" fn(mm:
                                                                 *mut mm_struct,
                                                             pgd:
                                                                 *mut pgd_t)>,
    pub alloc_pte: ::std::option::Option<unsafe extern "C" fn(mm:
                                                                  *mut mm_struct,
                                                              pfn:
                                                                  ::std::os::raw::c_ulong)>,
    pub alloc_pmd: ::std::option::Option<unsafe extern "C" fn(mm:
                                                                  *mut mm_struct,
                                                              pfn:
                                                                  ::std::os::raw::c_ulong)>,
    pub alloc_pud: ::std::option::Option<unsafe extern "C" fn(mm:
                                                                  *mut mm_struct,
                                                              pfn:
                                                                  ::std::os::raw::c_ulong)>,
    pub release_pte: ::std::option::Option<unsafe extern "C" fn(pfn:
                                                                    ::std::os::raw::c_ulong)>,
    pub release_pmd: ::std::option::Option<unsafe extern "C" fn(pfn:
                                                                    ::std::os::raw::c_ulong)>,
    pub release_pud: ::std::option::Option<unsafe extern "C" fn(pfn:
                                                                    ::std::os::raw::c_ulong)>,
    pub set_pte: ::std::option::Option<unsafe extern "C" fn(ptep: *mut pte_t,
                                                            pteval: pte_t)>,
    pub set_pte_at: ::std::option::Option<unsafe extern "C" fn(mm:
                                                                   *mut mm_struct,
                                                               addr:
                                                                   ::std::os::raw::c_ulong,
                                                               ptep:
                                                                   *mut pte_t,
                                                               pteval:
                                                                   pte_t)>,
    pub set_pmd: ::std::option::Option<unsafe extern "C" fn(pmdp: *mut pmd_t,
                                                            pmdval: pmd_t)>,
    pub set_pmd_at: ::std::option::Option<unsafe extern "C" fn(mm:
                                                                   *mut mm_struct,
                                                               addr:
                                                                   ::std::os::raw::c_ulong,
                                                               pmdp:
                                                                   *mut pmd_t,
                                                               pmdval:
                                                                   pmd_t)>,
    pub pte_update: ::std::option::Option<unsafe extern "C" fn(mm:
                                                                   *mut mm_struct,
                                                               addr:
                                                                   ::std::os::raw::c_ulong,
                                                               ptep:
                                                                   *mut pte_t)>,
    pub pte_update_defer: ::std::option::Option<unsafe extern "C" fn(mm:
                                                                         *mut mm_struct,
                                                                     addr:
                                                                         ::std::os::raw::c_ulong,
                                                                     ptep:
                                                                         *mut pte_t)>,
    pub pmd_update: ::std::option::Option<unsafe extern "C" fn(mm:
                                                                   *mut mm_struct,
                                                               addr:
                                                                   ::std::os::raw::c_ulong,
                                                               pmdp:
                                                                   *mut pmd_t)>,
    pub pmd_update_defer: ::std::option::Option<unsafe extern "C" fn(mm:
                                                                         *mut mm_struct,
                                                                     addr:
                                                                         ::std::os::raw::c_ulong,
                                                                     pmdp:
                                                                         *mut pmd_t)>,
    pub ptep_modify_prot_start: ::std::option::Option<unsafe extern "C" fn(mm:
                                                                               *mut mm_struct,
                                                                           addr:
                                                                               ::std::os::raw::c_ulong,
                                                                           ptep:
                                                                               *mut pte_t)
                                                          -> pte_t>,
    pub ptep_modify_prot_commit: ::std::option::Option<unsafe extern "C" fn(mm:
                                                                                *mut mm_struct,
                                                                            addr:
                                                                                ::std::os::raw::c_ulong,
                                                                            ptep:
                                                                                *mut pte_t,
                                                                            pte:
                                                                                pte_t)>,
    pub pte_val: paravirt_callee_save,
    pub make_pte: paravirt_callee_save,
    pub pgd_val: paravirt_callee_save,
    pub make_pgd: paravirt_callee_save,
    pub set_pud: ::std::option::Option<unsafe extern "C" fn(pudp: *mut pud_t,
                                                            pudval: pud_t)>,
    pub pmd_val: paravirt_callee_save,
    pub make_pmd: paravirt_callee_save,
    pub pud_val: paravirt_callee_save,
    pub make_pud: paravirt_callee_save,
    pub set_pgd: ::std::option::Option<unsafe extern "C" fn(pudp: *mut pgd_t,
                                                            pgdval: pgd_t)>,
    pub lazy_mode: pv_lazy_ops,
    pub set_fixmap: ::std::option::Option<unsafe extern "C" fn(idx:
                                                                   ::std::os::raw::c_uint,
                                                               phys:
                                                                   phys_addr_t,
                                                               flags:
                                                                   pgprot_t)>,
}
#[test]
fn bindgen_test_layout_pv_mmu_ops() {
    assert_eq!(::std::mem::size_of::<pv_mmu_ops>() , 344usize , concat ! (
               "Size of: " , stringify ! ( pv_mmu_ops ) ));
    assert_eq! (::std::mem::align_of::<pv_mmu_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pv_mmu_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . read_cr2 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( read_cr2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . write_cr2 as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( write_cr2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . read_cr3 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( read_cr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . write_cr3 as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( write_cr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . activate_mm as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( activate_mm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . dup_mmap as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( dup_mmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . exit_mmap as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( exit_mmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . flush_tlb_user as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( flush_tlb_user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . flush_tlb_kernel as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( flush_tlb_kernel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . flush_tlb_single as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( flush_tlb_single ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . flush_tlb_others as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( flush_tlb_others ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . pgd_alloc as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( pgd_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . pgd_free as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( pgd_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . alloc_pte as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( alloc_pte ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . alloc_pmd as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( alloc_pmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . alloc_pud as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( alloc_pud ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . release_pte as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( release_pte ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . release_pmd as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( release_pmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . release_pud as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( release_pud ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . set_pte as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( set_pte ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . set_pte_at as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( set_pte_at ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . set_pmd as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( set_pmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . set_pmd_at as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( set_pmd_at ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . pte_update as * const _
                as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( pte_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . pte_update_defer as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( pte_update_defer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . pmd_update as * const _
                as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( pmd_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . pmd_update_defer as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( pmd_update_defer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . ptep_modify_prot_start
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( ptep_modify_prot_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . ptep_modify_prot_commit
                as * const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( ptep_modify_prot_commit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . pte_val as * const _ as
                usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( pte_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . make_pte as * const _ as
                usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( make_pte ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . pgd_val as * const _ as
                usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( pgd_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . make_pgd as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( make_pgd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . set_pud as * const _ as
                usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( set_pud ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . pmd_val as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( pmd_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . make_pmd as * const _ as
                usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( make_pmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . pud_val as * const _ as
                usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( pud_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . make_pud as * const _ as
                usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( make_pud ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . set_pgd as * const _ as
                usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( set_pgd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . lazy_mode as * const _
                as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( lazy_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_mmu_ops ) ) . set_fixmap as * const _
                as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_mmu_ops ) , "::" ,
                stringify ! ( set_fixmap ) ));
}
impl Clone for pv_mmu_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_spinlock {
    _unused: [u8; 0],
}
pub type __ticket_t = u16;
pub type __ticketpair_t = u32;
#[repr(C)]
#[derive(Copy)]
pub struct qspinlock {
    pub val: atomic_t,
}
#[test]
fn bindgen_test_layout_qspinlock() {
    assert_eq!(::std::mem::size_of::<qspinlock>() , 4usize , concat ! (
               "Size of: " , stringify ! ( qspinlock ) ));
    assert_eq! (::std::mem::align_of::<qspinlock>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( qspinlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const qspinlock ) ) . val as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( qspinlock ) , "::" ,
                stringify ! ( val ) ));
}
impl Clone for qspinlock {
    fn clone(&self) -> Self { *self }
}
pub type arch_spinlock_t = qspinlock;
#[repr(C)]
#[derive(Copy)]
pub struct qrwlock {
    pub cnts: atomic_t,
    pub lock: arch_spinlock_t,
}
#[test]
fn bindgen_test_layout_qrwlock() {
    assert_eq!(::std::mem::size_of::<qrwlock>() , 8usize , concat ! (
               "Size of: " , stringify ! ( qrwlock ) ));
    assert_eq! (::std::mem::align_of::<qrwlock>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( qrwlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const qrwlock ) ) . cnts as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( qrwlock ) , "::" ,
                stringify ! ( cnts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const qrwlock ) ) . lock as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( qrwlock ) , "::" ,
                stringify ! ( lock ) ));
}
impl Clone for qrwlock {
    fn clone(&self) -> Self { *self }
}
pub type arch_rwlock_t = qrwlock;
#[repr(C)]
#[derive(Copy)]
pub struct pv_lock_ops {
    pub queued_spin_lock_slowpath: ::std::option::Option<unsafe extern "C" fn(lock:
                                                                                  *mut qspinlock,
                                                                              val:
                                                                                  u32)>,
    pub queued_spin_unlock: paravirt_callee_save,
    pub wait: ::std::option::Option<unsafe extern "C" fn(ptr: *mut u8,
                                                         val: u8)>,
    pub kick: ::std::option::Option<unsafe extern "C" fn(cpu:
                                                             ::std::os::raw::c_int)>,
}
#[test]
fn bindgen_test_layout_pv_lock_ops() {
    assert_eq!(::std::mem::size_of::<pv_lock_ops>() , 32usize , concat ! (
               "Size of: " , stringify ! ( pv_lock_ops ) ));
    assert_eq! (::std::mem::align_of::<pv_lock_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pv_lock_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_lock_ops ) ) .
                queued_spin_lock_slowpath as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( pv_lock_ops ) , "::" ,
                stringify ! ( queued_spin_lock_slowpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_lock_ops ) ) . queued_spin_unlock as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_lock_ops ) , "::" ,
                stringify ! ( queued_spin_unlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_lock_ops ) ) . wait as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_lock_ops ) , "::" ,
                stringify ! ( wait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_lock_ops ) ) . kick as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_lock_ops ) , "::" ,
                stringify ! ( kick ) ));
}
impl Clone for pv_lock_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct paravirt_patch_template {
    pub pv_init_ops: pv_init_ops,
    pub pv_time_ops: pv_time_ops,
    pub pv_cpu_ops: pv_cpu_ops,
    pub pv_irq_ops: pv_irq_ops,
    pub pv_apic_ops: pv_apic_ops,
    pub pv_mmu_ops: pv_mmu_ops,
    pub pv_lock_ops: pv_lock_ops,
}
#[test]
fn bindgen_test_layout_paravirt_patch_template() {
    assert_eq!(::std::mem::size_of::<paravirt_patch_template>() , 784usize ,
               concat ! (
               "Size of: " , stringify ! ( paravirt_patch_template ) ));
    assert_eq! (::std::mem::align_of::<paravirt_patch_template>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( paravirt_patch_template ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const paravirt_patch_template ) ) . pv_init_ops
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( paravirt_patch_template
                ) , "::" , stringify ! ( pv_init_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const paravirt_patch_template ) ) . pv_time_ops
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( paravirt_patch_template
                ) , "::" , stringify ! ( pv_time_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const paravirt_patch_template ) ) . pv_cpu_ops
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( paravirt_patch_template
                ) , "::" , stringify ! ( pv_cpu_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const paravirt_patch_template ) ) . pv_irq_ops
                as * const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( paravirt_patch_template
                ) , "::" , stringify ! ( pv_irq_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const paravirt_patch_template ) ) . pv_apic_ops
                as * const _ as usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( paravirt_patch_template
                ) , "::" , stringify ! ( pv_apic_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const paravirt_patch_template ) ) . pv_mmu_ops
                as * const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( paravirt_patch_template
                ) , "::" , stringify ! ( pv_mmu_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const paravirt_patch_template ) ) . pv_lock_ops
                as * const _ as usize } , 752usize , concat ! (
                "Alignment of field: " , stringify ! ( paravirt_patch_template
                ) , "::" , stringify ! ( pv_lock_ops ) ));
}
impl Clone for paravirt_patch_template {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "pv_info"]
    pub static mut pv_info: pv_info;
}
extern "C" {
    #[link_name = "pv_init_ops"]
    pub static mut pv_init_ops: pv_init_ops;
}
extern "C" {
    #[link_name = "pv_time_ops"]
    pub static mut pv_time_ops: pv_time_ops;
}
extern "C" {
    #[link_name = "pv_cpu_ops"]
    pub static mut pv_cpu_ops: pv_cpu_ops;
}
extern "C" {
    #[link_name = "pv_irq_ops"]
    pub static mut pv_irq_ops: pv_irq_ops;
}
extern "C" {
    #[link_name = "pv_apic_ops"]
    pub static mut pv_apic_ops: pv_apic_ops;
}
extern "C" {
    #[link_name = "pv_mmu_ops"]
    pub static mut pv_mmu_ops: pv_mmu_ops;
}
extern "C" {
    #[link_name = "pv_lock_ops"]
    pub static mut pv_lock_ops: pv_lock_ops;
}
extern "C" {
    pub fn paravirt_patch_nop() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_patch_ident_32(insnbuf: *mut ::std::os::raw::c_void,
                                   len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_patch_ident_64(insnbuf: *mut ::std::os::raw::c_void,
                                   len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_patch_ignore(len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_patch_call(insnbuf: *mut ::std::os::raw::c_void,
                               target: *const ::std::os::raw::c_void,
                               tgt_clobbers: u16,
                               addr: ::std::os::raw::c_ulong,
                               site_clobbers: u16,
                               len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_patch_jmp(insnbuf: *mut ::std::os::raw::c_void,
                              target: *const ::std::os::raw::c_void,
                              addr: ::std::os::raw::c_ulong,
                              len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_patch_default(type_: u8, clobbers: u16,
                                  insnbuf: *mut ::std::os::raw::c_void,
                                  addr: ::std::os::raw::c_ulong,
                                  len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_patch_insns(insnbuf: *mut ::std::os::raw::c_void,
                                len: ::std::os::raw::c_uint,
                                start: *const ::std::os::raw::c_char,
                                end: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn native_patch(type_: u8, clobbers: u16,
                        ibuf: *mut ::std::os::raw::c_void,
                        addr: ::std::os::raw::c_ulong,
                        len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_disable_iospace() -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum paravirt_lazy_mode {
    PARAVIRT_LAZY_NONE = 0,
    PARAVIRT_LAZY_MMU = 1,
    PARAVIRT_LAZY_CPU = 2,
}
extern "C" {
    pub fn paravirt_get_lazy_mode() -> paravirt_lazy_mode;
}
extern "C" {
    pub fn paravirt_start_context_switch(prev: *mut task_struct);
}
extern "C" {
    pub fn paravirt_end_context_switch(next: *mut task_struct);
}
extern "C" {
    pub fn paravirt_enter_lazy_mmu();
}
extern "C" {
    pub fn paravirt_leave_lazy_mmu();
}
extern "C" {
    pub fn paravirt_flush_lazy_mmu();
}
extern "C" {
    pub fn _paravirt_nop();
}
extern "C" {
    pub fn _paravirt_ident_32(arg1: u32) -> u32;
}
extern "C" {
    pub fn _paravirt_ident_64(arg1: u64) -> u64;
}
#[repr(C)]
#[derive(Copy)]
pub struct paravirt_patch_site {
    pub instr: *mut u8,
    pub instrtype: u8,
    pub len: u8,
    pub clobbers: u16,
}
#[test]
fn bindgen_test_layout_paravirt_patch_site() {
    assert_eq!(::std::mem::size_of::<paravirt_patch_site>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( paravirt_patch_site ) ));
    assert_eq! (::std::mem::align_of::<paravirt_patch_site>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( paravirt_patch_site ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const paravirt_patch_site ) ) . instr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( paravirt_patch_site ) ,
                "::" , stringify ! ( instr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const paravirt_patch_site ) ) . instrtype as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( paravirt_patch_site ) ,
                "::" , stringify ! ( instrtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const paravirt_patch_site ) ) . len as * const
                _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( paravirt_patch_site ) ,
                "::" , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const paravirt_patch_site ) ) . clobbers as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( paravirt_patch_site ) ,
                "::" , stringify ! ( clobbers ) ));
}
impl Clone for paravirt_patch_site {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "__parainstructions"]
    pub static mut __parainstructions: [paravirt_patch_site; 0usize];
}
extern "C" {
    #[link_name = "__parainstructions_end"]
    pub static mut __parainstructions_end: [paravirt_patch_site; 0usize];
}
#[repr(C)]
pub struct cpuinfo_x86 {
    pub x86: __u8,
    pub x86_vendor: __u8,
    pub x86_model: __u8,
    pub x86_mask: __u8,
    pub x86_tlbsize: ::std::os::raw::c_int,
    pub x86_virt_bits: __u8,
    pub x86_phys_bits: __u8,
    pub x86_coreid_bits: __u8,
    pub extended_cpuid_level: __u32,
    pub cpuid_level: ::std::os::raw::c_int,
    pub x86_capability: [__u32; 14usize],
    pub x86_vendor_id: [::std::os::raw::c_char; 16usize],
    pub x86_model_id: [::std::os::raw::c_char; 64usize],
    pub x86_cache_size: ::std::os::raw::c_int,
    pub x86_cache_alignment: ::std::os::raw::c_int,
    pub x86_cache_max_rmid: ::std::os::raw::c_int,
    pub x86_cache_occ_scale: ::std::os::raw::c_int,
    pub x86_power: ::std::os::raw::c_int,
    pub loops_per_jiffy: ::std::os::raw::c_ulong,
    pub x86_max_cores: u16,
    pub apicid: u16,
    pub initial_apicid: u16,
    pub x86_clflush_size: u16,
    pub booted_cores: u16,
    pub phys_proc_id: u16,
    pub cpu_core_id: u16,
    pub compute_unit_id: u8,
    pub cpu_index: u16,
    pub microcode: u32,
}
#[test]
fn bindgen_test_layout_cpuinfo_x86() {
    assert_eq!(::std::mem::size_of::<cpuinfo_x86>() , 208usize , concat ! (
               "Size of: " , stringify ! ( cpuinfo_x86 ) ));
    assert_eq! (::std::mem::align_of::<cpuinfo_x86>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpuinfo_x86 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_vendor as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_vendor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_model as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_model ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_mask as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_tlbsize as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_tlbsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_virt_bits as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_virt_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_phys_bits as *
                const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_phys_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_coreid_bits as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_coreid_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . extended_cpuid_level as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( extended_cpuid_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . cpuid_level as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( cpuid_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_capability as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_capability ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_vendor_id as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_vendor_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_model_id as * const
                _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_model_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_cache_size as *
                const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_cache_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_cache_alignment as
                * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_cache_alignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_cache_max_rmid as *
                const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_cache_max_rmid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_cache_occ_scale as
                * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_cache_occ_scale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_power as * const _
                as usize } , 172usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_power ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . loops_per_jiffy as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( loops_per_jiffy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_max_cores as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_max_cores ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . apicid as * const _ as
                usize } , 186usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( apicid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . initial_apicid as *
                const _ as usize } , 188usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( initial_apicid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . x86_clflush_size as *
                const _ as usize } , 190usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( x86_clflush_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . booted_cores as * const
                _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( booted_cores ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . phys_proc_id as * const
                _ as usize } , 194usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( phys_proc_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . cpu_core_id as * const
                _ as usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( cpu_core_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . compute_unit_id as *
                const _ as usize } , 198usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( compute_unit_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . cpu_index as * const _
                as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( cpu_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuinfo_x86 ) ) . microcode as * const _
                as usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuinfo_x86 ) , "::" ,
                stringify ! ( microcode ) ));
}
extern "C" {
    pub fn profile_pc(regs: *mut pt_regs) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn convert_ip_to_linear(child: *mut task_struct, regs: *mut pt_regs)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn send_sigtrap(tsk: *mut task_struct, regs: *mut pt_regs,
                        error_code: ::std::os::raw::c_int,
                        si_code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn syscall_trace_enter_phase1(arg1: *mut pt_regs, arch: u32)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn syscall_trace_enter_phase2(arg1: *mut pt_regs, arch: u32,
                                      phase1_result: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn syscall_trace_enter(arg1: *mut pt_regs) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn syscall_trace_leave(arg1: *mut pt_regs);
}
extern "C" {
    pub fn regs_query_register_offset(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regs_query_register_name(offset: ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_desc {
    _unused: [u8; 0],
}
extern "C" {
    pub fn do_get_thread_area(p: *mut task_struct, idx: ::std::os::raw::c_int,
                              info: *mut user_desc) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_set_thread_area(p: *mut task_struct, idx: ::std::os::raw::c_int,
                              info: *mut user_desc,
                              can_allocate: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct alt_instr {
    pub instr_offset: s32,
    pub repl_offset: s32,
    pub cpuid: u16,
    pub instrlen: u8,
    pub replacementlen: u8,
    pub padlen: u8,
}
#[test]
fn bindgen_test_layout_alt_instr() {
    assert_eq!(::std::mem::size_of::<alt_instr>() , 13usize , concat ! (
               "Size of: " , stringify ! ( alt_instr ) ));
    assert_eq! (::std::mem::align_of::<alt_instr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( alt_instr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alt_instr ) ) . instr_offset as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( alt_instr ) , "::" ,
                stringify ! ( instr_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alt_instr ) ) . repl_offset as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( alt_instr ) , "::" ,
                stringify ! ( repl_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alt_instr ) ) . cpuid as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( alt_instr ) , "::" ,
                stringify ! ( cpuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alt_instr ) ) . instrlen as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( alt_instr ) , "::" ,
                stringify ! ( instrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alt_instr ) ) . replacementlen as * const
                _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( alt_instr ) , "::" ,
                stringify ! ( replacementlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const alt_instr ) ) . padlen as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( alt_instr ) , "::" ,
                stringify ! ( padlen ) ));
}
impl Clone for alt_instr {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "alternatives_patched"]
    pub static mut alternatives_patched: ::std::os::raw::c_int;
}
extern "C" {
    pub fn alternative_instructions();
}
extern "C" {
    pub fn apply_alternatives(start: *mut alt_instr, end: *mut alt_instr);
}
extern "C" {
    pub fn alternatives_smp_module_add(mod_: *mut module,
                                       name: *mut ::std::os::raw::c_char,
                                       locks: *mut ::std::os::raw::c_void,
                                       locks_end: *mut ::std::os::raw::c_void,
                                       text: *mut ::std::os::raw::c_void,
                                       text_end: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alternatives_smp_module_del(mod_: *mut module);
}
extern "C" {
    pub fn alternatives_enable_smp();
}
extern "C" {
    pub fn alternatives_text_reserved(start: *mut ::std::os::raw::c_void,
                                      end: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "skip_smp_alternatives"]
    pub static mut skip_smp_alternatives: bool_;
}
extern "C" {
    #[link_name = "x86_cap_flags"]
    pub static mut x86_cap_flags: [*const ::std::os::raw::c_char; 416usize];
}
extern "C" {
    #[link_name = "x86_power_flags"]
    pub static mut x86_power_flags: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    #[link_name = "x86_bug_flags"]
    pub static mut x86_bug_flags: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub fn warn_pre_alternatives();
}
extern "C" {
    pub fn __static_cpu_has_safe(bit: u16) -> bool_;
}
extern "C" {
    pub fn apply_paravirt(start: *mut paravirt_patch_site,
                          end: *mut paravirt_patch_site);
}
extern "C" {
    pub fn text_poke_early(addr: *mut ::std::os::raw::c_void,
                           opcode: *const ::std::os::raw::c_void, len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn text_poke(addr: *mut ::std::os::raw::c_void,
                     opcode: *const ::std::os::raw::c_void, len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn poke_int3_handler(regs: *mut pt_regs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn text_poke_bp(addr: *mut ::std::os::raw::c_void,
                        opcode: *const ::std::os::raw::c_void, len: usize,
                        handler: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "ideal_nops"]
    pub static mut ideal_nops: *const *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn arch_init_ideal_nops();
}
extern "C" {
    /// find_next_bit - find the next set bit in a memory region
/// @addr: The address to base the search on
/// @offset: The bitnumber to start searching at
/// @size: The bitmap size in bits
///
/// Returns the bit number for the next set bit
/// If no bits are set, returns @size.
    pub fn find_next_bit(addr: *const ::std::os::raw::c_ulong,
                         size: ::std::os::raw::c_ulong,
                         offset: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    /// find_next_zero_bit - find the next cleared bit in a memory region
/// @addr: The address to base the search on
/// @offset: The bitnumber to start searching at
/// @size: The bitmap size in bits
///
/// Returns the bit number of the next zero bit
/// If no bits are zero, returns @size.
    pub fn find_next_zero_bit(addr: *const ::std::os::raw::c_ulong,
                              size: ::std::os::raw::c_ulong,
                              offset: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    /// find_first_bit - find the first set bit in a memory region
/// @addr: The address to start the search at
/// @size: The maximum number of bits to search
///
/// Returns the bit number of the first set bit.
/// If no bits are set, returns @size.
    pub fn find_first_bit(addr: *const ::std::os::raw::c_ulong,
                          size: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    /// find_first_zero_bit - find the first cleared bit in a memory region
/// @addr: The address to start the search at
/// @size: The maximum number of bits to search
///
/// Returns the bit number of the first cleared bit.
/// If no bits are zero, returns @size.
    pub fn find_first_zero_bit(addr: *const ::std::os::raw::c_ulong,
                               size: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    /// find_last_bit - find the last set bit in a memory region
/// @addr: The address to start the search at
/// @size: The number of bits to search
///
/// Returns the bit number of the last set bit, or size.
    pub fn find_last_bit(addr: *const ::std::os::raw::c_ulong,
                         size: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ____ilog2_NaN() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct completion {
    pub done: ::std::os::raw::c_uint,
    pub wait: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_completion() {
    assert_eq!(::std::mem::size_of::<completion>() , 32usize , concat ! (
               "Size of: " , stringify ! ( completion ) ));
    assert_eq! (::std::mem::align_of::<completion>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( completion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const completion ) ) . done as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( completion ) , "::" ,
                stringify ! ( done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const completion ) ) . wait as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( completion ) , "::" ,
                stringify ! ( wait ) ));
}
impl Clone for completion {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user {
    _unused: [u8; 0],
}
extern "C" {
    pub fn _cond_resched() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct atomic_notifier_head {
    pub lock: spinlock_t,
    pub head: *mut notifier_block,
}
#[test]
fn bindgen_test_layout_atomic_notifier_head() {
    assert_eq!(::std::mem::size_of::<atomic_notifier_head>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( atomic_notifier_head )
               ));
    assert_eq! (::std::mem::align_of::<atomic_notifier_head>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( atomic_notifier_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const atomic_notifier_head ) ) . lock as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( atomic_notifier_head )
                , "::" , stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const atomic_notifier_head ) ) . head as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( atomic_notifier_head )
                , "::" , stringify ! ( head ) ));
}
impl Clone for atomic_notifier_head {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "panic_notifier_list"]
    pub static mut panic_notifier_list: atomic_notifier_head;
}
extern "C" {
    #[link_name = "panic_blink"]
    pub static mut panic_blink:
               ::std::option::Option<unsafe extern "C" fn(state:
                                                              ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_long>;
}
extern "C" {
    pub fn panic(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn oops_enter();
}
extern "C" {
    pub fn oops_exit();
}
extern "C" {
    pub fn print_oops_end_marker();
}
extern "C" {
    pub fn oops_may_print() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_exit(error_code: ::std::os::raw::c_long);
}
extern "C" {
    pub fn complete_and_exit(arg1: *mut completion,
                             arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn _kstrtoul(s: *const ::std::os::raw::c_char,
                     base: ::std::os::raw::c_uint,
                     res: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _kstrtol(s: *const ::std::os::raw::c_char,
                    base: ::std::os::raw::c_uint,
                    res: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoull(s: *const ::std::os::raw::c_char,
                     base: ::std::os::raw::c_uint,
                     res: *mut ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoll(s: *const ::std::os::raw::c_char,
                    base: ::std::os::raw::c_uint,
                    res: *mut ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtouint(s: *const ::std::os::raw::c_char,
                      base: ::std::os::raw::c_uint,
                      res: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoint(s: *const ::std::os::raw::c_char,
                     base: ::std::os::raw::c_uint,
                     res: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou16(s: *const ::std::os::raw::c_char,
                     base: ::std::os::raw::c_uint, res: *mut u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos16(s: *const ::std::os::raw::c_char,
                     base: ::std::os::raw::c_uint, res: *mut s16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou8(s: *const ::std::os::raw::c_char,
                    base: ::std::os::raw::c_uint, res: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos8(s: *const ::std::os::raw::c_char,
                    base: ::std::os::raw::c_uint, res: *mut s8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoull_from_user(s: *const ::std::os::raw::c_char, count: usize,
                               base: ::std::os::raw::c_uint,
                               res: *mut ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoll_from_user(s: *const ::std::os::raw::c_char, count: usize,
                              base: ::std::os::raw::c_uint,
                              res: *mut ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoul_from_user(s: *const ::std::os::raw::c_char, count: usize,
                              base: ::std::os::raw::c_uint,
                              res: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtol_from_user(s: *const ::std::os::raw::c_char, count: usize,
                             base: ::std::os::raw::c_uint,
                             res: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtouint_from_user(s: *const ::std::os::raw::c_char,
                                count: usize, base: ::std::os::raw::c_uint,
                                res: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoint_from_user(s: *const ::std::os::raw::c_char, count: usize,
                               base: ::std::os::raw::c_uint,
                               res: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou16_from_user(s: *const ::std::os::raw::c_char, count: usize,
                               base: ::std::os::raw::c_uint, res: *mut u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos16_from_user(s: *const ::std::os::raw::c_char, count: usize,
                               base: ::std::os::raw::c_uint, res: *mut s16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou8_from_user(s: *const ::std::os::raw::c_char, count: usize,
                              base: ::std::os::raw::c_uint, res: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos8_from_user(s: *const ::std::os::raw::c_char, count: usize,
                              base: ::std::os::raw::c_uint, res: *mut s8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_strtoul(arg1: *const ::std::os::raw::c_char,
                          arg2: *mut *mut ::std::os::raw::c_char,
                          arg3: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn simple_strtol(arg1: *const ::std::os::raw::c_char,
                         arg2: *mut *mut ::std::os::raw::c_char,
                         arg3: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn simple_strtoull(arg1: *const ::std::os::raw::c_char,
                           arg2: *mut *mut ::std::os::raw::c_char,
                           arg3: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn simple_strtoll(arg1: *const ::std::os::raw::c_char,
                          arg2: *mut *mut ::std::os::raw::c_char,
                          arg3: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn num_to_str(buf: *mut ::std::os::raw::c_char,
                      size: ::std::os::raw::c_int,
                      num: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(buf: *mut ::std::os::raw::c_char,
                   fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(buf: *mut ::std::os::raw::c_char,
                    arg1: *const ::std::os::raw::c_char,
                    arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(buf: *mut ::std::os::raw::c_char, size: usize,
                    fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(buf: *mut ::std::os::raw::c_char, size: usize,
                     fmt: *const ::std::os::raw::c_char,
                     args: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scnprintf(buf: *mut ::std::os::raw::c_char, size: usize,
                     fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscnprintf(buf: *mut ::std::os::raw::c_char, size: usize,
                      fmt: *const ::std::os::raw::c_char,
                      args: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kasprintf(gfp: gfp_t, fmt: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kvasprintf(gfp: gfp_t, fmt: *const ::std::os::raw::c_char,
                      args: *mut __va_list_tag)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_option(str: *mut *mut ::std::os::raw::c_char,
                      pint: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_options(str: *const ::std::os::raw::c_char,
                       nints: ::std::os::raw::c_int,
                       ints: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memparse(ptr: *const ::std::os::raw::c_char,
                    retptr: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn parse_option_str(str: *const ::std::os::raw::c_char,
                            option: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn core_kernel_text(addr: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn core_kernel_data(addr: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __kernel_text_address(addr: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kernel_text_address(addr: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn func_ptr_is_kernel_text(ptr: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn int_sqrt(arg1: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bust_spinlocks(yes: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "oops_in_progress"]
    pub static mut oops_in_progress: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "panic_timeout"]
    pub static mut panic_timeout: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "panic_on_oops"]
    pub static mut panic_on_oops: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "panic_on_unrecovered_nmi"]
    pub static mut panic_on_unrecovered_nmi: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "panic_on_io_nmi"]
    pub static mut panic_on_io_nmi: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "panic_on_warn"]
    pub static mut panic_on_warn: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sysctl_panic_on_stackoverflow"]
    pub static mut sysctl_panic_on_stackoverflow: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "crash_kexec_post_notifiers"]
    pub static mut crash_kexec_post_notifiers: bool_;
}
extern "C" {
    pub fn print_tainted() -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lockdep_ok { LOCKDEP_STILL_OK = 0, LOCKDEP_NOW_UNRELIABLE = 1, }
extern "C" {
    pub fn add_taint(flag: ::std::os::raw::c_uint, arg1: lockdep_ok);
}
extern "C" {
    pub fn test_taint(flag: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_taint() -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "root_mountflags"]
    pub static mut root_mountflags: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "early_boot_irqs_disabled"]
    pub static mut early_boot_irqs_disabled: bool_;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_RUNNING = 1,
    SYSTEM_HALT = 2,
    SYSTEM_POWER_OFF = 3,
    SYSTEM_RESTART = 4,
}
extern "C" {
    #[link_name = "system_state"]
    pub static mut system_state: system_states;
}
extern "C" {
    #[link_name = "hex_asc"]
    pub static mut hex_asc: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "hex_asc_upper"]
    pub static mut hex_asc_upper: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn hex_to_bin(ch: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hex2bin(dst: *mut u8, src: *const ::std::os::raw::c_char,
                   count: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bin2hex(dst: *mut ::std::os::raw::c_char,
                   src: *const ::std::os::raw::c_void, count: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mac_pton(s: *const ::std::os::raw::c_char, mac: *mut u8) -> bool_;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ftrace_dump_mode { DUMP_NONE = 0, DUMP_ALL = 1, DUMP_ORIG = 2, }
extern "C" {
    pub fn tracing_on();
}
extern "C" {
    pub fn tracing_off();
}
extern "C" {
    pub fn tracing_is_on() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tracing_snapshot();
}
extern "C" {
    pub fn tracing_snapshot_alloc();
}
extern "C" {
    pub fn tracing_start();
}
extern "C" {
    pub fn tracing_stop();
}
extern "C" {
    pub fn __trace_bprintk(ip: ::std::os::raw::c_ulong,
                           fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __trace_printk(ip: ::std::os::raw::c_ulong,
                          fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __trace_bputs(ip: ::std::os::raw::c_ulong,
                         str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __trace_puts(ip: ::std::os::raw::c_ulong,
                        str: *const ::std::os::raw::c_char,
                        size: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn trace_dump_stack(skip: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __ftrace_vbprintk(ip: ::std::os::raw::c_ulong,
                             fmt: *const ::std::os::raw::c_char,
                             ap: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ftrace_vprintk(ip: ::std::os::raw::c_ulong,
                            fmt: *const ::std::os::raw::c_char,
                            ap: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftrace_dump(oops_dump_mode: ftrace_dump_mode);
}
#[repr(C)]
#[derive(Copy)]
pub struct bug_entry {
    pub bug_addr_disp: ::std::os::raw::c_int,
    pub file_disp: ::std::os::raw::c_int,
    pub line: ::std::os::raw::c_ushort,
    pub flags: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_bug_entry() {
    assert_eq!(::std::mem::size_of::<bug_entry>() , 12usize , concat ! (
               "Size of: " , stringify ! ( bug_entry ) ));
    assert_eq! (::std::mem::align_of::<bug_entry>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( bug_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bug_entry ) ) . bug_addr_disp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bug_entry ) , "::" ,
                stringify ! ( bug_addr_disp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bug_entry ) ) . file_disp as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bug_entry ) , "::" ,
                stringify ! ( file_disp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bug_entry ) ) . line as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bug_entry ) , "::" ,
                stringify ! ( line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bug_entry ) ) . flags as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( bug_entry ) , "::" ,
                stringify ! ( flags ) ));
}
impl Clone for bug_entry {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn warn_slowpath_fmt(file: *const ::std::os::raw::c_char,
                             line: ::std::os::raw::c_int,
                             fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn warn_slowpath_fmt_taint(file: *const ::std::os::raw::c_char,
                                   line: ::std::os::raw::c_int,
                                   taint: ::std::os::raw::c_uint,
                                   fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn warn_slowpath_null(file: *const ::std::os::raw::c_char,
                              line: ::std::os::raw::c_int);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bug_trap_type {
    BUG_TRAP_TYPE_NONE = 0,
    BUG_TRAP_TYPE_WARN = 1,
    BUG_TRAP_TYPE_BUG = 2,
}
extern "C" {
    pub fn find_bug(bugaddr: ::std::os::raw::c_ulong) -> *const bug_entry;
}
extern "C" {
    pub fn report_bug(bug_addr: ::std::os::raw::c_ulong, regs: *mut pt_regs)
     -> bug_trap_type;
}
extern "C" {
    pub fn is_valid_bugaddr(addr: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct {
    _unused: [u8; 0],
}
extern "C" {
    pub fn dump_page(page: *mut page, reason: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn dump_page_badflags(page: *mut page,
                              reason: *const ::std::os::raw::c_char,
                              badflags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn dump_vma(vma: *const vm_area_struct);
}
extern "C" {
    pub fn dump_mm(mm: *const mm_struct);
}
extern "C" {
    pub fn __bad_percpu_size();
}
extern "C" {
    pub fn __bad_size_call_parameter();
}
extern "C" {
    #[link_name = "__per_cpu_offset"]
    pub static mut __per_cpu_offset: [::std::os::raw::c_ulong; 256usize];
}
extern "C" {
    pub fn setup_per_cpu_areas();
}
extern "C" {
    #[link_name = "this_cpu_off"]
    pub static mut this_cpu_off: ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Copy)]
pub struct timespec {
    pub tv_sec: __kernel_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct compat_timespec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct restart_block {
    pub fn_: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                            *mut restart_block)
                                       -> ::std::os::raw::c_long>,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct restart_block__bindgen_ty_1 {
    pub futex: __BindgenUnionField<restart_block__bindgen_ty_1__bindgen_ty_1>,
    pub nanosleep: __BindgenUnionField<restart_block__bindgen_ty_1__bindgen_ty_2>,
    pub poll: __BindgenUnionField<restart_block__bindgen_ty_1__bindgen_ty_3>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_1 {
    pub uaddr: *mut u32,
    pub val: u32,
    pub flags: u32,
    pub bitset: u32,
    pub time: u64,
    pub uaddr2: *mut u32,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_1>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               restart_block__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_1 ) )
                . uaddr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( uaddr ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_1 ) )
                . val as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( val ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_1 ) )
                . flags as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( flags ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_1 ) )
                . bitset as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( bitset ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_1 ) )
                . time as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( time ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_1 ) )
                . uaddr2 as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( uaddr2 ) ));
}
impl Clone for restart_block__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_2 {
    pub clockid: clockid_t,
    pub rmtp: *mut timespec,
    pub compat_rmtp: *mut compat_timespec,
    pub expires: u64,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               restart_block__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_2 ) )
                . clockid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify
                ! ( clockid ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_2 ) )
                . rmtp as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify
                ! ( rmtp ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_2 ) )
                . compat_rmtp as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify
                ! ( compat_rmtp ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_2 ) )
                . expires as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify
                ! ( expires ) ));
}
impl Clone for restart_block__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_3 {
    pub ufds: *mut pollfd,
    pub nfds: ::std::os::raw::c_int,
    pub has_timeout: ::std::os::raw::c_int,
    pub tv_sec: ::std::os::raw::c_ulong,
    pub tv_nsec: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_3>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               restart_block__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_3>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_3 ) )
                . ufds as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify
                ! ( ufds ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_3 ) )
                . nfds as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify
                ! ( nfds ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_3 ) )
                . has_timeout as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify
                ! ( has_timeout ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_3 ) )
                . tv_sec as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify
                ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const restart_block__bindgen_ty_1__bindgen_ty_3 ) )
                . tv_nsec as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify
                ! ( tv_nsec ) ));
}
impl Clone for restart_block__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<restart_block__bindgen_ty_1>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( restart_block__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<restart_block__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( restart_block__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const restart_block__bindgen_ty_1 ) ) . futex
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1 ) , "::" , stringify ! ( futex )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const restart_block__bindgen_ty_1 ) ) .
                nanosleep as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1 ) , "::" , stringify ! ( nanosleep
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const restart_block__bindgen_ty_1 ) ) . poll as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                restart_block__bindgen_ty_1 ) , "::" , stringify ! ( poll )
                ));
}
impl Clone for restart_block__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_restart_block() {
    assert_eq!(::std::mem::size_of::<restart_block>() , 48usize , concat ! (
               "Size of: " , stringify ! ( restart_block ) ));
    assert_eq! (::std::mem::align_of::<restart_block>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( restart_block ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const restart_block ) ) . fn_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( restart_block ) , "::"
                , stringify ! ( fn_ ) ));
}
impl Clone for restart_block {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn do_no_restart_syscall(parm: *mut restart_block)
     -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "max_pfn"]
    pub static mut max_pfn: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "phys_base"]
    pub static mut phys_base: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn clear_page(page: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn copy_page(to: *mut ::std::os::raw::c_void,
                     from: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Copy)]
pub struct range {
    pub start: u64,
    pub end: u64,
}
#[test]
fn bindgen_test_layout_range() {
    assert_eq!(::std::mem::size_of::<range>() , 16usize , concat ! (
               "Size of: " , stringify ! ( range ) ));
    assert_eq! (::std::mem::align_of::<range>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const range ) ) . start as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( range ) , "::" ,
                stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const range ) ) . end as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( range ) , "::" ,
                stringify ! ( end ) ));
}
impl Clone for range {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn add_range(range: *mut range, az: ::std::os::raw::c_int,
                     nr_range: ::std::os::raw::c_int, start: u64, end: u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_range_with_merge(range: *mut range, az: ::std::os::raw::c_int,
                                nr_range: ::std::os::raw::c_int, start: u64,
                                end: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn subtract_range(range: *mut range, az: ::std::os::raw::c_int,
                          start: u64, end: u64);
}
extern "C" {
    pub fn clean_sort_range(range: *mut range, az: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sort_range(range: *mut range, nr_range: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "pfn_mapped"]
    pub static mut pfn_mapped: [range; 0usize];
}
extern "C" {
    #[link_name = "nr_pfn_mapped"]
    pub static mut nr_pfn_mapped: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __virt_addr_valid(kaddr: ::std::os::raw::c_ulong) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm86 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct math_emu_info {
    pub ___orig_eip: ::std::os::raw::c_long,
    pub regs: *mut pt_regs,
}
#[test]
fn bindgen_test_layout_math_emu_info() {
    assert_eq!(::std::mem::size_of::<math_emu_info>() , 16usize , concat ! (
               "Size of: " , stringify ! ( math_emu_info ) ));
    assert_eq! (::std::mem::align_of::<math_emu_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( math_emu_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const math_emu_info ) ) . ___orig_eip as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( math_emu_info ) , "::"
                , stringify ! ( ___orig_eip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const math_emu_info ) ) . regs as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( math_emu_info ) , "::"
                , stringify ! ( regs ) ));
}
impl Clone for math_emu_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _fpx_sw_bytes {
    pub magic1: __u32,
    pub extended_size: __u32,
    pub xfeatures: __u64,
    pub xstate_size: __u32,
    pub padding: [__u32; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(::std::mem::size_of::<_fpx_sw_bytes>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _fpx_sw_bytes ) ));
    assert_eq! (::std::mem::align_of::<_fpx_sw_bytes>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _fpx_sw_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . magic1 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( magic1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . extended_size as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( extended_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . xfeatures as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( xfeatures ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . xstate_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( xstate_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . padding as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( padding ) ));
}
impl Clone for _fpx_sw_bytes {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _fpstate {
    pub cwd: __u16,
    pub swd: __u16,
    pub twd: __u16,
    pub fop: __u16,
    pub rip: __u64,
    pub rdp: __u64,
    pub mxcsr: __u32,
    pub mxcsr_mask: __u32,
    pub st_space: [__u32; 32usize],
    pub xmm_space: [__u32; 64usize],
    pub reserved2: [__u32; 12usize],
    pub __bindgen_anon_1: _fpstate__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct _fpstate__bindgen_ty_1 {
    pub reserved3: __BindgenUnionField<[__u32; 12usize]>,
    pub sw_reserved: __BindgenUnionField<_fpx_sw_bytes>,
    pub bindgen_union_field: [u64; 6usize],
}
#[test]
fn bindgen_test_layout__fpstate__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_fpstate__bindgen_ty_1>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _fpstate__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<_fpstate__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _fpstate__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate__bindgen_ty_1 ) ) . reserved3 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate__bindgen_ty_1
                ) , "::" , stringify ! ( reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate__bindgen_ty_1 ) ) . sw_reserved
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate__bindgen_ty_1
                ) , "::" , stringify ! ( sw_reserved ) ));
}
impl Clone for _fpstate__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__fpstate() {
    assert_eq!(::std::mem::size_of::<_fpstate>() , 512usize , concat ! (
               "Size of: " , stringify ! ( _fpstate ) ));
    assert_eq! (::std::mem::align_of::<_fpstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . cwd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( cwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . swd as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( swd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . twd as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( twd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . fop as * const _ as usize
                } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( fop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . rip as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . rdp as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( rdp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . mxcsr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . mxcsr_mask as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( mxcsr_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . st_space as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( st_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . xmm_space as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( xmm_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . reserved2 as * const _ as
                usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( reserved2 ) ));
}
#[repr(C)]
#[derive(Copy)]
pub struct _header {
    pub xfeatures: __u64,
    pub reserved1: [__u64; 2usize],
    pub reserved2: [__u64; 5usize],
}
#[test]
fn bindgen_test_layout__header() {
    assert_eq!(::std::mem::size_of::<_header>() , 64usize , concat ! (
               "Size of: " , stringify ! ( _header ) ));
    assert_eq! (::std::mem::align_of::<_header>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _header ) ) . xfeatures as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _header ) , "::" ,
                stringify ! ( xfeatures ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _header ) ) . reserved1 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _header ) , "::" ,
                stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _header ) ) . reserved2 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _header ) , "::" ,
                stringify ! ( reserved2 ) ));
}
impl Clone for _header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _ymmh_state {
    pub ymmh_space: [__u32; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(::std::mem::size_of::<_ymmh_state>() , 256usize , concat ! (
               "Size of: " , stringify ! ( _ymmh_state ) ));
    assert_eq! (::std::mem::align_of::<_ymmh_state>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _ymmh_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ymmh_state ) ) . ymmh_space as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _ymmh_state ) , "::" ,
                stringify ! ( ymmh_space ) ));
}
#[repr(C)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _header,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(::std::mem::size_of::<_xstate>() , 832usize , concat ! (
               "Size of: " , stringify ! ( _xstate ) ));
    assert_eq! (::std::mem::align_of::<_xstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _xstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . fpstate as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . xstate_hdr as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( xstate_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . ymmh as * const _ as usize
                } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( ymmh ) ));
}
#[repr(C)]
#[derive(Copy)]
pub struct sigcontext {
    pub r8: ::std::os::raw::c_ulong,
    pub r9: ::std::os::raw::c_ulong,
    pub r10: ::std::os::raw::c_ulong,
    pub r11: ::std::os::raw::c_ulong,
    pub r12: ::std::os::raw::c_ulong,
    pub r13: ::std::os::raw::c_ulong,
    pub r14: ::std::os::raw::c_ulong,
    pub r15: ::std::os::raw::c_ulong,
    pub di: ::std::os::raw::c_ulong,
    pub si: ::std::os::raw::c_ulong,
    pub bp: ::std::os::raw::c_ulong,
    pub bx: ::std::os::raw::c_ulong,
    pub dx: ::std::os::raw::c_ulong,
    pub ax: ::std::os::raw::c_ulong,
    pub cx: ::std::os::raw::c_ulong,
    pub sp: ::std::os::raw::c_ulong,
    pub ip: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: ::std::os::raw::c_ulong,
    pub trapno: ::std::os::raw::c_ulong,
    pub oldmask: ::std::os::raw::c_ulong,
    pub cr2: ::std::os::raw::c_ulong,
    pub fpstate: *mut ::std::os::raw::c_void,
    pub reserved1: [::std::os::raw::c_ulong; 8usize],
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(::std::mem::size_of::<sigcontext>() , 256usize , concat ! (
               "Size of: " , stringify ! ( sigcontext ) ));
    assert_eq! (::std::mem::align_of::<sigcontext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r8 as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r9 as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r10 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r11 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r12 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r13 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r14 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r15 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . di as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( di ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . si as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( si ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . bp as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( bp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . bx as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( bx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . dx as * const _ as usize
                } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( dx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . ax as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( ax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . cx as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( cx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sp as * const _ as usize
                } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . ip as * const _ as usize
                } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . flags as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . cs as * const _ as usize
                } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . gs as * const _ as usize
                } , 146usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . fs as * const _ as usize
                } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . __pad0 as * const _ as
                usize } , 150usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( __pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . err as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . trapno as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . oldmask as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( oldmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . cr2 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( cr2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . fpstate as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . reserved1 as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( reserved1 ) ));
}
impl Clone for sigcontext {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "current_task"]
    pub static mut current_task: *mut task_struct;
}
extern "C" {
    pub fn strndup_user(arg1: *const ::std::os::raw::c_char,
                        arg2: ::std::os::raw::c_long)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memdup_user(arg1: *const ::std::os::raw::c_void, arg2: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __memcpy(to: *mut ::std::os::raw::c_void,
                    from: *const ::std::os::raw::c_void, len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(s: *mut ::std::os::raw::c_void, c: ::std::os::raw::c_int,
                  n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __memset(s: *mut ::std::os::raw::c_void, c: ::std::os::raw::c_int,
                    n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(dest: *mut ::std::os::raw::c_void,
                   src: *const ::std::os::raw::c_void, count: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __memmove(dest: *mut ::std::os::raw::c_void,
                     src: *const ::std::os::raw::c_void, count: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(cs: *const ::std::os::raw::c_void,
                  ct: *const ::std::os::raw::c_void, count: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcpy(dest: *mut ::std::os::raw::c_char,
                  src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(dest: *mut ::std::os::raw::c_char,
                  src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(cs: *const ::std::os::raw::c_char,
                  ct: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: __kernel_size_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcpy(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: __kernel_size_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: __kernel_size_t)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncmp(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: __kernel_size_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(s1: *const ::std::os::raw::c_char,
                      s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(s1: *const ::std::os::raw::c_char,
                       s2: *const ::std::os::raw::c_char, n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strchr(arg1: *const ::std::os::raw::c_char,
                  arg2: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(arg1: *const ::std::os::raw::c_char,
                     arg2: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnchr(arg1: *const ::std::os::raw::c_char, arg2: usize,
                   arg3: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(arg1: *const ::std::os::raw::c_char,
                   arg2: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn skip_spaces(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strim(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: __kernel_size_t)
     -> __kernel_size_t;
}
extern "C" {
    pub fn strpbrk(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcspn(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn memscan(arg1: *mut ::std::os::raw::c_void,
                   arg2: ::std::os::raw::c_int, arg3: __kernel_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memchr(arg1: *const ::std::os::raw::c_void,
                  arg2: ::std::os::raw::c_int, arg3: __kernel_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memchr_inv(s: *const ::std::os::raw::c_void,
                      c: ::std::os::raw::c_int, n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strreplace(s: *mut ::std::os::raw::c_char,
                      old: ::std::os::raw::c_char,
                      new: ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kfree_const(x: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn kstrdup(s: *const ::std::os::raw::c_char, gfp: gfp_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kstrdup_const(s: *const ::std::os::raw::c_char, gfp: gfp_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn kstrndup(s: *const ::std::os::raw::c_char, len: usize, gfp: gfp_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kmemdup(src: *const ::std::os::raw::c_void, len: usize, gfp: gfp_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn argv_split(gfp: gfp_t, str: *const ::std::os::raw::c_char,
                      argcp: *mut ::std::os::raw::c_int)
     -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn argv_free(argv: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn sysfs_streq(s1: *const ::std::os::raw::c_char,
                       s2: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn strtobool(s: *const ::std::os::raw::c_char, res: *mut bool_)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vbin_printf(bin_buf: *mut u32, size: usize,
                       fmt: *const ::std::os::raw::c_char,
                       args: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bstr_printf(buf: *mut ::std::os::raw::c_char, size: usize,
                       fmt: *const ::std::os::raw::c_char,
                       bin_buf: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bprintf(bin_buf: *mut u32, size: usize,
                   fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memory_read_from_buffer(to: *mut ::std::os::raw::c_void,
                                   count: usize, ppos: *mut loff_t,
                                   from: *const ::std::os::raw::c_void,
                                   available: usize) -> isize;
}
extern "C" {
    pub fn memweight(ptr: *const ::std::os::raw::c_void, bytes: usize)
     -> usize;
}
extern "C" {
    pub fn memzero_explicit(s: *mut ::std::os::raw::c_void, count: usize);
}
extern "C" {
    pub fn __bitmap_empty(bitmap: *const ::std::os::raw::c_ulong,
                          nbits: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_full(bitmap: *const ::std::os::raw::c_ulong,
                         nbits: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_equal(bitmap1: *const ::std::os::raw::c_ulong,
                          bitmap2: *const ::std::os::raw::c_ulong,
                          nbits: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_complement(dst: *mut ::std::os::raw::c_ulong,
                               src: *const ::std::os::raw::c_ulong,
                               nbits: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn __bitmap_shift_right(dst: *mut ::std::os::raw::c_ulong,
                                src: *const ::std::os::raw::c_ulong,
                                shift: ::std::os::raw::c_uint,
                                nbits: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn __bitmap_shift_left(dst: *mut ::std::os::raw::c_ulong,
                               src: *const ::std::os::raw::c_ulong,
                               shift: ::std::os::raw::c_uint,
                               nbits: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn __bitmap_and(dst: *mut ::std::os::raw::c_ulong,
                        bitmap1: *const ::std::os::raw::c_ulong,
                        bitmap2: *const ::std::os::raw::c_ulong,
                        nbits: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_or(dst: *mut ::std::os::raw::c_ulong,
                       bitmap1: *const ::std::os::raw::c_ulong,
                       bitmap2: *const ::std::os::raw::c_ulong,
                       nbits: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn __bitmap_xor(dst: *mut ::std::os::raw::c_ulong,
                        bitmap1: *const ::std::os::raw::c_ulong,
                        bitmap2: *const ::std::os::raw::c_ulong,
                        nbits: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn __bitmap_andnot(dst: *mut ::std::os::raw::c_ulong,
                           bitmap1: *const ::std::os::raw::c_ulong,
                           bitmap2: *const ::std::os::raw::c_ulong,
                           nbits: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_intersects(bitmap1: *const ::std::os::raw::c_ulong,
                               bitmap2: *const ::std::os::raw::c_ulong,
                               nbits: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_subset(bitmap1: *const ::std::os::raw::c_ulong,
                           bitmap2: *const ::std::os::raw::c_ulong,
                           nbits: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bitmap_weight(bitmap: *const ::std::os::raw::c_ulong,
                           nbits: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_set(map: *mut ::std::os::raw::c_ulong,
                      start: ::std::os::raw::c_uint,
                      len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn bitmap_clear(map: *mut ::std::os::raw::c_ulong,
                        start: ::std::os::raw::c_uint,
                        len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn bitmap_find_next_zero_area_off(map: *mut ::std::os::raw::c_ulong,
                                          size: ::std::os::raw::c_ulong,
                                          start: ::std::os::raw::c_ulong,
                                          nr: ::std::os::raw::c_uint,
                                          align_mask: ::std::os::raw::c_ulong,
                                          align_offset:
                                              ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __bitmap_parse(buf: *const ::std::os::raw::c_char,
                          buflen: ::std::os::raw::c_uint,
                          is_user: ::std::os::raw::c_int,
                          dst: *mut ::std::os::raw::c_ulong,
                          nbits: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_parse_user(ubuf: *const ::std::os::raw::c_char,
                             ulen: ::std::os::raw::c_uint,
                             dst: *mut ::std::os::raw::c_ulong,
                             nbits: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_parselist(buf: *const ::std::os::raw::c_char,
                            maskp: *mut ::std::os::raw::c_ulong,
                            nmaskbits: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_parselist_user(ubuf: *const ::std::os::raw::c_char,
                                 ulen: ::std::os::raw::c_uint,
                                 dst: *mut ::std::os::raw::c_ulong,
                                 nbits: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_remap(dst: *mut ::std::os::raw::c_ulong,
                        src: *const ::std::os::raw::c_ulong,
                        old: *const ::std::os::raw::c_ulong,
                        new: *const ::std::os::raw::c_ulong,
                        nbits: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn bitmap_bitremap(oldbit: ::std::os::raw::c_int,
                           old: *const ::std::os::raw::c_ulong,
                           new: *const ::std::os::raw::c_ulong,
                           bits: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_onto(dst: *mut ::std::os::raw::c_ulong,
                       orig: *const ::std::os::raw::c_ulong,
                       relmap: *const ::std::os::raw::c_ulong,
                       bits: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn bitmap_fold(dst: *mut ::std::os::raw::c_ulong,
                       orig: *const ::std::os::raw::c_ulong,
                       sz: ::std::os::raw::c_uint,
                       nbits: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn bitmap_find_free_region(bitmap: *mut ::std::os::raw::c_ulong,
                                   bits: ::std::os::raw::c_uint,
                                   order: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_release_region(bitmap: *mut ::std::os::raw::c_ulong,
                                 pos: ::std::os::raw::c_uint,
                                 order: ::std::os::raw::c_int);
}
extern "C" {
    pub fn bitmap_allocate_region(bitmap: *mut ::std::os::raw::c_ulong,
                                  pos: ::std::os::raw::c_uint,
                                  order: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_ord_to_pos(bitmap: *const ::std::os::raw::c_ulong,
                             ord: ::std::os::raw::c_uint,
                             nbits: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bitmap_print_to_pagebuf(list: bool_,
                                   buf: *mut ::std::os::raw::c_char,
                                   maskp: *const ::std::os::raw::c_ulong,
                                   nmaskbits: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type cpumask_t = cpumask;
extern "C" {
    #[link_name = "nr_cpu_ids"]
    pub static mut nr_cpu_ids: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "cpu_possible_mask"]
    pub static cpu_possible_mask: *const cpumask;
}
extern "C" {
    #[link_name = "cpu_online_mask"]
    pub static cpu_online_mask: *const cpumask;
}
extern "C" {
    #[link_name = "cpu_present_mask"]
    pub static cpu_present_mask: *const cpumask;
}
extern "C" {
    #[link_name = "cpu_active_mask"]
    pub static cpu_active_mask: *const cpumask;
}
extern "C" {
    pub fn cpumask_next_and(n: ::std::os::raw::c_int, arg1: *const cpumask,
                            arg2: *const cpumask) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cpumask_any_but(mask: *const cpumask, cpu: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cpumask_local_spread(i: ::std::os::raw::c_uint,
                                node: ::std::os::raw::c_int)
     -> ::std::os::raw::c_uint;
}
pub type cpumask_var_t = [cpumask; 1usize];
extern "C" {
    #[link_name = "cpu_all_bits"]
    pub static mut cpu_all_bits: [::std::os::raw::c_ulong; 4usize];
}
extern "C" {
    pub fn set_cpu_possible(cpu: ::std::os::raw::c_uint, possible: bool_);
}
extern "C" {
    pub fn set_cpu_present(cpu: ::std::os::raw::c_uint, present: bool_);
}
extern "C" {
    pub fn set_cpu_online(cpu: ::std::os::raw::c_uint, online: bool_);
}
extern "C" {
    pub fn set_cpu_active(cpu: ::std::os::raw::c_uint, active: bool_);
}
extern "C" {
    pub fn init_cpu_present(src: *const cpumask);
}
extern "C" {
    pub fn init_cpu_possible(src: *const cpumask);
}
extern "C" {
    pub fn init_cpu_online(src: *const cpumask);
}
extern "C" {
    #[link_name = "cpu_bit_bitmap"]
    pub static mut cpu_bit_bitmap:
               [[::std::os::raw::c_ulong; 4usize]; 65usize];
}
extern "C" {
    #[link_name = "cpu_callin_mask"]
    pub static mut cpu_callin_mask: cpumask_var_t;
}
extern "C" {
    #[link_name = "cpu_callout_mask"]
    pub static mut cpu_callout_mask: cpumask_var_t;
}
extern "C" {
    #[link_name = "cpu_initialized_mask"]
    pub static mut cpu_initialized_mask: cpumask_var_t;
}
extern "C" {
    #[link_name = "cpu_sibling_setup_mask"]
    pub static mut cpu_sibling_setup_mask: cpumask_var_t;
}
extern "C" {
    pub fn setup_cpu_local_masks();
}
extern "C" {
    #[link_name = "__invalid_size_argument_for_IOC"]
    pub static mut __invalid_size_argument_for_IOC: ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Copy)]
pub struct msr {
    pub __bindgen_anon_1: msr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct msr__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<msr__bindgen_ty_1__bindgen_ty_1>,
    pub q: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Copy)]
pub struct msr__bindgen_ty_1__bindgen_ty_1 {
    pub l: u32,
    pub h: u32,
}
#[test]
fn bindgen_test_layout_msr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<msr__bindgen_ty_1__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( msr__bindgen_ty_1__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<msr__bindgen_ty_1__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                msr__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msr__bindgen_ty_1__bindgen_ty_1 ) ) . l
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                msr__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( l )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msr__bindgen_ty_1__bindgen_ty_1 ) ) . h
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                msr__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( h )
                ));
}
impl Clone for msr__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_msr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<msr__bindgen_ty_1>() , 8usize , concat !
               ( "Size of: " , stringify ! ( msr__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<msr__bindgen_ty_1>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( msr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msr__bindgen_ty_1 ) ) . q as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( msr__bindgen_ty_1 ) ,
                "::" , stringify ! ( q ) ));
}
impl Clone for msr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_msr() {
    assert_eq!(::std::mem::size_of::<msr>() , 8usize , concat ! (
               "Size of: " , stringify ! ( msr ) ));
    assert_eq! (::std::mem::align_of::<msr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( msr ) ));
}
impl Clone for msr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct msr_info {
    pub msr_no: u32,
    pub reg: msr,
    pub msrs: *mut msr,
    pub err: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msr_info() {
    assert_eq!(::std::mem::size_of::<msr_info>() , 32usize , concat ! (
               "Size of: " , stringify ! ( msr_info ) ));
    assert_eq! (::std::mem::align_of::<msr_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( msr_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msr_info ) ) . msr_no as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( msr_info ) , "::" ,
                stringify ! ( msr_no ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msr_info ) ) . reg as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( msr_info ) , "::" ,
                stringify ! ( reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msr_info ) ) . msrs as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( msr_info ) , "::" ,
                stringify ! ( msrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msr_info ) ) . err as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( msr_info ) , "::" ,
                stringify ! ( err ) ));
}
impl Clone for msr_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct msr_regs_info {
    pub regs: *mut u32,
    pub err: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msr_regs_info() {
    assert_eq!(::std::mem::size_of::<msr_regs_info>() , 16usize , concat ! (
               "Size of: " , stringify ! ( msr_regs_info ) ));
    assert_eq! (::std::mem::align_of::<msr_regs_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( msr_regs_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msr_regs_info ) ) . regs as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( msr_regs_info ) , "::"
                , stringify ! ( regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msr_regs_info ) ) . err as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( msr_regs_info ) , "::"
                , stringify ! ( err ) ));
}
impl Clone for msr_regs_info {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn native_read_tsc() -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn rdmsr_safe_regs(regs: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe_regs(regs: *mut u32) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct static_key {
    pub enabled: atomic_t,
}
#[test]
fn bindgen_test_layout_static_key() {
    assert_eq!(::std::mem::size_of::<static_key>() , 4usize , concat ! (
               "Size of: " , stringify ! ( static_key ) ));
    assert_eq! (::std::mem::align_of::<static_key>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( static_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const static_key ) ) . enabled as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( static_key ) , "::" ,
                stringify ! ( enabled ) ));
}
impl Clone for static_key {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "paravirt_steal_enabled"]
    pub static mut paravirt_steal_enabled: static_key;
}
extern "C" {
    #[link_name = "paravirt_steal_rq_enabled"]
    pub static mut paravirt_steal_rq_enabled: static_key;
}
extern "C" {
    pub fn default_banner();
}
extern "C" {
    pub fn msrs_alloc() -> *mut msr;
}
extern "C" {
    pub fn msrs_free(msrs: *mut msr);
}
extern "C" {
    pub fn msr_set_bit(msr: u32, bit: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msr_clear_bit(msr: u32, bit: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsr_on_cpu(cpu: ::std::os::raw::c_uint, msr_no: u32, l: *mut u32,
                        h: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_on_cpu(cpu: ::std::os::raw::c_uint, msr_no: u32, l: u32,
                        h: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsrl_on_cpu(cpu: ::std::os::raw::c_uint, msr_no: u32,
                         q: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsrl_on_cpu(cpu: ::std::os::raw::c_uint, msr_no: u32, q: u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsr_on_cpus(mask: *const cpumask, msr_no: u32, msrs: *mut msr);
}
extern "C" {
    pub fn wrmsr_on_cpus(mask: *const cpumask, msr_no: u32, msrs: *mut msr);
}
extern "C" {
    pub fn rdmsr_safe_on_cpu(cpu: ::std::os::raw::c_uint, msr_no: u32,
                             l: *mut u32, h: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe_on_cpu(cpu: ::std::os::raw::c_uint, msr_no: u32, l: u32,
                             h: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsrl_safe_on_cpu(cpu: ::std::os::raw::c_uint, msr_no: u32,
                              q: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsrl_safe_on_cpu(cpu: ::std::os::raw::c_uint, msr_no: u32,
                              q: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsr_safe_regs_on_cpu(cpu: ::std::os::raw::c_uint, regs: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe_regs_on_cpu(cpu: ::std::os::raw::c_uint, regs: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__force_order"]
    pub static mut __force_order: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn native_load_gs_index(arg1: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Copy)]
pub struct fregs_state {
    pub cwd: u32,
    pub swd: u32,
    pub twd: u32,
    pub fip: u32,
    pub fcs: u32,
    pub foo: u32,
    pub fos: u32,
    pub st_space: [u32; 20usize],
    pub status: u32,
}
#[test]
fn bindgen_test_layout_fregs_state() {
    assert_eq!(::std::mem::size_of::<fregs_state>() , 112usize , concat ! (
               "Size of: " , stringify ! ( fregs_state ) ));
    assert_eq! (::std::mem::align_of::<fregs_state>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( fregs_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fregs_state ) ) . cwd as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fregs_state ) , "::" ,
                stringify ! ( cwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fregs_state ) ) . swd as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( fregs_state ) , "::" ,
                stringify ! ( swd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fregs_state ) ) . twd as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( fregs_state ) , "::" ,
                stringify ! ( twd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fregs_state ) ) . fip as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( fregs_state ) , "::" ,
                stringify ! ( fip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fregs_state ) ) . fcs as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( fregs_state ) , "::" ,
                stringify ! ( fcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fregs_state ) ) . foo as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( fregs_state ) , "::" ,
                stringify ! ( foo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fregs_state ) ) . fos as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( fregs_state ) , "::" ,
                stringify ! ( fos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fregs_state ) ) . st_space as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( fregs_state ) , "::" ,
                stringify ! ( st_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fregs_state ) ) . status as * const _ as
                usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( fregs_state ) , "::" ,
                stringify ! ( status ) ));
}
impl Clone for fregs_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct fxregs_state {
    pub cwd: u16,
    pub swd: u16,
    pub twd: u16,
    pub fop: u16,
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1,
    pub mxcsr: u32,
    pub mxcsr_mask: u32,
    pub st_space: [u32; 32usize],
    pub xmm_space: [u32; 64usize],
    pub padding: [u32; 12usize],
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy)]
pub struct fxregs_state__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<fxregs_state__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<fxregs_state__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_1 {
    pub rip: u64,
    pub rdp: u64,
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               fxregs_state__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                fxregs_state__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const fxregs_state__bindgen_ty_1__bindgen_ty_1 ) )
                . rip as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                fxregs_state__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( rip ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const fxregs_state__bindgen_ty_1__bindgen_ty_1 ) )
                . rdp as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                fxregs_state__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( rdp ) ));
}
impl Clone for fxregs_state__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_2 {
    pub fip: u32,
    pub fcs: u32,
    pub foo: u32,
    pub fos: u32,
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               fxregs_state__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                fxregs_state__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const fxregs_state__bindgen_ty_1__bindgen_ty_2 ) )
                . fip as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                fxregs_state__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify
                ! ( fip ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const fxregs_state__bindgen_ty_1__bindgen_ty_2 ) )
                . fcs as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                fxregs_state__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify
                ! ( fcs ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const fxregs_state__bindgen_ty_1__bindgen_ty_2 ) )
                . foo as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                fxregs_state__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify
                ! ( foo ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const fxregs_state__bindgen_ty_1__bindgen_ty_2 ) )
                . fos as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                fxregs_state__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify
                ! ( fos ) ));
}
impl Clone for fxregs_state__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<fxregs_state__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( fxregs_state__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<fxregs_state__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( fxregs_state__bindgen_ty_1 )
                ));
}
impl Clone for fxregs_state__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct fxregs_state__bindgen_ty_2 {
    pub padding1: __BindgenUnionField<[u32; 12usize]>,
    pub sw_reserved: __BindgenUnionField<[u32; 12usize]>,
    pub bindgen_union_field: [u32; 12usize],
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<fxregs_state__bindgen_ty_2>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( fxregs_state__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<fxregs_state__bindgen_ty_2>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( fxregs_state__bindgen_ty_2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fxregs_state__bindgen_ty_2 ) ) . padding1
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                fxregs_state__bindgen_ty_2 ) , "::" , stringify ! ( padding1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fxregs_state__bindgen_ty_2 ) ) .
                sw_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                fxregs_state__bindgen_ty_2 ) , "::" , stringify ! (
                sw_reserved ) ));
}
impl Clone for fxregs_state__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_fxregs_state() {
    assert_eq!(::std::mem::size_of::<fxregs_state>() , 512usize , concat ! (
               "Size of: " , stringify ! ( fxregs_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fxregs_state ) ) . cwd as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fxregs_state ) , "::" ,
                stringify ! ( cwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fxregs_state ) ) . swd as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( fxregs_state ) , "::" ,
                stringify ! ( swd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fxregs_state ) ) . twd as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( fxregs_state ) , "::" ,
                stringify ! ( twd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fxregs_state ) ) . fop as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( fxregs_state ) , "::" ,
                stringify ! ( fop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fxregs_state ) ) . mxcsr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( fxregs_state ) , "::" ,
                stringify ! ( mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fxregs_state ) ) . mxcsr_mask as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( fxregs_state ) , "::" ,
                stringify ! ( mxcsr_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fxregs_state ) ) . st_space as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( fxregs_state ) , "::" ,
                stringify ! ( st_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fxregs_state ) ) . xmm_space as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( fxregs_state ) , "::" ,
                stringify ! ( xmm_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fxregs_state ) ) . padding as * const _
                as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( fxregs_state ) , "::" ,
                stringify ! ( padding ) ));
}
#[repr(C)]
#[derive(Copy)]
pub struct swregs_state {
    pub cwd: u32,
    pub swd: u32,
    pub twd: u32,
    pub fip: u32,
    pub fcs: u32,
    pub foo: u32,
    pub fos: u32,
    pub st_space: [u32; 20usize],
    pub ftop: u8,
    pub changed: u8,
    pub lookahead: u8,
    pub no_update: u8,
    pub rm: u8,
    pub alimit: u8,
    pub info: *mut math_emu_info,
    pub entry_eip: u32,
}
#[test]
fn bindgen_test_layout_swregs_state() {
    assert_eq!(::std::mem::size_of::<swregs_state>() , 136usize , concat ! (
               "Size of: " , stringify ! ( swregs_state ) ));
    assert_eq! (::std::mem::align_of::<swregs_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( swregs_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . cwd as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( cwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . swd as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( swd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . twd as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( twd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . fip as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( fip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . fcs as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( fcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . foo as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( foo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . fos as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( fos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . st_space as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( st_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . ftop as * const _ as
                usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( ftop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . changed as * const _
                as usize } , 109usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . lookahead as * const _
                as usize } , 110usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( lookahead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . no_update as * const _
                as usize } , 111usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( no_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . rm as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( rm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . alimit as * const _ as
                usize } , 113usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( alimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . info as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const swregs_state ) ) . entry_eip as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( swregs_state ) , "::" ,
                stringify ! ( entry_eip ) ));
}
impl Clone for swregs_state {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xfeature_bit {
    XSTATE_BIT_FP = 0,
    XSTATE_BIT_SSE = 1,
    XSTATE_BIT_YMM = 2,
    XSTATE_BIT_BNDREGS = 3,
    XSTATE_BIT_BNDCSR = 4,
    XSTATE_BIT_OPMASK = 5,
    XSTATE_BIT_ZMM_Hi256 = 6,
    XSTATE_BIT_Hi16_ZMM = 7,
    XFEATURES_NR_MAX = 8,
}
#[repr(C)]
pub struct ymmh_struct {
    pub ymmh_space: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_ymmh_struct() {
    assert_eq!(::std::mem::size_of::<ymmh_struct>() , 256usize , concat ! (
               "Size of: " , stringify ! ( ymmh_struct ) ));
    assert_eq! (::std::mem::align_of::<ymmh_struct>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ymmh_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ymmh_struct ) ) . ymmh_space as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ymmh_struct ) , "::" ,
                stringify ! ( ymmh_space ) ));
}
#[repr(C)]
pub struct lwp_struct {
    pub reserved: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_lwp_struct() {
    assert_eq!(::std::mem::size_of::<lwp_struct>() , 128usize , concat ! (
               "Size of: " , stringify ! ( lwp_struct ) ));
    assert_eq! (::std::mem::align_of::<lwp_struct>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( lwp_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lwp_struct ) ) . reserved as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lwp_struct ) , "::" ,
                stringify ! ( reserved ) ));
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct bndreg {
    pub lower_bound: u64,
    pub upper_bound: u64,
}
#[test]
fn bindgen_test_layout_bndreg() {
    assert_eq!(::std::mem::size_of::<bndreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bndreg ) ));
    assert_eq! (::std::mem::align_of::<bndreg>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( bndreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bndreg ) ) . lower_bound as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bndreg ) , "::" ,
                stringify ! ( lower_bound ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bndreg ) ) . upper_bound as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bndreg ) , "::" ,
                stringify ! ( upper_bound ) ));
}
impl Clone for bndreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct bndcsr {
    pub bndcfgu: u64,
    pub bndstatus: u64,
}
#[test]
fn bindgen_test_layout_bndcsr() {
    assert_eq!(::std::mem::size_of::<bndcsr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bndcsr ) ));
    assert_eq! (::std::mem::align_of::<bndcsr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( bndcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bndcsr ) ) . bndcfgu as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bndcsr ) , "::" ,
                stringify ! ( bndcfgu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bndcsr ) ) . bndstatus as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bndcsr ) , "::" ,
                stringify ! ( bndstatus ) ));
}
impl Clone for bndcsr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct mpx_struct {
    pub bndreg: [bndreg; 4usize],
    pub bndcsr: bndcsr,
}
#[test]
fn bindgen_test_layout_mpx_struct() {
    assert_eq!(::std::mem::size_of::<mpx_struct>() , 80usize , concat ! (
               "Size of: " , stringify ! ( mpx_struct ) ));
    assert_eq! (::std::mem::align_of::<mpx_struct>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( mpx_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpx_struct ) ) . bndreg as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpx_struct ) , "::" ,
                stringify ! ( bndreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpx_struct ) ) . bndcsr as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( mpx_struct ) , "::" ,
                stringify ! ( bndcsr ) ));
}
impl Clone for mpx_struct {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct xstate_header {
    pub xfeatures: u64,
    pub xcomp_bv: u64,
    pub reserved: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_xstate_header() {
    assert_eq!(::std::mem::size_of::<xstate_header>() , 64usize , concat ! (
               "Size of: " , stringify ! ( xstate_header ) ));
    assert_eq! (::std::mem::align_of::<xstate_header>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( xstate_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xstate_header ) ) . xfeatures as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xstate_header ) , "::"
                , stringify ! ( xfeatures ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xstate_header ) ) . xcomp_bv as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xstate_header ) , "::"
                , stringify ! ( xcomp_bv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xstate_header ) ) . reserved as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( xstate_header ) , "::"
                , stringify ! ( reserved ) ));
}
impl Clone for xstate_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
pub struct xregs_state {
    pub i387: fxregs_state,
    pub header: xstate_header,
    pub __reserved: [u8; 464usize],
    pub __bindgen_padding_0: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_xregs_state() {
    assert_eq!(::std::mem::size_of::<xregs_state>() , 1088usize , concat ! (
               "Size of: " , stringify ! ( xregs_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xregs_state ) ) . i387 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xregs_state ) , "::" ,
                stringify ! ( i387 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xregs_state ) ) . header as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( xregs_state ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xregs_state ) ) . __reserved as * const _
                as usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( xregs_state ) , "::" ,
                stringify ! ( __reserved ) ));
}
#[repr(C)]
#[derive(Copy)]
pub struct fpregs_state {
    pub fsave: __BindgenUnionField<fregs_state>,
    pub fxsave: __BindgenUnionField<fxregs_state>,
    pub soft: __BindgenUnionField<swregs_state>,
    pub xsave: __BindgenUnionField<xregs_state>,
    pub __padding: __BindgenUnionField<[u8; 4096usize]>,
    pub bindgen_union_field: [u8; 4096usize],
}
#[test]
fn bindgen_test_layout_fpregs_state() {
    assert_eq!(::std::mem::size_of::<fpregs_state>() , 4096usize , concat ! (
               "Size of: " , stringify ! ( fpregs_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fpregs_state ) ) . fsave as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fpregs_state ) , "::" ,
                stringify ! ( fsave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fpregs_state ) ) . fxsave as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fpregs_state ) , "::" ,
                stringify ! ( fxsave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fpregs_state ) ) . soft as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fpregs_state ) , "::" ,
                stringify ! ( soft ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fpregs_state ) ) . xsave as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fpregs_state ) , "::" ,
                stringify ! ( xsave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fpregs_state ) ) . __padding as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fpregs_state ) , "::" ,
                stringify ! ( __padding ) ));
}
impl Clone for fpregs_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct fpu {
    pub last_cpu: ::std::os::raw::c_uint,
    pub fpstate_active: ::std::os::raw::c_uchar,
    pub fpregs_active: ::std::os::raw::c_uchar,
    pub counter: ::std::os::raw::c_uchar,
    pub __bindgen_padding_0: [u64; 7usize],
    pub state: fpregs_state,
}
#[test]
fn bindgen_test_layout_fpu() {
    assert_eq!(::std::mem::size_of::<fpu>() , 4160usize , concat ! (
               "Size of: " , stringify ! ( fpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fpu ) ) . last_cpu as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fpu ) , "::" ,
                stringify ! ( last_cpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fpu ) ) . fpstate_active as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( fpu ) , "::" ,
                stringify ! ( fpstate_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fpu ) ) . fpregs_active as * const _ as
                usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( fpu ) , "::" ,
                stringify ! ( fpregs_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fpu ) ) . counter as * const _ as usize }
                , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( fpu ) , "::" ,
                stringify ! ( counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fpu ) ) . state as * const _ as usize } ,
                64usize , concat ! (
                "Alignment of field: " , stringify ! ( fpu ) , "::" ,
                stringify ! ( state ) ));
}
impl Clone for fpu {
    fn clone(&self) -> Self { *self }
}
pub const UNAME26: _bindgen_ty_5 = _bindgen_ty_5::UNAME26;
pub const ADDR_NO_RANDOMIZE: _bindgen_ty_5 = _bindgen_ty_5::ADDR_NO_RANDOMIZE;
pub const FDPIC_FUNCPTRS: _bindgen_ty_5 = _bindgen_ty_5::FDPIC_FUNCPTRS;
pub const MMAP_PAGE_ZERO: _bindgen_ty_5 = _bindgen_ty_5::MMAP_PAGE_ZERO;
pub const ADDR_COMPAT_LAYOUT: _bindgen_ty_5 =
    _bindgen_ty_5::ADDR_COMPAT_LAYOUT;
pub const READ_IMPLIES_EXEC: _bindgen_ty_5 = _bindgen_ty_5::READ_IMPLIES_EXEC;
pub const ADDR_LIMIT_32BIT: _bindgen_ty_5 = _bindgen_ty_5::ADDR_LIMIT_32BIT;
pub const SHORT_INODE: _bindgen_ty_5 = _bindgen_ty_5::SHORT_INODE;
pub const WHOLE_SECONDS: _bindgen_ty_5 = _bindgen_ty_5::WHOLE_SECONDS;
pub const STICKY_TIMEOUTS: _bindgen_ty_5 = _bindgen_ty_5::STICKY_TIMEOUTS;
pub const ADDR_LIMIT_3GB: _bindgen_ty_5 = _bindgen_ty_5::ADDR_LIMIT_3GB;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    UNAME26 = 131072,
    ADDR_NO_RANDOMIZE = 262144,
    FDPIC_FUNCPTRS = 524288,
    MMAP_PAGE_ZERO = 1048576,
    ADDR_COMPAT_LAYOUT = 2097152,
    READ_IMPLIES_EXEC = 4194304,
    ADDR_LIMIT_32BIT = 8388608,
    SHORT_INODE = 16777216,
    WHOLE_SECONDS = 33554432,
    STICKY_TIMEOUTS = 67108864,
    ADDR_LIMIT_3GB = 134217728,
}
pub const PER_LINUX: _bindgen_ty_6 = _bindgen_ty_6::PER_LINUX;
pub const PER_LINUX_32BIT: _bindgen_ty_6 = _bindgen_ty_6::PER_LINUX_32BIT;
pub const PER_LINUX_FDPIC: _bindgen_ty_6 = _bindgen_ty_6::PER_LINUX_FDPIC;
pub const PER_SVR4: _bindgen_ty_6 = _bindgen_ty_6::PER_SVR4;
pub const PER_SVR3: _bindgen_ty_6 = _bindgen_ty_6::PER_SVR3;
pub const PER_SCOSVR3: _bindgen_ty_6 = _bindgen_ty_6::PER_SCOSVR3;
pub const PER_OSR5: _bindgen_ty_6 = _bindgen_ty_6::PER_OSR5;
pub const PER_WYSEV386: _bindgen_ty_6 = _bindgen_ty_6::PER_WYSEV386;
pub const PER_ISCR4: _bindgen_ty_6 = _bindgen_ty_6::PER_ISCR4;
pub const PER_BSD: _bindgen_ty_6 = _bindgen_ty_6::PER_BSD;
pub const PER_SUNOS: _bindgen_ty_6 = _bindgen_ty_6::PER_SUNOS;
pub const PER_XENIX: _bindgen_ty_6 = _bindgen_ty_6::PER_XENIX;
pub const PER_LINUX32: _bindgen_ty_6 = _bindgen_ty_6::PER_LINUX32;
pub const PER_LINUX32_3GB: _bindgen_ty_6 = _bindgen_ty_6::PER_LINUX32_3GB;
pub const PER_IRIX32: _bindgen_ty_6 = _bindgen_ty_6::PER_IRIX32;
pub const PER_IRIXN32: _bindgen_ty_6 = _bindgen_ty_6::PER_IRIXN32;
pub const PER_IRIX64: _bindgen_ty_6 = _bindgen_ty_6::PER_IRIX64;
pub const PER_RISCOS: _bindgen_ty_6 = _bindgen_ty_6::PER_RISCOS;
pub const PER_SOLARIS: _bindgen_ty_6 = _bindgen_ty_6::PER_SOLARIS;
pub const PER_UW7: _bindgen_ty_6 = _bindgen_ty_6::PER_UW7;
pub const PER_OSF4: _bindgen_ty_6 = _bindgen_ty_6::PER_OSF4;
pub const PER_HPUX: _bindgen_ty_6 = _bindgen_ty_6::PER_HPUX;
pub const PER_MASK: _bindgen_ty_6 = _bindgen_ty_6::PER_MASK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    PER_LINUX = 0,
    PER_LINUX_32BIT = 8388608,
    PER_LINUX_FDPIC = 524288,
    PER_SVR4 = 68157441,
    PER_SVR3 = 83886082,
    PER_SCOSVR3 = 117440515,
    PER_OSR5 = 100663299,
    PER_WYSEV386 = 83886084,
    PER_ISCR4 = 67108869,
    PER_BSD = 6,
    PER_SUNOS = 67108870,
    PER_XENIX = 83886087,
    PER_LINUX32 = 8,
    PER_LINUX32_3GB = 134217736,
    PER_IRIX32 = 67108873,
    PER_IRIXN32 = 67108874,
    PER_IRIX64 = 67108875,
    PER_RISCOS = 12,
    PER_SOLARIS = 67108877,
    PER_UW7 = 68157454,
    PER_OSF4 = 15,
    PER_HPUX = 16,
    PER_MASK = 255,
}
extern "C" {
    pub fn iter_div_u64_rem(dividend: u64, divisor: u32, remainder: *mut u64)
     -> u32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum tlb_infos { ENTRIES = 0, NR_INFO = 1, }
extern "C" {
    #[link_name = "tlb_lli_4k"]
    pub static mut tlb_lli_4k: [u16; 1usize];
}
extern "C" {
    #[link_name = "tlb_lli_2m"]
    pub static mut tlb_lli_2m: [u16; 1usize];
}
extern "C" {
    #[link_name = "tlb_lli_4m"]
    pub static mut tlb_lli_4m: [u16; 1usize];
}
extern "C" {
    #[link_name = "tlb_lld_4k"]
    pub static mut tlb_lld_4k: [u16; 1usize];
}
extern "C" {
    #[link_name = "tlb_lld_2m"]
    pub static mut tlb_lld_2m: [u16; 1usize];
}
extern "C" {
    #[link_name = "tlb_lld_4m"]
    pub static mut tlb_lld_4m: [u16; 1usize];
}
extern "C" {
    #[link_name = "tlb_lld_1g"]
    pub static mut tlb_lld_1g: [u16; 1usize];
}
extern "C" {
    #[link_name = "boot_cpu_data"]
    pub static mut boot_cpu_data: cpuinfo_x86;
}
extern "C" {
    #[link_name = "new_cpu_data"]
    pub static mut new_cpu_data: cpuinfo_x86;
}
extern "C" {
    #[link_name = "doublefault_tss"]
    pub static mut doublefault_tss: tss_struct;
}
extern "C" {
    #[link_name = "cpu_caps_cleared"]
    pub static mut cpu_caps_cleared: [__u32; 13usize];
}
extern "C" {
    #[link_name = "cpu_caps_set"]
    pub static mut cpu_caps_set: [__u32; 13usize];
}
extern "C" {
    #[link_name = "cpu_info"]
    pub static mut cpu_info: cpuinfo_x86;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seq_operations {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "cpuinfo_op"]
    pub static cpuinfo_op: seq_operations;
}
extern "C" {
    pub fn cpu_detect(c: *mut cpuinfo_x86);
}
extern "C" {
    pub fn early_cpu_init();
}
extern "C" {
    pub fn identify_boot_cpu();
}
extern "C" {
    pub fn identify_secondary_cpu(arg1: *mut cpuinfo_x86);
}
extern "C" {
    pub fn print_cpu_info(arg1: *mut cpuinfo_x86);
}
extern "C" {
    pub fn print_cpu_msr(arg1: *mut cpuinfo_x86);
}
extern "C" {
    pub fn init_scattered_cpuid_features(c: *mut cpuinfo_x86);
}
extern "C" {
    pub fn init_intel_cacheinfo(c: *mut cpuinfo_x86)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn init_amd_cacheinfo(c: *mut cpuinfo_x86);
}
extern "C" {
    pub fn detect_extended_topology(c: *mut cpuinfo_x86);
}
extern "C" {
    pub fn detect_ht(c: *mut cpuinfo_x86);
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct x86_hw_tss {
    pub reserved1: u32,
    pub sp0: u64,
    pub sp1: u64,
    pub sp2: u64,
    pub reserved2: u64,
    pub ist: [u64; 7usize],
    pub reserved3: u32,
    pub reserved4: u32,
    pub reserved5: u16,
    pub io_bitmap_base: u16,
    pub __bindgen_padding_0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_x86_hw_tss() {
    assert_eq!(::std::mem::size_of::<x86_hw_tss>() , 128usize , concat ! (
               "Size of: " , stringify ! ( x86_hw_tss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_hw_tss ) ) . reserved1 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_hw_tss ) , "::" ,
                stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_hw_tss ) ) . sp0 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_hw_tss ) , "::" ,
                stringify ! ( sp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_hw_tss ) ) . sp1 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_hw_tss ) , "::" ,
                stringify ! ( sp1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_hw_tss ) ) . sp2 as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_hw_tss ) , "::" ,
                stringify ! ( sp2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_hw_tss ) ) . reserved2 as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_hw_tss ) , "::" ,
                stringify ! ( reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_hw_tss ) ) . ist as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_hw_tss ) , "::" ,
                stringify ! ( ist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_hw_tss ) ) . reserved3 as * const _
                as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_hw_tss ) , "::" ,
                stringify ! ( reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_hw_tss ) ) . reserved4 as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_hw_tss ) , "::" ,
                stringify ! ( reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_hw_tss ) ) . reserved5 as * const _
                as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_hw_tss ) , "::" ,
                stringify ! ( reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_hw_tss ) ) . io_bitmap_base as *
                const _ as usize } , 102usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_hw_tss ) , "::" ,
                stringify ! ( io_bitmap_base ) ));
}
impl Clone for x86_hw_tss {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "cpu_tss"]
    pub static mut cpu_tss: tss_struct;
}
#[repr(C)]
#[derive(Copy)]
pub struct orig_ist {
    pub ist: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout_orig_ist() {
    assert_eq!(::std::mem::size_of::<orig_ist>() , 56usize , concat ! (
               "Size of: " , stringify ! ( orig_ist ) ));
    assert_eq! (::std::mem::align_of::<orig_ist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( orig_ist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orig_ist ) ) . ist as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( orig_ist ) , "::" ,
                stringify ! ( ist ) ));
}
impl Clone for orig_ist {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "orig_ist"]
    pub static mut orig_ist: orig_ist;
}
#[repr(C)]
#[derive(Copy)]
pub struct irq_stack_union {
    pub irq_stack: __BindgenUnionField<[::std::os::raw::c_char; 16384usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<irq_stack_union__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 2048usize],
}
#[repr(C)]
pub struct irq_stack_union__bindgen_ty_1 {
    pub gs_base: [::std::os::raw::c_char; 40usize],
    pub stack_canary: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_irq_stack_union__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<irq_stack_union__bindgen_ty_1>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( irq_stack_union__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<irq_stack_union__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( irq_stack_union__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const irq_stack_union__bindgen_ty_1 ) ) .
                gs_base as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                irq_stack_union__bindgen_ty_1 ) , "::" , stringify ! ( gs_base
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const irq_stack_union__bindgen_ty_1 ) ) .
                stack_canary as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                irq_stack_union__bindgen_ty_1 ) , "::" , stringify ! (
                stack_canary ) ));
}
#[test]
fn bindgen_test_layout_irq_stack_union() {
    assert_eq!(::std::mem::size_of::<irq_stack_union>() , 16384usize , concat
               ! ( "Size of: " , stringify ! ( irq_stack_union ) ));
    assert_eq! (::std::mem::align_of::<irq_stack_union>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( irq_stack_union ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const irq_stack_union ) ) . irq_stack as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( irq_stack_union ) ,
                "::" , stringify ! ( irq_stack ) ));
}
impl Clone for irq_stack_union {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "irq_stack_union"]
    pub static mut irq_stack_union: irq_stack_union;
}
extern "C" {
    #[link_name = "init_per_cpu__irq_stack_union"]
    pub static mut init_per_cpu__irq_stack_union: irq_stack_union;
}
extern "C" {
    #[link_name = "irq_stack_ptr"]
    pub static mut irq_stack_ptr: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "irq_count"]
    pub static mut irq_count: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ignore_sysret();
}
extern "C" {
    #[link_name = "xstate_size"]
    pub static mut xstate_size: ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct mm_segment_t {
    pub seg: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_mm_segment_t() {
    assert_eq!(::std::mem::size_of::<mm_segment_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( mm_segment_t ) ));
    assert_eq! (::std::mem::align_of::<mm_segment_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mm_segment_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mm_segment_t ) ) . seg as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mm_segment_t ) , "::" ,
                stringify ! ( seg ) ));
}
impl Clone for mm_segment_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn release_thread(arg1: *mut task_struct);
}
extern "C" {
    pub fn get_wchan(p: *mut task_struct) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn select_idle_routine(c: *const cpuinfo_x86);
}
extern "C" {
    pub fn init_amd_e400_c1e_mask();
}
extern "C" {
    #[link_name = "boot_option_idle_override"]
    pub static mut boot_option_idle_override: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "amd_e400_c1e_detected"]
    pub static mut amd_e400_c1e_detected: bool_;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idle_boot_override {
    IDLE_NO_OVERRIDE = 0,
    IDLE_HALT = 1,
    IDLE_NOMWAIT = 2,
    IDLE_POLL = 3,
}
extern "C" {
    pub fn enable_sep_cpu();
}
extern "C" {
    pub fn sysenter_setup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn early_trap_init();
}
extern "C" {
    pub fn early_trap_pf_init();
}
extern "C" {
    #[link_name = "early_gdt_descr"]
    pub static mut early_gdt_descr: desc_ptr;
}
extern "C" {
    pub fn cpu_set_gdt(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn switch_to_new_gdt(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn load_percpu_segment(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cpu_init();
}
extern "C" {
    pub fn set_task_blockstep(task: *mut task_struct, on: bool_);
}
extern "C" {
    #[link_name = "machine_id"]
    pub static mut machine_id: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "machine_submodel_id"]
    pub static mut machine_submodel_id: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "BIOS_revision"]
    pub static mut BIOS_revision: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "bootloader_type"]
    pub static mut bootloader_type: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "bootloader_version"]
    pub static mut bootloader_version: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ignore_fpu_irq"]
    pub static mut ignore_fpu_irq: ::std::os::raw::c_char;
}
extern "C" {
    pub fn KSTK_ESP(task: *mut task_struct) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn start_thread(regs: *mut pt_regs, new_ip: ::std::os::raw::c_ulong,
                        new_sp: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn get_tsc_mode(adr: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_tsc_mode(val: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mpx_enable_management() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mpx_disable_management() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn amd_get_nb_id(cpu: ::std::os::raw::c_int) -> u16;
}
extern "C" {
    pub fn amd_get_nodes_per_socket() -> u32;
}
extern "C" {
    pub fn arch_align_stack(sp: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn free_init_pages(what: *mut ::std::os::raw::c_char,
                           begin: ::std::os::raw::c_ulong,
                           end: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn default_idle();
}
extern "C" {
    pub fn xen_set_default_idle() -> bool_;
}
extern "C" {
    pub fn stop_this_cpu(dummy: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn df_debug(regs: *mut pt_regs, error_code: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __xchg_wrong_size();
}
extern "C" {
    pub fn __cmpxchg_wrong_size();
}
extern "C" {
    pub fn __xadd_wrong_size();
}
extern "C" {
    pub fn __add_wrong_size();
}
pub type atomic_long_t = atomic64_t;
#[repr(C)]
#[derive(Copy)]
pub struct thread_info {
    pub task: *mut task_struct,
    pub flags: __u32,
    pub status: __u32,
    pub cpu: __u32,
    pub saved_preempt_count: ::std::os::raw::c_int,
    pub addr_limit: mm_segment_t,
    pub sysenter_return: *mut ::std::os::raw::c_void,
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_thread_info() {
    assert_eq!(::std::mem::size_of::<thread_info>() , 48usize , concat ! (
               "Size of: " , stringify ! ( thread_info ) ));
    assert_eq! (::std::mem::align_of::<thread_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( thread_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_info ) ) . task as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_info ) , "::" ,
                stringify ! ( task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_info ) ) . flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_info ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_info ) ) . status as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_info ) , "::" ,
                stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_info ) ) . cpu as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_info ) , "::" ,
                stringify ! ( cpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_info ) ) . saved_preempt_count as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_info ) , "::" ,
                stringify ! ( saved_preempt_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_info ) ) . addr_limit as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_info ) , "::" ,
                stringify ! ( addr_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread_info ) ) . sysenter_return as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( thread_info ) , "::" ,
                stringify ! ( sysenter_return ) ));
}
impl Clone for thread_info {
    fn clone(&self) -> Self { *self }
}
impl thread_info {
    #[inline]
    pub fn sig_on_uaccess_error(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sig_on_uaccess_error(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn uaccess_err(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_uaccess_err(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(sig_on_uaccess_error: ::std::os::raw::c_uint,
                          uaccess_err: ::std::os::raw::c_uint) -> u8 {
        ({
             ({ 0 } |
                  ((sig_on_uaccess_error as u32 as u8) << 0usize) &
                      (1u64 as u8))
         } | ((uaccess_err as u32 as u8) << 1usize) & (2u64 as u8))
    }
}
extern "C" {
    pub fn arch_task_cache_init();
}
extern "C" {
    pub fn arch_dup_task_struct(dst: *mut task_struct, src: *mut task_struct)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_release_task_struct(tsk: *mut task_struct);
}
extern "C" {
    #[link_name = "__preempt_count"]
    pub static mut __preempt_count: ::std::os::raw::c_int;
}
/// preempt_notifier - key for installing preemption notifiers
/// @link: internal use
/// @ops: defines the notifier functions to be called
///
/// Usually used in conjunction with container_of().
#[repr(C)]
#[derive(Copy)]
pub struct preempt_notifier {
    pub link: hlist_node,
    pub ops: *mut preempt_ops,
}
#[test]
fn bindgen_test_layout_preempt_notifier() {
    assert_eq!(::std::mem::size_of::<preempt_notifier>() , 24usize , concat !
               ( "Size of: " , stringify ! ( preempt_notifier ) ));
    assert_eq! (::std::mem::align_of::<preempt_notifier>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( preempt_notifier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const preempt_notifier ) ) . link as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( preempt_notifier ) ,
                "::" , stringify ! ( link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const preempt_notifier ) ) . ops as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( preempt_notifier ) ,
                "::" , stringify ! ( ops ) ));
}
impl Clone for preempt_notifier {
    fn clone(&self) -> Self { *self }
}
/// preempt_ops - notifiers called when a task is preempted and rescheduled
/// @sched_in: we're about to be rescheduled:
/// notifier: struct preempt_notifier for the task being scheduled
/// cpu:  cpu we're scheduled on
/// @sched_out: we've just been preempted
/// notifier: struct preempt_notifier for the task being preempted
/// next: the task that's kicking us out
///
/// Please note that sched_in and out are called under different
/// contexts.  sched_out is called with rq lock held and irq disabled
/// while sched_in is called without rq lock and irq enabled.  This
/// difference is intentional and depended upon by its users.
#[repr(C)]
#[derive(Copy)]
pub struct preempt_ops {
    pub sched_in: ::std::option::Option<unsafe extern "C" fn(notifier:
                                                                 *mut preempt_notifier,
                                                             cpu:
                                                                 ::std::os::raw::c_int)>,
    pub sched_out: ::std::option::Option<unsafe extern "C" fn(notifier:
                                                                  *mut preempt_notifier,
                                                              next:
                                                                  *mut task_struct)>,
}
#[test]
fn bindgen_test_layout_preempt_ops() {
    assert_eq!(::std::mem::size_of::<preempt_ops>() , 16usize , concat ! (
               "Size of: " , stringify ! ( preempt_ops ) ));
    assert_eq! (::std::mem::align_of::<preempt_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( preempt_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const preempt_ops ) ) . sched_in as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( preempt_ops ) , "::" ,
                stringify ! ( sched_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const preempt_ops ) ) . sched_out as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( preempt_ops ) , "::" ,
                stringify ! ( sched_out ) ));
}
impl Clone for preempt_ops {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn preempt_notifier_inc();
}
extern "C" {
    pub fn preempt_notifier_dec();
}
extern "C" {
    pub fn preempt_notifier_register(notifier: *mut preempt_notifier);
}
extern "C" {
    pub fn preempt_notifier_unregister(notifier: *mut preempt_notifier);
}
extern "C" {
    pub fn _local_bh_enable();
}
extern "C" {
    pub fn __local_bh_enable_ip(ip: ::std::os::raw::c_ulong,
                                cnt: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockdep_map {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "prove_locking"]
    pub static mut prove_locking: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "lock_stat"]
    pub static mut lock_stat: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct lock_class_key {
}
#[test]
fn bindgen_test_layout_lock_class_key() {
    assert_eq!(::std::mem::size_of::<lock_class_key>() , 0usize , concat ! (
               "Size of: " , stringify ! ( lock_class_key ) ));
    assert_eq! (::std::mem::align_of::<lock_class_key>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( lock_class_key ) ));
}
impl Clone for lock_class_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
#[test]
fn bindgen_test_layout_raw_spinlock() {
    assert_eq!(::std::mem::size_of::<raw_spinlock>() , 4usize , concat ! (
               "Size of: " , stringify ! ( raw_spinlock ) ));
    assert_eq! (::std::mem::align_of::<raw_spinlock>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( raw_spinlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const raw_spinlock ) ) . raw_lock as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( raw_spinlock ) , "::" ,
                stringify ! ( raw_lock ) ));
}
impl Clone for raw_spinlock {
    fn clone(&self) -> Self { *self }
}
pub type raw_spinlock_t = raw_spinlock;
#[repr(C)]
#[derive(Copy)]
pub struct spinlock {
    pub __bindgen_anon_1: spinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct spinlock__bindgen_ty_1 {
    pub rlock: __BindgenUnionField<raw_spinlock>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_spinlock__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<spinlock__bindgen_ty_1>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( spinlock__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<spinlock__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( spinlock__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const spinlock__bindgen_ty_1 ) ) . rlock as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( spinlock__bindgen_ty_1
                ) , "::" , stringify ! ( rlock ) ));
}
impl Clone for spinlock__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_spinlock() {
    assert_eq!(::std::mem::size_of::<spinlock>() , 4usize , concat ! (
               "Size of: " , stringify ! ( spinlock ) ));
    assert_eq! (::std::mem::align_of::<spinlock>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( spinlock ) ));
}
impl Clone for spinlock {
    fn clone(&self) -> Self { *self }
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Copy)]
pub struct rwlock_t {
    pub raw_lock: arch_rwlock_t,
}
#[test]
fn bindgen_test_layout_rwlock_t() {
    assert_eq!(::std::mem::size_of::<rwlock_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<rwlock_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rwlock_t ) ) . raw_lock as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rwlock_t ) , "::" ,
                stringify ! ( raw_lock ) ));
}
impl Clone for rwlock_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "static_key_initialized"]
    pub static mut static_key_initialized: bool_;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum jump_label_type { JUMP_LABEL_DISABLE = 0, JUMP_LABEL_ENABLE = 1, }
extern "C" {
    #[link_name = "paravirt_ticketlocks_enabled"]
    pub static mut paravirt_ticketlocks_enabled: static_key;
}
extern "C" {
    pub fn native_queued_spin_lock_slowpath(lock: *mut qspinlock, val: u32);
}
extern "C" {
    pub fn __pv_init_lock_hash();
}
extern "C" {
    pub fn __pv_queued_spin_lock_slowpath(lock: *mut qspinlock, val: u32);
}
extern "C" {
    pub fn __raw_callee_save___pv_queued_spin_unlock(lock: *mut qspinlock);
}
extern "C" {
    pub fn queue_read_lock_slowpath(lock: *mut qrwlock);
}
extern "C" {
    pub fn queue_write_lock_slowpath(lock: *mut qrwlock);
}
extern "C" {
    pub fn in_lock_functions(addr: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_spin_lock(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_nested(lock: *mut raw_spinlock_t,
                                 subclass: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _raw_spin_lock_bh_nested(lock: *mut raw_spinlock_t,
                                    subclass: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _raw_spin_lock_nest_lock(lock: *mut raw_spinlock_t,
                                    map: *mut lockdep_map);
}
extern "C" {
    pub fn _raw_spin_lock_bh(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_irq(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_irqsave(lock: *mut raw_spinlock_t)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_spin_lock_irqsave_nested(lock: *mut raw_spinlock_t,
                                         subclass: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_spin_trylock(lock: *mut raw_spinlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_spin_trylock_bh(lock: *mut raw_spinlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_spin_unlock(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_bh(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_irq(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_irqrestore(lock: *mut raw_spinlock_t,
                                       flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn _raw_read_lock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_lock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_lock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_lock_irqsave(lock: *mut rwlock_t)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_write_lock_irqsave(lock: *mut rwlock_t)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_read_trylock(lock: *mut rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_write_trylock(lock: *mut rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_read_unlock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_irqrestore(lock: *mut rwlock_t,
                                       flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn _raw_write_unlock_irqrestore(lock: *mut rwlock_t,
                                        flags: ::std::os::raw::c_ulong);
}
extern "C" {
    /// atomic_dec_and_lock - lock on reaching reference count zero
/// @atomic: the atomic counter
/// @lock: the spinlock in question
///
/// Decrements @atomic by 1.  If the result is 0, returns true and locks
/// @lock.  Returns false for all other cases.
    pub fn _atomic_dec_and_lock(atomic: *mut atomic_t, lock: *mut spinlock_t)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct __wait_queue {
    pub flags: ::std::os::raw::c_uint,
    pub private: *mut ::std::os::raw::c_void,
    pub func: wait_queue_func_t,
    pub task_list: list_head,
}
#[test]
fn bindgen_test_layout___wait_queue() {
    assert_eq!(::std::mem::size_of::<__wait_queue>() , 40usize , concat ! (
               "Size of: " , stringify ! ( __wait_queue ) ));
    assert_eq! (::std::mem::align_of::<__wait_queue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __wait_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wait_queue ) ) . flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __wait_queue ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wait_queue ) ) . private as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __wait_queue ) , "::" ,
                stringify ! ( private ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wait_queue ) ) . func as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __wait_queue ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wait_queue ) ) . task_list as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __wait_queue ) , "::" ,
                stringify ! ( task_list ) ));
}
impl Clone for __wait_queue {
    fn clone(&self) -> Self { *self }
}
pub type wait_queue_t = __wait_queue;
pub type wait_queue_func_t =
    ::std::option::Option<unsafe extern "C" fn(wait: *mut wait_queue_t,
                                               mode: ::std::os::raw::c_uint,
                                               flags: ::std::os::raw::c_int,
                                               key:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn default_wake_function(wait: *mut wait_queue_t,
                                 mode: ::std::os::raw::c_uint,
                                 flags: ::std::os::raw::c_int,
                                 key: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct wait_bit_key {
    pub flags: *mut ::std::os::raw::c_void,
    pub bit_nr: ::std::os::raw::c_int,
    pub timeout: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_wait_bit_key() {
    assert_eq!(::std::mem::size_of::<wait_bit_key>() , 24usize , concat ! (
               "Size of: " , stringify ! ( wait_bit_key ) ));
    assert_eq! (::std::mem::align_of::<wait_bit_key>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( wait_bit_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait_bit_key ) ) . flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait_bit_key ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait_bit_key ) ) . bit_nr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( wait_bit_key ) , "::" ,
                stringify ! ( bit_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait_bit_key ) ) . timeout as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( wait_bit_key ) , "::" ,
                stringify ! ( timeout ) ));
}
impl Clone for wait_bit_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct wait_bit_queue {
    pub key: wait_bit_key,
    pub wait: wait_queue_t,
}
#[test]
fn bindgen_test_layout_wait_bit_queue() {
    assert_eq!(::std::mem::size_of::<wait_bit_queue>() , 64usize , concat ! (
               "Size of: " , stringify ! ( wait_bit_queue ) ));
    assert_eq! (::std::mem::align_of::<wait_bit_queue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( wait_bit_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait_bit_queue ) ) . key as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait_bit_queue ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait_bit_queue ) ) . wait as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( wait_bit_queue ) , "::"
                , stringify ! ( wait ) ));
}
impl Clone for wait_bit_queue {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __wait_queue_head {
    pub lock: spinlock_t,
    pub task_list: list_head,
}
#[test]
fn bindgen_test_layout___wait_queue_head() {
    assert_eq!(::std::mem::size_of::<__wait_queue_head>() , 24usize , concat !
               ( "Size of: " , stringify ! ( __wait_queue_head ) ));
    assert_eq! (::std::mem::align_of::<__wait_queue_head>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( __wait_queue_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wait_queue_head ) ) . lock as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __wait_queue_head ) ,
                "::" , stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wait_queue_head ) ) . task_list as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __wait_queue_head ) ,
                "::" , stringify ! ( task_list ) ));
}
impl Clone for __wait_queue_head {
    fn clone(&self) -> Self { *self }
}
pub type wait_queue_head_t = __wait_queue_head;
extern "C" {
    pub fn __init_waitqueue_head(q: *mut wait_queue_head_t,
                                 name: *const ::std::os::raw::c_char,
                                 arg1: *mut lock_class_key);
}
extern "C" {
    pub fn add_wait_queue(q: *mut wait_queue_head_t, wait: *mut wait_queue_t);
}
extern "C" {
    pub fn add_wait_queue_exclusive(q: *mut wait_queue_head_t,
                                    wait: *mut wait_queue_t);
}
extern "C" {
    pub fn remove_wait_queue(q: *mut wait_queue_head_t,
                             wait: *mut wait_queue_t);
}
pub type wait_bit_action_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut wait_bit_key,
                                               mode: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn __wake_up(q: *mut wait_queue_head_t, mode: ::std::os::raw::c_uint,
                     nr: ::std::os::raw::c_int,
                     key: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __wake_up_locked_key(q: *mut wait_queue_head_t,
                                mode: ::std::os::raw::c_uint,
                                key: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __wake_up_sync_key(q: *mut wait_queue_head_t,
                              mode: ::std::os::raw::c_uint,
                              nr: ::std::os::raw::c_int,
                              key: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __wake_up_locked(q: *mut wait_queue_head_t,
                            mode: ::std::os::raw::c_uint,
                            nr: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __wake_up_sync(q: *mut wait_queue_head_t,
                          mode: ::std::os::raw::c_uint,
                          nr: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __wake_up_bit(arg1: *mut wait_queue_head_t,
                         arg2: *mut ::std::os::raw::c_void,
                         arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __wait_on_bit(arg1: *mut wait_queue_head_t,
                         arg2: *mut wait_bit_queue, arg3: wait_bit_action_f,
                         arg4: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wait_on_bit_lock(arg1: *mut wait_queue_head_t,
                              arg2: *mut wait_bit_queue,
                              arg3: wait_bit_action_f,
                              arg4: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wake_up_bit(arg1: *mut ::std::os::raw::c_void,
                       arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn wake_up_atomic_t(arg1: *mut atomic_t);
}
extern "C" {
    pub fn out_of_line_wait_on_bit(arg1: *mut ::std::os::raw::c_void,
                                   arg2: ::std::os::raw::c_int,
                                   arg3: wait_bit_action_f,
                                   arg4: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn out_of_line_wait_on_bit_timeout(arg1: *mut ::std::os::raw::c_void,
                                           arg2: ::std::os::raw::c_int,
                                           arg3: wait_bit_action_f,
                                           arg4: ::std::os::raw::c_uint,
                                           arg5: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn out_of_line_wait_on_bit_lock(arg1: *mut ::std::os::raw::c_void,
                                        arg2: ::std::os::raw::c_int,
                                        arg3: wait_bit_action_f,
                                        arg4: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn out_of_line_wait_on_atomic_t(arg1: *mut atomic_t,
                                        arg2:
                                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                           *mut atomic_t)
                                                                      ->
                                                                          ::std::os::raw::c_int>,
                                        arg3: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bit_waitqueue(arg1: *mut ::std::os::raw::c_void,
                         arg2: ::std::os::raw::c_int)
     -> *mut wait_queue_head_t;
}
extern "C" {
    pub fn prepare_to_wait(q: *mut wait_queue_head_t, wait: *mut wait_queue_t,
                           state: ::std::os::raw::c_int);
}
extern "C" {
    pub fn prepare_to_wait_exclusive(q: *mut wait_queue_head_t,
                                     wait: *mut wait_queue_t,
                                     state: ::std::os::raw::c_int);
}
extern "C" {
    pub fn prepare_to_wait_event(q: *mut wait_queue_head_t,
                                 wait: *mut wait_queue_t,
                                 state: ::std::os::raw::c_int)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn finish_wait(q: *mut wait_queue_head_t, wait: *mut wait_queue_t);
}
extern "C" {
    pub fn abort_exclusive_wait(q: *mut wait_queue_head_t,
                                wait: *mut wait_queue_t,
                                mode: ::std::os::raw::c_uint,
                                key: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wait_woken(wait: *mut wait_queue_t, mode: ::std::os::raw::c_uint,
                      timeout: ::std::os::raw::c_long)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn woken_wake_function(wait: *mut wait_queue_t,
                               mode: ::std::os::raw::c_uint,
                               sync: ::std::os::raw::c_int,
                               key: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn autoremove_wake_function(wait: *mut wait_queue_t,
                                    mode: ::std::os::raw::c_uint,
                                    sync: ::std::os::raw::c_int,
                                    key: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wake_bit_function(wait: *mut wait_queue_t,
                             mode: ::std::os::raw::c_uint,
                             sync: ::std::os::raw::c_int,
                             key: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bit_wait(arg1: *mut wait_bit_key, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bit_wait_io(arg1: *mut wait_bit_key, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bit_wait_timeout(arg1: *mut wait_bit_key,
                            arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bit_wait_io_timeout(arg1: *mut wait_bit_key,
                               arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct seqcount {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_seqcount() {
    assert_eq!(::std::mem::size_of::<seqcount>() , 4usize , concat ! (
               "Size of: " , stringify ! ( seqcount ) ));
    assert_eq! (::std::mem::align_of::<seqcount>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( seqcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const seqcount ) ) . sequence as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( seqcount ) , "::" ,
                stringify ! ( sequence ) ));
}
impl Clone for seqcount {
    fn clone(&self) -> Self { *self }
}
pub type seqcount_t = seqcount;
#[repr(C)]
#[derive(Copy)]
pub struct seqlock_t {
    pub seqcount: seqcount,
    pub lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_seqlock_t() {
    assert_eq!(::std::mem::size_of::<seqlock_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( seqlock_t ) ));
    assert_eq! (::std::mem::align_of::<seqlock_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( seqlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const seqlock_t ) ) . seqcount as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( seqlock_t ) , "::" ,
                stringify ! ( seqcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const seqlock_t ) ) . lock as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( seqlock_t ) , "::" ,
                stringify ! ( lock ) ));
}
impl Clone for seqlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct nodemask_t {
    pub bits: [::std::os::raw::c_ulong; 1usize],
}
#[test]
fn bindgen_test_layout_nodemask_t() {
    assert_eq!(::std::mem::size_of::<nodemask_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( nodemask_t ) ));
    assert_eq! (::std::mem::align_of::<nodemask_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nodemask_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nodemask_t ) ) . bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nodemask_t ) , "::" ,
                stringify ! ( bits ) ));
}
impl Clone for nodemask_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_unused_nodemask_arg_"]
    pub static mut _unused_nodemask_arg_: nodemask_t;
}
pub const node_states_N_HIGH_MEMORY: node_states =
    node_states::N_NORMAL_MEMORY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum node_states {
    N_POSSIBLE = 0,
    N_ONLINE = 1,
    N_NORMAL_MEMORY = 2,
    N_MEMORY = 3,
    N_CPU = 4,
    NR_NODE_STATES = 5,
}
extern "C" {
    #[link_name = "node_states"]
    pub static mut node_states: [nodemask_t; 5usize];
}
extern "C" {
    #[link_name = "nr_node_ids"]
    pub static mut nr_node_ids: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "nr_online_nodes"]
    pub static mut nr_online_nodes: ::std::os::raw::c_int;
}
extern "C" {
    pub fn node_random(maskp: *const nodemask_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct nodemask_scratch {
    pub mask1: nodemask_t,
    pub mask2: nodemask_t,
}
#[test]
fn bindgen_test_layout_nodemask_scratch() {
    assert_eq!(::std::mem::size_of::<nodemask_scratch>() , 16usize , concat !
               ( "Size of: " , stringify ! ( nodemask_scratch ) ));
    assert_eq! (::std::mem::align_of::<nodemask_scratch>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nodemask_scratch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nodemask_scratch ) ) . mask1 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nodemask_scratch ) ,
                "::" , stringify ! ( mask1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nodemask_scratch ) ) . mask2 as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nodemask_scratch ) ,
                "::" , stringify ! ( mask2 ) ));
}
impl Clone for nodemask_scratch {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pageblock_bits {
    PB_migrate = 0,
    PB_migrate_end = 2,
    PB_migrate_skip = 3,
    NR_PAGEBLOCK_BITS = 4,
}
extern "C" {
    pub fn get_pfnblock_flags_mask(page: *mut page,
                                   pfn: ::std::os::raw::c_ulong,
                                   end_bitidx: ::std::os::raw::c_ulong,
                                   mask: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn set_pfnblock_flags_mask(page: *mut page,
                                   flags: ::std::os::raw::c_ulong,
                                   pfn: ::std::os::raw::c_ulong,
                                   end_bitidx: ::std::os::raw::c_ulong,
                                   mask: ::std::os::raw::c_ulong);
}
pub const MIGRATE_UNMOVABLE: _bindgen_ty_7 = _bindgen_ty_7::MIGRATE_UNMOVABLE;
pub const MIGRATE_RECLAIMABLE: _bindgen_ty_7 =
    _bindgen_ty_7::MIGRATE_RECLAIMABLE;
pub const MIGRATE_MOVABLE: _bindgen_ty_7 = _bindgen_ty_7::MIGRATE_MOVABLE;
pub const MIGRATE_PCPTYPES: _bindgen_ty_7 = _bindgen_ty_7::MIGRATE_PCPTYPES;
pub const MIGRATE_RESERVE: _bindgen_ty_7 = _bindgen_ty_7::MIGRATE_PCPTYPES;
pub const MIGRATE_CMA: _bindgen_ty_7 = _bindgen_ty_7::MIGRATE_CMA;
pub const MIGRATE_ISOLATE: _bindgen_ty_7 = _bindgen_ty_7::MIGRATE_ISOLATE;
pub const MIGRATE_TYPES: _bindgen_ty_7 = _bindgen_ty_7::MIGRATE_TYPES;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    MIGRATE_UNMOVABLE = 0,
    MIGRATE_RECLAIMABLE = 1,
    MIGRATE_MOVABLE = 2,
    MIGRATE_PCPTYPES = 3,
    MIGRATE_CMA = 4,
    MIGRATE_ISOLATE = 5,
    MIGRATE_TYPES = 6,
}
extern "C" {
    #[link_name = "page_group_by_mobility_disabled"]
    pub static mut page_group_by_mobility_disabled: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct free_area {
    pub free_list: [list_head; 6usize],
    pub nr_free: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_free_area() {
    assert_eq!(::std::mem::size_of::<free_area>() , 104usize , concat ! (
               "Size of: " , stringify ! ( free_area ) ));
    assert_eq! (::std::mem::align_of::<free_area>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( free_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const free_area ) ) . free_list as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( free_area ) , "::" ,
                stringify ! ( free_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const free_area ) ) . nr_free as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( free_area ) , "::" ,
                stringify ! ( nr_free ) ));
}
impl Clone for free_area {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct pglist_data {
    pub node_zones: [zone; 4usize],
    pub node_zonelists: [zonelist; 2usize],
    pub nr_zones: ::std::os::raw::c_int,
    pub node_size_lock: spinlock_t,
    pub node_start_pfn: ::std::os::raw::c_ulong,
    pub node_present_pages: ::std::os::raw::c_ulong,
    pub node_spanned_pages: ::std::os::raw::c_ulong,
    pub node_id: ::std::os::raw::c_int,
    pub kswapd_wait: wait_queue_head_t,
    pub pfmemalloc_wait: wait_queue_head_t,
    pub kswapd: *mut task_struct,
    pub kswapd_max_order: ::std::os::raw::c_int,
    pub classzone_idx: zone_type,
    pub numabalancing_migrate_lock: spinlock_t,
    pub numabalancing_migrate_next_window: ::std::os::raw::c_ulong,
    pub numabalancing_migrate_nr_pages: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_pglist_data() {
    assert_eq!(::std::mem::size_of::<pglist_data>() , 17152usize , concat ! (
               "Size of: " , stringify ! ( pglist_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) . node_zones as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( node_zones ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) . node_zonelists as *
                const _ as usize } , 7680usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( node_zonelists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) . nr_zones as * const _
                as usize } , 17024usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( nr_zones ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) . node_size_lock as *
                const _ as usize } , 17028usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( node_size_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) . node_start_pfn as *
                const _ as usize } , 17032usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( node_start_pfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) . node_present_pages as *
                const _ as usize } , 17040usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( node_present_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) . node_spanned_pages as *
                const _ as usize } , 17048usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( node_spanned_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) . node_id as * const _ as
                usize } , 17056usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( node_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) . kswapd_wait as * const
                _ as usize } , 17064usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( kswapd_wait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) . pfmemalloc_wait as *
                const _ as usize } , 17088usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( pfmemalloc_wait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) . kswapd as * const _ as
                usize } , 17112usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( kswapd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) . kswapd_max_order as *
                const _ as usize } , 17120usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( kswapd_max_order ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) . classzone_idx as *
                const _ as usize } , 17124usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( classzone_idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) .
                numabalancing_migrate_lock as * const _ as usize } ,
                17128usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( numabalancing_migrate_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) .
                numabalancing_migrate_next_window as * const _ as usize } ,
                17136usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( numabalancing_migrate_next_window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pglist_data ) ) .
                numabalancing_migrate_nr_pages as * const _ as usize } ,
                17144usize , concat ! (
                "Alignment of field: " , stringify ! ( pglist_data ) , "::" ,
                stringify ! ( numabalancing_migrate_nr_pages ) ));
}
#[repr(C)]
#[derive(Copy)]
pub struct zone_padding {
    pub x: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_zone_padding() {
    assert_eq!(::std::mem::size_of::<zone_padding>() , 0usize , concat ! (
               "Size of: " , stringify ! ( zone_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone_padding ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zone_padding ) , "::" ,
                stringify ! ( x ) ));
}
impl Clone for zone_padding {
    fn clone(&self) -> Self { *self }
}
pub const zone_stat_item_NR_INACTIVE_ANON: zone_stat_item =
    zone_stat_item::NR_LRU_BASE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zone_stat_item {
    NR_FREE_PAGES = 0,
    NR_ALLOC_BATCH = 1,
    NR_LRU_BASE = 2,
    NR_ACTIVE_ANON = 3,
    NR_INACTIVE_FILE = 4,
    NR_ACTIVE_FILE = 5,
    NR_UNEVICTABLE = 6,
    NR_MLOCK = 7,
    NR_ANON_PAGES = 8,
    NR_FILE_MAPPED = 9,
    NR_FILE_PAGES = 10,
    NR_FILE_DIRTY = 11,
    NR_WRITEBACK = 12,
    NR_SLAB_RECLAIMABLE = 13,
    NR_SLAB_UNRECLAIMABLE = 14,
    NR_PAGETABLE = 15,
    NR_KERNEL_STACK = 16,
    NR_UNSTABLE_NFS = 17,
    NR_BOUNCE = 18,
    NR_VMSCAN_WRITE = 19,
    NR_VMSCAN_IMMEDIATE = 20,
    NR_WRITEBACK_TEMP = 21,
    NR_ISOLATED_ANON = 22,
    NR_ISOLATED_FILE = 23,
    NR_SHMEM = 24,
    NR_DIRTIED = 25,
    NR_WRITTEN = 26,
    NR_PAGES_SCANNED = 27,
    NUMA_HIT = 28,
    NUMA_MISS = 29,
    NUMA_FOREIGN = 30,
    NUMA_INTERLEAVE_HIT = 31,
    NUMA_LOCAL = 32,
    NUMA_OTHER = 33,
    WORKINGSET_REFAULT = 34,
    WORKINGSET_ACTIVATE = 35,
    WORKINGSET_NODERECLAIM = 36,
    NR_ANON_TRANSPARENT_HUGEPAGES = 37,
    NR_FREE_CMA_PAGES = 38,
    NR_VM_ZONE_STAT_ITEMS = 39,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lru_list {
    LRU_INACTIVE_ANON = 0,
    LRU_ACTIVE_ANON = 1,
    LRU_INACTIVE_FILE = 2,
    LRU_ACTIVE_FILE = 3,
    LRU_UNEVICTABLE = 4,
    NR_LRU_LISTS = 5,
}
#[repr(C)]
#[derive(Copy)]
pub struct zone_reclaim_stat {
    pub recent_rotated: [::std::os::raw::c_ulong; 2usize],
    pub recent_scanned: [::std::os::raw::c_ulong; 2usize],
}
#[test]
fn bindgen_test_layout_zone_reclaim_stat() {
    assert_eq!(::std::mem::size_of::<zone_reclaim_stat>() , 32usize , concat !
               ( "Size of: " , stringify ! ( zone_reclaim_stat ) ));
    assert_eq! (::std::mem::align_of::<zone_reclaim_stat>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( zone_reclaim_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone_reclaim_stat ) ) . recent_rotated as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zone_reclaim_stat ) ,
                "::" , stringify ! ( recent_rotated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone_reclaim_stat ) ) . recent_scanned as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( zone_reclaim_stat ) ,
                "::" , stringify ! ( recent_scanned ) ));
}
impl Clone for zone_reclaim_stat {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct lruvec {
    pub lists: [list_head; 5usize],
    pub reclaim_stat: zone_reclaim_stat,
    pub zone: *mut zone,
}
#[test]
fn bindgen_test_layout_lruvec() {
    assert_eq!(::std::mem::size_of::<lruvec>() , 120usize , concat ! (
               "Size of: " , stringify ! ( lruvec ) ));
    assert_eq! (::std::mem::align_of::<lruvec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lruvec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lruvec ) ) . lists as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lruvec ) , "::" ,
                stringify ! ( lists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lruvec ) ) . reclaim_stat as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( lruvec ) , "::" ,
                stringify ! ( reclaim_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lruvec ) ) . zone as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( lruvec ) , "::" ,
                stringify ! ( zone ) ));
}
impl Clone for lruvec {
    fn clone(&self) -> Self { *self }
}
pub type isolate_mode_t = ::std::os::raw::c_uint;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zone_watermarks {
    WMARK_MIN = 0,
    WMARK_LOW = 1,
    WMARK_HIGH = 2,
    NR_WMARK = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct per_cpu_pages {
    pub count: ::std::os::raw::c_int,
    pub high: ::std::os::raw::c_int,
    pub batch: ::std::os::raw::c_int,
    pub lists: [list_head; 3usize],
}
#[test]
fn bindgen_test_layout_per_cpu_pages() {
    assert_eq!(::std::mem::size_of::<per_cpu_pages>() , 64usize , concat ! (
               "Size of: " , stringify ! ( per_cpu_pages ) ));
    assert_eq! (::std::mem::align_of::<per_cpu_pages>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( per_cpu_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const per_cpu_pages ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( per_cpu_pages ) , "::"
                , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const per_cpu_pages ) ) . high as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( per_cpu_pages ) , "::"
                , stringify ! ( high ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const per_cpu_pages ) ) . batch as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( per_cpu_pages ) , "::"
                , stringify ! ( batch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const per_cpu_pages ) ) . lists as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( per_cpu_pages ) , "::"
                , stringify ! ( lists ) ));
}
impl Clone for per_cpu_pages {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct per_cpu_pageset {
    pub pcp: per_cpu_pages,
    pub expire: s8,
    pub stat_threshold: s8,
    pub vm_stat_diff: [s8; 39usize],
}
#[test]
fn bindgen_test_layout_per_cpu_pageset() {
    assert_eq!(::std::mem::size_of::<per_cpu_pageset>() , 112usize , concat !
               ( "Size of: " , stringify ! ( per_cpu_pageset ) ));
    assert_eq! (::std::mem::align_of::<per_cpu_pageset>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( per_cpu_pageset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const per_cpu_pageset ) ) . pcp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( per_cpu_pageset ) ,
                "::" , stringify ! ( pcp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const per_cpu_pageset ) ) . expire as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( per_cpu_pageset ) ,
                "::" , stringify ! ( expire ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const per_cpu_pageset ) ) . stat_threshold as *
                const _ as usize } , 65usize , concat ! (
                "Alignment of field: " , stringify ! ( per_cpu_pageset ) ,
                "::" , stringify ! ( stat_threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const per_cpu_pageset ) ) . vm_stat_diff as *
                const _ as usize } , 66usize , concat ! (
                "Alignment of field: " , stringify ! ( per_cpu_pageset ) ,
                "::" , stringify ! ( vm_stat_diff ) ));
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zone_type {
    ZONE_DMA = 0,
    ZONE_DMA32 = 1,
    ZONE_NORMAL = 2,
    ZONE_MOVABLE = 3,
    __MAX_NR_ZONES = 4,
}
#[repr(C)]
pub struct zone {
    pub watermark: [::std::os::raw::c_ulong; 3usize],
    pub lowmem_reserve: [::std::os::raw::c_long; 4usize],
    pub node: ::std::os::raw::c_int,
    pub inactive_ratio: ::std::os::raw::c_uint,
    pub zone_pgdat: *mut pglist_data,
    pub pageset: *mut per_cpu_pageset,
    pub dirty_balance_reserve: ::std::os::raw::c_ulong,
    pub min_unmapped_pages: ::std::os::raw::c_ulong,
    pub min_slab_pages: ::std::os::raw::c_ulong,
    pub zone_start_pfn: ::std::os::raw::c_ulong,
    pub managed_pages: ::std::os::raw::c_ulong,
    pub spanned_pages: ::std::os::raw::c_ulong,
    pub present_pages: ::std::os::raw::c_ulong,
    pub name: *const ::std::os::raw::c_char,
    pub nr_migrate_reserve_block: ::std::os::raw::c_int,
    pub nr_isolate_pageblock: ::std::os::raw::c_ulong,
    pub span_seqlock: seqlock_t,
    pub wait_table: *mut wait_queue_head_t,
    pub wait_table_hash_nr_entries: ::std::os::raw::c_ulong,
    pub wait_table_bits: ::std::os::raw::c_ulong,
    pub _pad1_: zone_padding,
    pub free_area: [free_area; 11usize],
    pub flags: ::std::os::raw::c_ulong,
    pub lock: spinlock_t,
    pub __bindgen_padding_0: [u64; 7usize],
    pub _pad2_: zone_padding,
    pub lru_lock: spinlock_t,
    pub lruvec: lruvec,
    pub inactive_age: atomic_long_t,
    pub percpu_drift_mark: ::std::os::raw::c_ulong,
    pub compact_cached_free_pfn: ::std::os::raw::c_ulong,
    pub compact_cached_migrate_pfn: [::std::os::raw::c_ulong; 2usize],
    pub compact_considered: ::std::os::raw::c_uint,
    pub compact_defer_shift: ::std::os::raw::c_uint,
    pub compact_order_failed: ::std::os::raw::c_int,
    pub compact_blockskip_flush: bool_,
    pub __bindgen_padding_1: u64,
    pub _pad3_: zone_padding,
    pub vm_stat: [atomic_long_t; 39usize],
    pub __bindgen_padding_2: u64,
}
#[test]
fn bindgen_test_layout_zone() {
    assert_eq!(::std::mem::size_of::<zone>() , 1920usize , concat ! (
               "Size of: " , stringify ! ( zone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . watermark as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( watermark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . lowmem_reserve as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( lowmem_reserve ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . node as * const _ as usize } ,
                56usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . inactive_ratio as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( inactive_ratio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . zone_pgdat as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( zone_pgdat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . pageset as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( pageset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . dirty_balance_reserve as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( dirty_balance_reserve ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . min_unmapped_pages as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( min_unmapped_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . min_slab_pages as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( min_slab_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . zone_start_pfn as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( zone_start_pfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . managed_pages as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( managed_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . spanned_pages as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( spanned_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . present_pages as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( present_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . name as * const _ as usize } ,
                136usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . nr_migrate_reserve_block as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( nr_migrate_reserve_block ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . nr_isolate_pageblock as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( nr_isolate_pageblock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . span_seqlock as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( span_seqlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . wait_table as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( wait_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . wait_table_hash_nr_entries as
                * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( wait_table_hash_nr_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . wait_table_bits as * const _
                as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( wait_table_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . _pad1_ as * const _ as usize }
                , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( _pad1_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . free_area as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( free_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . flags as * const _ as usize }
                , 1336usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . lock as * const _ as usize } ,
                1344usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . _pad2_ as * const _ as usize }
                , 1408usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( _pad2_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . lru_lock as * const _ as usize
                } , 1408usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( lru_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . lruvec as * const _ as usize }
                , 1416usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( lruvec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . inactive_age as * const _ as
                usize } , 1536usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( inactive_age ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . percpu_drift_mark as * const _
                as usize } , 1544usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( percpu_drift_mark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . compact_cached_free_pfn as *
                const _ as usize } , 1552usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( compact_cached_free_pfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . compact_cached_migrate_pfn as
                * const _ as usize } , 1560usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( compact_cached_migrate_pfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . compact_considered as * const
                _ as usize } , 1576usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( compact_considered ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . compact_defer_shift as * const
                _ as usize } , 1580usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( compact_defer_shift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . compact_order_failed as *
                const _ as usize } , 1584usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( compact_order_failed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . compact_blockskip_flush as *
                const _ as usize } , 1588usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( compact_blockskip_flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . _pad3_ as * const _ as usize }
                , 1600usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( _pad3_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zone ) ) . vm_stat as * const _ as usize
                } , 1600usize , concat ! (
                "Alignment of field: " , stringify ! ( zone ) , "::" ,
                stringify ! ( vm_stat ) ));
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zone_flags {
    ZONE_RECLAIM_LOCKED = 0,
    ZONE_OOM_LOCKED = 1,
    ZONE_CONGESTED = 2,
    ZONE_DIRTY = 3,
    ZONE_WRITEBACK = 4,
    ZONE_FAIR_DEPLETED = 5,
}
#[repr(C)]
pub struct zonelist_cache {
    pub z_to_n: [::std::os::raw::c_ushort; 256usize],
    pub fullzones: [::std::os::raw::c_ulong; 4usize],
    pub last_full_zap: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_zonelist_cache() {
    assert_eq!(::std::mem::size_of::<zonelist_cache>() , 552usize , concat ! (
               "Size of: " , stringify ! ( zonelist_cache ) ));
    assert_eq! (::std::mem::align_of::<zonelist_cache>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( zonelist_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zonelist_cache ) ) . z_to_n as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zonelist_cache ) , "::"
                , stringify ! ( z_to_n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zonelist_cache ) ) . fullzones as * const
                _ as usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( zonelist_cache ) , "::"
                , stringify ! ( fullzones ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zonelist_cache ) ) . last_full_zap as *
                const _ as usize } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( zonelist_cache ) , "::"
                , stringify ! ( last_full_zap ) ));
}
#[repr(C)]
#[derive(Copy)]
pub struct zoneref {
    pub zone: *mut zone,
    pub zone_idx: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_zoneref() {
    assert_eq!(::std::mem::size_of::<zoneref>() , 16usize , concat ! (
               "Size of: " , stringify ! ( zoneref ) ));
    assert_eq! (::std::mem::align_of::<zoneref>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( zoneref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zoneref ) ) . zone as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zoneref ) , "::" ,
                stringify ! ( zone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zoneref ) ) . zone_idx as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( zoneref ) , "::" ,
                stringify ! ( zone_idx ) ));
}
impl Clone for zoneref {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct zonelist {
    pub zlcache_ptr: *mut zonelist_cache,
    pub _zonerefs: [zoneref; 257usize],
    pub zlcache: zonelist_cache,
}
#[test]
fn bindgen_test_layout_zonelist() {
    assert_eq!(::std::mem::size_of::<zonelist>() , 4672usize , concat ! (
               "Size of: " , stringify ! ( zonelist ) ));
    assert_eq! (::std::mem::align_of::<zonelist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( zonelist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zonelist ) ) . zlcache_ptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zonelist ) , "::" ,
                stringify ! ( zlcache_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zonelist ) ) . _zonerefs as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( zonelist ) , "::" ,
                stringify ! ( _zonerefs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zonelist ) ) . zlcache as * const _ as
                usize } , 4120usize , concat ! (
                "Alignment of field: " , stringify ! ( zonelist ) , "::" ,
                stringify ! ( zlcache ) ));
}
#[repr(C)]
#[derive(Copy)]
pub struct node_active_region {
    pub start_pfn: ::std::os::raw::c_ulong,
    pub end_pfn: ::std::os::raw::c_ulong,
    pub nid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_node_active_region() {
    assert_eq!(::std::mem::size_of::<node_active_region>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( node_active_region ) ));
    assert_eq! (::std::mem::align_of::<node_active_region>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( node_active_region ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const node_active_region ) ) . start_pfn as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( node_active_region ) ,
                "::" , stringify ! ( start_pfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const node_active_region ) ) . end_pfn as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( node_active_region ) ,
                "::" , stringify ! ( end_pfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const node_active_region ) ) . nid as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( node_active_region ) ,
                "::" , stringify ! ( nid ) ));
}
impl Clone for node_active_region {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "mem_map"]
    pub static mut mem_map: *mut page;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bootmem_data {
    _unused: [u8; 0],
}
pub type pg_data_t = pglist_data;
#[repr(C)]
#[derive(Copy)]
pub struct optimistic_spin_node {
    pub next: *mut optimistic_spin_node,
    pub prev: *mut optimistic_spin_node,
    pub locked: ::std::os::raw::c_int,
    pub cpu: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_optimistic_spin_node() {
    assert_eq!(::std::mem::size_of::<optimistic_spin_node>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( optimistic_spin_node )
               ));
    assert_eq! (::std::mem::align_of::<optimistic_spin_node>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( optimistic_spin_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const optimistic_spin_node ) ) . next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( optimistic_spin_node )
                , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const optimistic_spin_node ) ) . prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( optimistic_spin_node )
                , "::" , stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const optimistic_spin_node ) ) . locked as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( optimistic_spin_node )
                , "::" , stringify ! ( locked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const optimistic_spin_node ) ) . cpu as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( optimistic_spin_node )
                , "::" , stringify ! ( cpu ) ));
}
impl Clone for optimistic_spin_node {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct optimistic_spin_queue {
    pub tail: atomic_t,
}
#[test]
fn bindgen_test_layout_optimistic_spin_queue() {
    assert_eq!(::std::mem::size_of::<optimistic_spin_queue>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( optimistic_spin_queue )
               ));
    assert_eq! (::std::mem::align_of::<optimistic_spin_queue>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( optimistic_spin_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const optimistic_spin_queue ) ) . tail as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( optimistic_spin_queue )
                , "::" , stringify ! ( tail ) ));
}
impl Clone for optimistic_spin_queue {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn osq_lock(lock: *mut optimistic_spin_queue) -> bool_;
}
extern "C" {
    pub fn osq_unlock(lock: *mut optimistic_spin_queue);
}
#[repr(C)]
#[derive(Copy)]
pub struct mutex {
    pub count: atomic_t,
    pub wait_lock: spinlock_t,
    pub wait_list: list_head,
    pub owner: *mut task_struct,
    pub osq: optimistic_spin_queue,
}
#[test]
fn bindgen_test_layout_mutex() {
    assert_eq!(::std::mem::size_of::<mutex>() , 40usize , concat ! (
               "Size of: " , stringify ! ( mutex ) ));
    assert_eq! (::std::mem::align_of::<mutex>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mutex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mutex ) ) . count as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mutex ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mutex ) ) . wait_lock as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mutex ) , "::" ,
                stringify ! ( wait_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mutex ) ) . wait_list as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mutex ) , "::" ,
                stringify ! ( wait_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mutex ) ) . owner as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mutex ) , "::" ,
                stringify ! ( owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mutex ) ) . osq as * const _ as usize } ,
                32usize , concat ! (
                "Alignment of field: " , stringify ! ( mutex ) , "::" ,
                stringify ! ( osq ) ));
}
impl Clone for mutex {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct mutex_waiter {
    pub list: list_head,
    pub task: *mut task_struct,
}
#[test]
fn bindgen_test_layout_mutex_waiter() {
    assert_eq!(::std::mem::size_of::<mutex_waiter>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mutex_waiter ) ));
    assert_eq! (::std::mem::align_of::<mutex_waiter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mutex_waiter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mutex_waiter ) ) . list as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mutex_waiter ) , "::" ,
                stringify ! ( list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mutex_waiter ) ) . task as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mutex_waiter ) , "::" ,
                stringify ! ( task ) ));
}
impl Clone for mutex_waiter {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __mutex_init(lock: *mut mutex, name: *const ::std::os::raw::c_char,
                        key: *mut lock_class_key);
}
extern "C" {
    pub fn mutex_lock(lock: *mut mutex);
}
extern "C" {
    pub fn mutex_lock_interruptible(lock: *mut mutex)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mutex_lock_killable(lock: *mut mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mutex_trylock(lock: *mut mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mutex_unlock(lock: *mut mutex);
}
extern "C" {
    pub fn atomic_dec_and_mutex_lock(cnt: *mut atomic_t, lock: *mut mutex)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct rw_semaphore {
    pub count: ::std::os::raw::c_long,
    pub wait_list: list_head,
    pub wait_lock: raw_spinlock_t,
    pub osq: optimistic_spin_queue,
    pub owner: *mut task_struct,
}
#[test]
fn bindgen_test_layout_rw_semaphore() {
    assert_eq!(::std::mem::size_of::<rw_semaphore>() , 40usize , concat ! (
               "Size of: " , stringify ! ( rw_semaphore ) ));
    assert_eq! (::std::mem::align_of::<rw_semaphore>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rw_semaphore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rw_semaphore ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rw_semaphore ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rw_semaphore ) ) . wait_list as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rw_semaphore ) , "::" ,
                stringify ! ( wait_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rw_semaphore ) ) . wait_lock as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rw_semaphore ) , "::" ,
                stringify ! ( wait_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rw_semaphore ) ) . osq as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( rw_semaphore ) , "::" ,
                stringify ! ( osq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rw_semaphore ) ) . owner as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rw_semaphore ) , "::" ,
                stringify ! ( owner ) ));
}
impl Clone for rw_semaphore {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn rwsem_down_read_failed(sem: *mut rw_semaphore)
     -> *mut rw_semaphore;
}
extern "C" {
    pub fn rwsem_down_write_failed(sem: *mut rw_semaphore)
     -> *mut rw_semaphore;
}
extern "C" {
    pub fn rwsem_wake(arg1: *mut rw_semaphore) -> *mut rw_semaphore;
}
extern "C" {
    pub fn rwsem_downgrade_wake(sem: *mut rw_semaphore) -> *mut rw_semaphore;
}
extern "C" {
    pub fn __init_rwsem(sem: *mut rw_semaphore,
                        name: *const ::std::os::raw::c_char,
                        key: *mut lock_class_key);
}
extern "C" {
    pub fn down_read(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn down_read_trylock(sem: *mut rw_semaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn down_write(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn down_write_trylock(sem: *mut rw_semaphore)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn up_read(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn up_write(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn downgrade_write(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn wait_for_completion(arg1: *mut completion);
}
extern "C" {
    pub fn wait_for_completion_io(arg1: *mut completion);
}
extern "C" {
    pub fn wait_for_completion_interruptible(x: *mut completion)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait_for_completion_killable(x: *mut completion)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait_for_completion_timeout(x: *mut completion,
                                       timeout: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wait_for_completion_io_timeout(x: *mut completion,
                                          timeout: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wait_for_completion_interruptible_timeout(x: *mut completion,
                                                     timeout:
                                                         ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wait_for_completion_killable_timeout(x: *mut completion,
                                                timeout:
                                                    ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn try_wait_for_completion(x: *mut completion) -> bool_;
}
extern "C" {
    pub fn completion_done(x: *mut completion) -> bool_;
}
extern "C" {
    pub fn complete(arg1: *mut completion);
}
extern "C" {
    pub fn complete_all(arg1: *mut completion);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum debug_obj_state {
    ODEBUG_STATE_NONE = 0,
    ODEBUG_STATE_INIT = 1,
    ODEBUG_STATE_INACTIVE = 2,
    ODEBUG_STATE_ACTIVE = 3,
    ODEBUG_STATE_DESTROYED = 4,
    ODEBUG_STATE_NOTAVAILABLE = 5,
    ODEBUG_STATE_MAX = 6,
}
/// struct debug_obj_descr - object type specific debug description structure
///
/// @name:		name of the object typee
/// @debug_hint:		function returning address, which have associated
/// kernel symbol, to allow identify the object
/// @fixup_init:		fixup function, which is called when the init check
/// fails
/// @fixup_activate:	fixup function, which is called when the activate check
/// fails
/// @fixup_destroy:	fixup function, which is called when the destroy check
/// fails
/// @fixup_free:		fixup function, which is called when the free check
/// fails
/// @fixup_assert_init:  fixup function, which is called when the assert_init
/// check fails
#[repr(C)]
#[derive(Copy)]
pub struct debug_obj_descr {
    pub name: *const ::std::os::raw::c_char,
    pub debug_hint: ::std::option::Option<unsafe extern "C" fn(addr:
                                                                   *mut ::std::os::raw::c_void)
                                              -> *mut ::std::os::raw::c_void>,
    pub fixup_init: ::std::option::Option<unsafe extern "C" fn(addr:
                                                                   *mut ::std::os::raw::c_void,
                                                               state:
                                                                   debug_obj_state)
                                              -> ::std::os::raw::c_int>,
    pub fixup_activate: ::std::option::Option<unsafe extern "C" fn(addr:
                                                                       *mut ::std::os::raw::c_void,
                                                                   state:
                                                                       debug_obj_state)
                                                  -> ::std::os::raw::c_int>,
    pub fixup_destroy: ::std::option::Option<unsafe extern "C" fn(addr:
                                                                      *mut ::std::os::raw::c_void,
                                                                  state:
                                                                      debug_obj_state)
                                                 -> ::std::os::raw::c_int>,
    pub fixup_free: ::std::option::Option<unsafe extern "C" fn(addr:
                                                                   *mut ::std::os::raw::c_void,
                                                               state:
                                                                   debug_obj_state)
                                              -> ::std::os::raw::c_int>,
    pub fixup_assert_init: ::std::option::Option<unsafe extern "C" fn(addr:
                                                                          *mut ::std::os::raw::c_void,
                                                                      state:
                                                                          debug_obj_state)
                                                     ->
                                                         ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_debug_obj_descr() {
    assert_eq!(::std::mem::size_of::<debug_obj_descr>() , 56usize , concat ! (
               "Size of: " , stringify ! ( debug_obj_descr ) ));
    assert_eq! (::std::mem::align_of::<debug_obj_descr>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( debug_obj_descr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const debug_obj_descr ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( debug_obj_descr ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const debug_obj_descr ) ) . debug_hint as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( debug_obj_descr ) ,
                "::" , stringify ! ( debug_hint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const debug_obj_descr ) ) . fixup_init as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( debug_obj_descr ) ,
                "::" , stringify ! ( fixup_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const debug_obj_descr ) ) . fixup_activate as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( debug_obj_descr ) ,
                "::" , stringify ! ( fixup_activate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const debug_obj_descr ) ) . fixup_destroy as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( debug_obj_descr ) ,
                "::" , stringify ! ( fixup_destroy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const debug_obj_descr ) ) . fixup_free as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( debug_obj_descr ) ,
                "::" , stringify ! ( fixup_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const debug_obj_descr ) ) . fixup_assert_init
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( debug_obj_descr ) ,
                "::" , stringify ! ( fixup_assert_init ) ));
}
impl Clone for debug_obj_descr {
    fn clone(&self) -> Self { *self }
}
/// struct debug_obj - representaion of an tracked object
/// @node:	hlist node to link the object into the tracker list
/// @state:	tracked object state
/// @astate:	current active state
/// @object:	pointer to the real object
/// @descr:	pointer to an object type specific debug description structure
#[repr(C)]
#[derive(Copy)]
pub struct debug_obj {
    pub node: hlist_node,
    pub state: debug_obj_state,
    pub astate: ::std::os::raw::c_uint,
    pub object: *mut ::std::os::raw::c_void,
    pub descr: *mut debug_obj_descr,
}
#[test]
fn bindgen_test_layout_debug_obj() {
    assert_eq!(::std::mem::size_of::<debug_obj>() , 40usize , concat ! (
               "Size of: " , stringify ! ( debug_obj ) ));
    assert_eq! (::std::mem::align_of::<debug_obj>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( debug_obj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const debug_obj ) ) . node as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( debug_obj ) , "::" ,
                stringify ! ( node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const debug_obj ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( debug_obj ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const debug_obj ) ) . astate as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( debug_obj ) , "::" ,
                stringify ! ( astate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const debug_obj ) ) . object as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( debug_obj ) , "::" ,
                stringify ! ( object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const debug_obj ) ) . descr as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( debug_obj ) , "::" ,
                stringify ! ( descr ) ));
}
impl Clone for debug_obj {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct timeval {
    pub tv_sec: __kernel_time_t,
    pub tv_usec: __kernel_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::std::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::std::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::std::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::std::mem::size_of::<itimerval>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerval ) ));
    assert_eq! (::std::mem::align_of::<itimerval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
pub type time64_t = __s64;
extern "C" {
    #[link_name = "sys_tz"]
    pub static mut sys_tz: timezone;
}
extern "C" {
    pub fn mktime64(year: ::std::os::raw::c_uint, mon: ::std::os::raw::c_uint,
                    day: ::std::os::raw::c_uint, hour: ::std::os::raw::c_uint,
                    min: ::std::os::raw::c_uint, sec: ::std::os::raw::c_uint)
     -> time64_t;
}
extern "C" {
    pub fn set_normalized_timespec(ts: *mut timespec, sec: time_t, nsec: s64);
}
extern "C" {
    pub fn timespec_add_safe(lhs: timespec, rhs: timespec) -> timespec;
}
extern "C" {
    pub fn timespec_trunc(t: timespec, gran: ::std::os::raw::c_uint)
     -> timespec;
}
extern "C" {
    pub fn do_setitimer(which: ::std::os::raw::c_int, value: *mut itimerval,
                        ovalue: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_getitimer(which: ::std::os::raw::c_int, value: *mut itimerval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm_setitimer(seconds: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn do_utimes(dfd: ::std::os::raw::c_int,
                     filename: *const ::std::os::raw::c_char,
                     times: *mut timespec, flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_long;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tms {
    _unused: [u8; 0],
}
extern "C" {
    pub fn do_sys_times(arg1: *mut tms);
}
#[repr(C)]
#[derive(Copy)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_long,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 40usize , concat ! (
               "Size of: " , stringify ! ( tm ) ));
    assert_eq! (::std::mem::align_of::<tm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_sec as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_min as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_hour as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mday as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mon as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_year as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_wday as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_yday as * const _ as usize }
                , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_yday ) ));
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn time_to_tm(totalsecs: time_t, offset: ::std::os::raw::c_int,
                      result: *mut tm);
}
extern "C" {
    /// ns_to_timespec - Convert nanoseconds to timespec
/// @nsec:	the nanoseconds value to be converted
///
/// Returns the timespec representation of the nsec parameter.
    pub fn ns_to_timespec(nsec: s64) -> timespec;
}
extern "C" {
    /// ns_to_timeval - Convert nanoseconds to timeval
/// @nsec:	the nanoseconds value to be converted
///
/// Returns the timeval representation of the nsec parameter.
    pub fn ns_to_timeval(nsec: s64) -> timeval;
}
#[repr(C)]
#[derive(Copy)]
pub struct timex {
    pub modes: ::std::os::raw::c_uint,
    pub offset: __kernel_long_t,
    pub freq: __kernel_long_t,
    pub maxerror: __kernel_long_t,
    pub esterror: __kernel_long_t,
    pub status: ::std::os::raw::c_int,
    pub constant: __kernel_long_t,
    pub precision: __kernel_long_t,
    pub tolerance: __kernel_long_t,
    pub time: timeval,
    pub tick: __kernel_long_t,
    pub ppsfreq: __kernel_long_t,
    pub jitter: __kernel_long_t,
    pub shift: ::std::os::raw::c_int,
    pub stabil: __kernel_long_t,
    pub jitcnt: __kernel_long_t,
    pub calcnt: __kernel_long_t,
    pub errcnt: __kernel_long_t,
    pub stbcnt: __kernel_long_t,
    pub tai: ::std::os::raw::c_int,
    pub _bitfield_1: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_timex() {
    assert_eq!(::std::mem::size_of::<timex>() , 208usize , concat ! (
               "Size of: " , stringify ! ( timex ) ));
    assert_eq! (::std::mem::align_of::<timex>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . modes as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( modes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . offset as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . freq as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( freq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . maxerror as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( maxerror ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . esterror as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( esterror ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . status as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . constant as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( constant ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . precision as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( precision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . tolerance as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( tolerance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . time as * const _ as usize }
                , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . tick as * const _ as usize }
                , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( tick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . ppsfreq as * const _ as usize
                } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( ppsfreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . jitter as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( jitter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . shift as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( shift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . stabil as * const _ as usize
                } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( stabil ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . jitcnt as * const _ as usize
                } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( jitcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . calcnt as * const _ as usize
                } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( calcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . errcnt as * const _ as usize
                } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( errcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . stbcnt as * const _ as usize
                } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( stbcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timex ) ) . tai as * const _ as usize } ,
                160usize , concat ! (
                "Alignment of field: " , stringify ! ( timex ) , "::" ,
                stringify ! ( tai ) ));
}
impl Clone for timex {
    fn clone(&self) -> Self { *self }
}
pub type cycles_t = ::std::os::raw::c_ulonglong;
extern "C" {
    #[link_name = "cpu_khz"]
    pub static mut cpu_khz: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "tsc_khz"]
    pub static mut tsc_khz: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn disable_TSC();
}
extern "C" {
    pub fn tsc_init();
}
extern "C" {
    pub fn mark_tsc_unstable(reason: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn unsynchronized_tsc() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn check_tsc_unstable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn check_tsc_disabled() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_calibrate_tsc() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn native_sched_clock_from_tsc(tsc: u64)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "tsc_clocksource_reliable"]
    pub static mut tsc_clocksource_reliable: ::std::os::raw::c_int;
}
extern "C" {
    pub fn check_tsc_sync_source(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn check_tsc_sync_target();
}
extern "C" {
    pub fn notsc_setup(arg1: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tsc_save_sched_clock_state();
}
extern "C" {
    pub fn tsc_restore_sched_clock_state();
}
extern "C" {
    pub fn try_msr_calibrate_tsc() -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "tick_usec"]
    pub static mut tick_usec: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "tick_nsec"]
    pub static mut tick_nsec: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn do_adjtimex(arg1: *mut timex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hardpps(arg1: *const timespec, arg2: *const timespec);
}
extern "C" {
    pub fn read_current_timer(timer_val: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ntp_notify_cmos_timer();
}
extern "C" {
    pub fn register_refined_jiffies(clock_tick_rate: ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "jiffies_64"]
    pub static mut jiffies_64: u64;
}
extern "C" {
    #[link_name = "jiffies"]
    pub static mut jiffies: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "preset_lpj"]
    pub static mut preset_lpj: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn jiffies_to_msecs(j: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn jiffies_to_usecs(j: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __msecs_to_jiffies(m: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __usecs_to_jiffies(u: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn timespec_to_jiffies(value: *const timespec)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn jiffies_to_timespec(jiffies: ::std::os::raw::c_ulong,
                               value: *mut timespec);
}
extern "C" {
    pub fn timeval_to_jiffies(value: *const timeval)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn jiffies_to_timeval(jiffies: ::std::os::raw::c_ulong,
                              value: *mut timeval);
}
extern "C" {
    pub fn jiffies_to_clock_t(x: ::std::os::raw::c_ulong) -> clock_t;
}
extern "C" {
    pub fn clock_t_to_jiffies(x: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn jiffies_64_to_clock_t(x: u64) -> u64;
}
extern "C" {
    pub fn nsec_to_clock_t(x: u64) -> u64;
}
extern "C" {
    pub fn nsecs_to_jiffies64(n: u64) -> u64;
}
extern "C" {
    pub fn nsecs_to_jiffies(n: u64) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Copy)]
pub struct ktime {
    pub tv64: __BindgenUnionField<s64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_ktime() {
    assert_eq!(::std::mem::size_of::<ktime>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ktime ) ));
    assert_eq! (::std::mem::align_of::<ktime>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ktime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktime ) ) . tv64 as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ktime ) , "::" ,
                stringify ! ( tv64 ) ));
}
impl Clone for ktime {
    fn clone(&self) -> Self { *self }
}
pub type ktime_t = ktime;
extern "C" {
    pub fn ktime_add_safe(lhs: ktime_t, rhs: ktime_t) -> ktime_t;
}
extern "C" {
    pub fn timekeeping_init();
}
extern "C" {
    #[link_name = "timekeeping_suspended"]
    pub static mut timekeeping_suspended: ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_gettimeofday(tv: *mut timeval);
}
extern "C" {
    pub fn do_settimeofday64(ts: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_sys_settimeofday(tv: *const timespec, tz: *const timezone)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_seconds() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn current_kernel_time() -> timespec;
}
extern "C" {
    pub fn __current_kernel_time() -> timespec;
}
extern "C" {
    pub fn get_monotonic_coarse64() -> timespec;
}
extern "C" {
    pub fn getrawmonotonic64(ts: *mut timespec);
}
extern "C" {
    pub fn ktime_get_ts64(ts: *mut timespec);
}
extern "C" {
    pub fn ktime_get_seconds() -> time64_t;
}
extern "C" {
    pub fn ktime_get_real_seconds() -> time64_t;
}
extern "C" {
    pub fn __getnstimeofday64(tv: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnstimeofday64(tv: *mut timespec);
}
extern "C" {
    pub fn getboottime64(ts: *mut timespec);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum tk_offsets {
    TK_OFFS_REAL = 0,
    TK_OFFS_BOOT = 1,
    TK_OFFS_TAI = 2,
    TK_OFFS_MAX = 3,
}
extern "C" {
    pub fn ktime_get() -> ktime_t;
}
extern "C" {
    pub fn ktime_get_with_offset(offs: tk_offsets) -> ktime_t;
}
extern "C" {
    pub fn ktime_mono_to_any(tmono: ktime_t, offs: tk_offsets) -> ktime_t;
}
extern "C" {
    pub fn ktime_get_raw() -> ktime_t;
}
extern "C" {
    pub fn ktime_get_resolution_ns() -> u32;
}
extern "C" {
    pub fn ktime_get_mono_fast_ns() -> u64;
}
extern "C" {
    pub fn ktime_get_raw_fast_ns() -> u64;
}
extern "C" {
    pub fn timekeeping_rtc_skipsuspend() -> bool_;
}
extern "C" {
    pub fn timekeeping_rtc_skipresume() -> bool_;
}
extern "C" {
    pub fn timekeeping_inject_sleeptime64(delta: *mut timespec);
}
extern "C" {
    pub fn getnstime_raw_and_real(ts_raw: *mut timespec,
                                  ts_real: *mut timespec);
}
extern "C" {
    #[link_name = "persistent_clock_is_local"]
    pub static mut persistent_clock_is_local: ::std::os::raw::c_int;
}
extern "C" {
    pub fn read_persistent_clock(ts: *mut timespec);
}
extern "C" {
    pub fn read_persistent_clock64(ts: *mut timespec);
}
extern "C" {
    pub fn read_boot_clock64(ts: *mut timespec);
}
extern "C" {
    pub fn update_persistent_clock(now: timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn update_persistent_clock64(now: timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "rcu_expedited"]
    pub static mut rcu_expedited: ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcu_gp_is_expedited() -> bool_;
}
extern "C" {
    pub fn rcu_expedite_gp();
}
extern "C" {
    pub fn rcu_unexpedite_gp();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rcutorture_type {
    RCU_FLAVOR = 0,
    RCU_BH_FLAVOR = 1,
    RCU_SCHED_FLAVOR = 2,
    RCU_TASKS_FLAVOR = 3,
    SRCU_FLAVOR = 4,
    INVALID_RCU_FLAVOR = 5,
}
extern "C" {
    pub fn rcutorture_get_gp_data(test_type: rcutorture_type,
                                  flags: *mut ::std::os::raw::c_int,
                                  gpnum: *mut ::std::os::raw::c_ulong,
                                  completed: *mut ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn rcutorture_record_test_transition();
}
extern "C" {
    pub fn rcutorture_record_progress(vernum: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn do_trace_rcu_torture_read(rcutorturename:
                                         *const ::std::os::raw::c_char,
                                     rhp: *mut callback_head,
                                     secs: ::std::os::raw::c_ulong,
                                     c_old: ::std::os::raw::c_ulong,
                                     c: ::std::os::raw::c_ulong);
}
extern "C" {
    /// call_rcu_bh() - Queue an RCU for invocation after a quicker grace period.
/// @head: structure to be used for queueing the RCU updates.
/// @func: actual callback function to be invoked after the grace period
///
/// The callback function will be invoked some time after a full grace
/// period elapses, in other words after all currently executing RCU
/// read-side critical sections have completed. call_rcu_bh() assumes
/// that the read-side critical sections end on completion of a softirq
/// handler. This means that read-side critical sections in process
/// context must not be interrupted by softirqs. This interface is to be
/// used when most of the read-side critical sections are in softirq context.
/// RCU read-side critical sections are delimited by :
/// - rcu_read_lock() and  rcu_read_unlock(), if in interrupt context.
/// OR
/// - rcu_read_lock_bh() and rcu_read_unlock_bh(), if in process context.
/// These may be nested.
///
/// See the description of call_rcu() for more detailed information on
/// memory ordering guarantees.
    pub fn call_rcu_bh(head: *mut callback_head,
                       func:
                           ::std::option::Option<unsafe extern "C" fn(head:
                                                                          *mut callback_head)>);
}
extern "C" {
    /// call_rcu_sched() - Queue an RCU for invocation after sched grace period.
/// @head: structure to be used for queueing the RCU updates.
/// @func: actual callback function to be invoked after the grace period
///
/// The callback function will be invoked some time after a full grace
/// period elapses, in other words after all currently executing RCU
/// read-side critical sections have completed. call_rcu_sched() assumes
/// that the read-side critical sections end on enabling of preemption
/// or on voluntary preemption.
/// RCU read-side critical sections are delimited by :
/// - rcu_read_lock_sched() and  rcu_read_unlock_sched(),
/// OR
/// anything that disables preemption.
/// These may be nested.
///
/// See the description of call_rcu() for more detailed information on
/// memory ordering guarantees.
    pub fn call_rcu_sched(head: *mut callback_head,
                          func:
                              ::std::option::Option<unsafe extern "C" fn(rcu:
                                                                             *mut callback_head)>);
}
extern "C" {
    pub fn synchronize_sched();
}
#[repr(C)]
#[derive(Copy)]
pub struct rcu_synchronize {
    pub head: callback_head,
    pub completion: completion,
}
#[test]
fn bindgen_test_layout_rcu_synchronize() {
    assert_eq!(::std::mem::size_of::<rcu_synchronize>() , 48usize , concat ! (
               "Size of: " , stringify ! ( rcu_synchronize ) ));
    assert_eq! (::std::mem::align_of::<rcu_synchronize>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rcu_synchronize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rcu_synchronize ) ) . head as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rcu_synchronize ) ,
                "::" , stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rcu_synchronize ) ) . completion as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rcu_synchronize ) ,
                "::" , stringify ! ( completion ) ));
}
impl Clone for rcu_synchronize {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn wakeme_after_rcu(head: *mut callback_head);
}
extern "C" {
    /// call_rcu_tasks() - Queue an RCU for invocation task-based grace period
/// @head: structure to be used for queueing the RCU updates.
/// @func: actual callback function to be invoked after the grace period
///
/// The callback function will be invoked some time after a full grace
/// period elapses, in other words after all currently executing RCU
/// read-side critical sections have completed. call_rcu_tasks() assumes
/// that the read-side critical sections end at a voluntary context
/// switch (not a preemption!), entry into idle, or transition to usermode
/// execution.  As such, there are no read-side primitives analogous to
/// rcu_read_lock() and rcu_read_unlock() because this primitive is intended
/// to determine that all tasks have passed through a safe state, not so
/// much for data-strcuture synchronization.
///
/// See the description of call_rcu() for more detailed information on
/// memory ordering guarantees.
    pub fn call_rcu_tasks(head: *mut callback_head,
                          func:
                              ::std::option::Option<unsafe extern "C" fn(head:
                                                                             *mut callback_head)>);
}
extern "C" {
    pub fn synchronize_rcu_tasks();
}
extern "C" {
    pub fn rcu_barrier_tasks();
}
extern "C" {
    pub fn rcu_init();
}
extern "C" {
    pub fn rcu_end_inkernel_boot();
}
extern "C" {
    pub fn rcu_sched_qs();
}
extern "C" {
    pub fn rcu_bh_qs();
}
extern "C" {
    pub fn rcu_check_callbacks(user: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Copy)]
pub struct notifier_block {
    pub notifier_call: notifier_fn_t,
    pub next: *mut notifier_block,
    pub priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_notifier_block() {
    assert_eq!(::std::mem::size_of::<notifier_block>() , 24usize , concat ! (
               "Size of: " , stringify ! ( notifier_block ) ));
    assert_eq! (::std::mem::align_of::<notifier_block>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( notifier_block ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const notifier_block ) ) . notifier_call as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( notifier_block ) , "::"
                , stringify ! ( notifier_call ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const notifier_block ) ) . next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( notifier_block ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const notifier_block ) ) . priority as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( notifier_block ) , "::"
                , stringify ! ( priority ) ));
}
impl Clone for notifier_block {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn rcu_cpu_notify(self_: *mut notifier_block,
                          action: ::std::os::raw::c_ulong,
                          hcpu: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcu_sysrq_start();
}
extern "C" {
    pub fn rcu_sysrq_end();
}
extern "C" {
    pub fn rcu_init_nohz();
}
extern "C" {
    pub fn __rcu_is_watching() -> bool_;
}
pub type call_rcu_func_t =
    ::std::option::Option<unsafe extern "C" fn(head: *mut callback_head,
                                               func:
                                                   ::std::option::Option<unsafe extern "C" fn(head:
                                                                                                  *mut callback_head)>)>;
extern "C" {
    pub fn wait_rcu_gp(crf: call_rcu_func_t);
}
extern "C" {
    pub fn rcu_note_context_switch();
}
extern "C" {
    pub fn rcu_needs_cpu(basem: u64, nextevt: *mut u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcu_cpu_stall_reset();
}
extern "C" {
    pub fn synchronize_rcu_bh();
}
extern "C" {
    pub fn synchronize_sched_expedited();
}
extern "C" {
    pub fn synchronize_rcu_expedited();
}
extern "C" {
    pub fn kfree_call_rcu(head: *mut callback_head,
                          func:
                              ::std::option::Option<unsafe extern "C" fn(rcu:
                                                                             *mut callback_head)>);
}
extern "C" {
    pub fn rcu_barrier();
}
extern "C" {
    pub fn rcu_barrier_bh();
}
extern "C" {
    pub fn rcu_barrier_sched();
}
extern "C" {
    pub fn get_state_synchronize_rcu() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn cond_synchronize_rcu(oldstate: ::std::os::raw::c_ulong);
}
extern "C" {
    #[link_name = "rcutorture_testseq"]
    pub static mut rcutorture_testseq: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "rcutorture_vernum"]
    pub static mut rcutorture_vernum: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rcu_batches_started() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rcu_batches_started_bh() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rcu_batches_started_sched() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rcu_batches_completed() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rcu_batches_completed_bh() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rcu_batches_completed_sched() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn show_rcu_gp_kthreads();
}
extern "C" {
    pub fn rcu_force_quiescent_state();
}
extern "C" {
    pub fn rcu_bh_force_quiescent_state();
}
extern "C" {
    pub fn rcu_sched_force_quiescent_state();
}
extern "C" {
    pub fn rcu_idle_enter();
}
extern "C" {
    pub fn rcu_idle_exit();
}
extern "C" {
    pub fn rcu_irq_enter();
}
extern "C" {
    pub fn rcu_irq_exit();
}
extern "C" {
    pub fn exit_rcu();
}
extern "C" {
    pub fn rcu_scheduler_starting();
}
extern "C" {
    #[link_name = "rcu_scheduler_active"]
    pub static mut rcu_scheduler_active: ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcu_is_watching() -> bool_;
}
extern "C" {
    pub fn rcu_all_qs();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tvec_base {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct timer_list {
    pub entry: hlist_node,
    pub expires: ::std::os::raw::c_ulong,
    pub function: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 ::std::os::raw::c_ulong)>,
    pub data: ::std::os::raw::c_ulong,
    pub flags: u32,
    pub slack: ::std::os::raw::c_int,
    pub start_pid: ::std::os::raw::c_int,
    pub start_site: *mut ::std::os::raw::c_void,
    pub start_comm: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_timer_list() {
    assert_eq!(::std::mem::size_of::<timer_list>() , 80usize , concat ! (
               "Size of: " , stringify ! ( timer_list ) ));
    assert_eq! (::std::mem::align_of::<timer_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timer_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timer_list ) ) . entry as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timer_list ) , "::" ,
                stringify ! ( entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timer_list ) ) . expires as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( timer_list ) , "::" ,
                stringify ! ( expires ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timer_list ) ) . function as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( timer_list ) , "::" ,
                stringify ! ( function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timer_list ) ) . data as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( timer_list ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timer_list ) ) . flags as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( timer_list ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timer_list ) ) . slack as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( timer_list ) , "::" ,
                stringify ! ( slack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timer_list ) ) . start_pid as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( timer_list ) , "::" ,
                stringify ! ( start_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timer_list ) ) . start_site as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( timer_list ) , "::" ,
                stringify ! ( start_site ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timer_list ) ) . start_comm as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( timer_list ) , "::" ,
                stringify ! ( start_comm ) ));
}
impl Clone for timer_list {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn init_timer_key(timer: *mut timer_list,
                          flags: ::std::os::raw::c_uint,
                          name: *const ::std::os::raw::c_char,
                          key: *mut lock_class_key);
}
extern "C" {
    pub fn add_timer_on(timer: *mut timer_list, cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn del_timer(timer: *mut timer_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mod_timer(timer: *mut timer_list, expires: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mod_timer_pending(timer: *mut timer_list,
                             expires: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mod_timer_pinned(timer: *mut timer_list,
                            expires: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_timer_slack(time: *mut timer_list,
                           slack_hz: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "timer_stats_active"]
    pub static mut timer_stats_active: ::std::os::raw::c_int;
}
extern "C" {
    pub fn init_timer_stats();
}
extern "C" {
    pub fn timer_stats_update_stats(timer: *mut ::std::os::raw::c_void,
                                    pid: pid_t,
                                    startf: *mut ::std::os::raw::c_void,
                                    timerf: *mut ::std::os::raw::c_void,
                                    comm: *mut ::std::os::raw::c_char,
                                    flags: u32);
}
extern "C" {
    pub fn __timer_stats_timer_set_start_info(timer: *mut timer_list,
                                              addr:
                                                  *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn add_timer(timer: *mut timer_list);
}
extern "C" {
    pub fn try_to_del_timer_sync(timer: *mut timer_list)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn del_timer_sync(timer: *mut timer_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn init_timers();
}
extern "C" {
    pub fn run_local_timers();
}
/// struct hrtimer - the basic hrtimer structure
/// @node:	timerqueue node, which also manages node.expires,
/// the absolute expiry time in the hrtimers internal
/// representation. The time is related to the clock on
/// which the timer is based. Is setup by adding
/// slack to the _softexpires value. For non range timers
/// identical to _softexpires.
/// @_softexpires: the absolute earliest expiry time of the hrtimer.
/// The time which was given as expiry time when the timer
/// was armed.
/// @function:	timer expiry callback function
/// @base:	pointer to the timer base (per cpu and per clock)
/// @state:	state information (See bit values above)
/// @is_rel:	Set if the timer was armed relative
/// @start_pid:  timer statistics field to store the pid of the task which
/// started the timer
/// @start_site:	timer statistics field to store the site where the timer
/// was started
/// @start_comm: timer statistics field to store the name of the process which
/// started the timer
///
/// The hrtimer structure must be initialized by hrtimer_init()
#[repr(C)]
#[derive(Copy)]
pub struct hrtimer {
    pub node: timerqueue_node,
    pub _softexpires: ktime_t,
    pub function: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut hrtimer)
                                            -> hrtimer_restart>,
    pub base: *mut hrtimer_clock_base,
    pub state: u8,
    pub is_rel: u8,
    pub start_pid: ::std::os::raw::c_int,
    pub start_site: *mut ::std::os::raw::c_void,
    pub start_comm: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_hrtimer() {
    assert_eq!(::std::mem::size_of::<hrtimer>() , 88usize , concat ! (
               "Size of: " , stringify ! ( hrtimer ) ));
    assert_eq! (::std::mem::align_of::<hrtimer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( hrtimer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer ) ) . node as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer ) , "::" ,
                stringify ! ( node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer ) ) . _softexpires as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer ) , "::" ,
                stringify ! ( _softexpires ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer ) ) . function as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer ) , "::" ,
                stringify ! ( function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer ) ) . base as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer ) , "::" ,
                stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer ) ) . state as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer ) ) . is_rel as * const _ as
                usize } , 57usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer ) , "::" ,
                stringify ! ( is_rel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer ) ) . start_pid as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer ) , "::" ,
                stringify ! ( start_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer ) ) . start_site as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer ) , "::" ,
                stringify ! ( start_site ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer ) ) . start_comm as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer ) , "::" ,
                stringify ! ( start_comm ) ));
}
impl Clone for hrtimer {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn it_real_fn(arg1: *mut hrtimer) -> hrtimer_restart;
}
#[repr(C)]
#[derive(Copy)]
pub struct rb_node {
    pub __rb_parent_color: ::std::os::raw::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_node() {
    assert_eq!(::std::mem::size_of::<rb_node>() , 24usize , concat ! (
               "Size of: " , stringify ! ( rb_node ) ));
    assert_eq! (::std::mem::align_of::<rb_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rb_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rb_node ) ) . __rb_parent_color as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rb_node ) , "::" ,
                stringify ! ( __rb_parent_color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rb_node ) ) . rb_right as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rb_node ) , "::" ,
                stringify ! ( rb_right ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rb_node ) ) . rb_left as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rb_node ) , "::" ,
                stringify ! ( rb_left ) ));
}
impl Clone for rb_node {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rb_root {
    pub rb_node: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_root() {
    assert_eq!(::std::mem::size_of::<rb_root>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rb_root ) ));
    assert_eq! (::std::mem::align_of::<rb_root>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rb_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rb_root ) ) . rb_node as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rb_root ) , "::" ,
                stringify ! ( rb_node ) ));
}
impl Clone for rb_root {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn rb_insert_color(arg1: *mut rb_node, arg2: *mut rb_root);
}
extern "C" {
    pub fn rb_erase(arg1: *mut rb_node, arg2: *mut rb_root);
}
extern "C" {
    pub fn rb_next(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_prev(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_first(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_last(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_first_postorder(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_next_postorder(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_replace_node(victim: *mut rb_node, new: *mut rb_node,
                           root: *mut rb_root);
}
#[repr(C)]
#[derive(Copy)]
pub struct __sysctl_args {
    pub name: *mut ::std::os::raw::c_int,
    pub nlen: ::std::os::raw::c_int,
    pub oldval: *mut ::std::os::raw::c_void,
    pub oldlenp: *mut usize,
    pub newval: *mut ::std::os::raw::c_void,
    pub newlen: usize,
    pub __unused: [::std::os::raw::c_ulong; 4usize],
}
#[test]
fn bindgen_test_layout___sysctl_args() {
    assert_eq!(::std::mem::size_of::<__sysctl_args>() , 80usize , concat ! (
               "Size of: " , stringify ! ( __sysctl_args ) ));
    assert_eq! (::std::mem::align_of::<__sysctl_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sysctl_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sysctl_args ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sysctl_args ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sysctl_args ) ) . nlen as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sysctl_args ) , "::"
                , stringify ! ( nlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sysctl_args ) ) . oldval as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sysctl_args ) , "::"
                , stringify ! ( oldval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sysctl_args ) ) . oldlenp as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sysctl_args ) , "::"
                , stringify ! ( oldlenp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sysctl_args ) ) . newval as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __sysctl_args ) , "::"
                , stringify ! ( newval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sysctl_args ) ) . newlen as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sysctl_args ) , "::"
                , stringify ! ( newlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sysctl_args ) ) . __unused as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sysctl_args ) , "::"
                , stringify ! ( __unused ) ));
}
impl Clone for __sysctl_args {
    fn clone(&self) -> Self { *self }
}
pub const CTL_KERN: _bindgen_ty_8 = _bindgen_ty_8::CTL_KERN;
pub const CTL_VM: _bindgen_ty_8 = _bindgen_ty_8::CTL_VM;
pub const CTL_NET: _bindgen_ty_8 = _bindgen_ty_8::CTL_NET;
pub const CTL_PROC: _bindgen_ty_8 = _bindgen_ty_8::CTL_PROC;
pub const CTL_FS: _bindgen_ty_8 = _bindgen_ty_8::CTL_FS;
pub const CTL_DEBUG: _bindgen_ty_8 = _bindgen_ty_8::CTL_DEBUG;
pub const CTL_DEV: _bindgen_ty_8 = _bindgen_ty_8::CTL_DEV;
pub const CTL_BUS: _bindgen_ty_8 = _bindgen_ty_8::CTL_BUS;
pub const CTL_ABI: _bindgen_ty_8 = _bindgen_ty_8::CTL_ABI;
pub const CTL_CPU: _bindgen_ty_8 = _bindgen_ty_8::CTL_CPU;
pub const CTL_ARLAN: _bindgen_ty_8 = _bindgen_ty_8::CTL_ARLAN;
pub const CTL_S390DBF: _bindgen_ty_8 = _bindgen_ty_8::CTL_S390DBF;
pub const CTL_SUNRPC: _bindgen_ty_8 = _bindgen_ty_8::CTL_SUNRPC;
pub const CTL_PM: _bindgen_ty_8 = _bindgen_ty_8::CTL_PM;
pub const CTL_FRV: _bindgen_ty_8 = _bindgen_ty_8::CTL_FRV;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    CTL_KERN = 1,
    CTL_VM = 2,
    CTL_NET = 3,
    CTL_PROC = 4,
    CTL_FS = 5,
    CTL_DEBUG = 6,
    CTL_DEV = 7,
    CTL_BUS = 8,
    CTL_ABI = 9,
    CTL_CPU = 10,
    CTL_ARLAN = 254,
    CTL_S390DBF = 5677,
    CTL_SUNRPC = 7249,
    CTL_PM = 9899,
    CTL_FRV = 9898,
}
pub const CTL_BUS_ISA: _bindgen_ty_9 = _bindgen_ty_9::CTL_BUS_ISA;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 { CTL_BUS_ISA = 1, }
pub const INOTIFY_MAX_USER_INSTANCES: _bindgen_ty_10 =
    _bindgen_ty_10::INOTIFY_MAX_USER_INSTANCES;
pub const INOTIFY_MAX_USER_WATCHES: _bindgen_ty_10 =
    _bindgen_ty_10::INOTIFY_MAX_USER_WATCHES;
pub const INOTIFY_MAX_QUEUED_EVENTS: _bindgen_ty_10 =
    _bindgen_ty_10::INOTIFY_MAX_QUEUED_EVENTS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    INOTIFY_MAX_USER_INSTANCES = 1,
    INOTIFY_MAX_USER_WATCHES = 2,
    INOTIFY_MAX_QUEUED_EVENTS = 3,
}
pub const KERN_OSTYPE: _bindgen_ty_11 = _bindgen_ty_11::KERN_OSTYPE;
pub const KERN_OSRELEASE: _bindgen_ty_11 = _bindgen_ty_11::KERN_OSRELEASE;
pub const KERN_OSREV: _bindgen_ty_11 = _bindgen_ty_11::KERN_OSREV;
pub const KERN_VERSION: _bindgen_ty_11 = _bindgen_ty_11::KERN_VERSION;
pub const KERN_SECUREMASK: _bindgen_ty_11 = _bindgen_ty_11::KERN_SECUREMASK;
pub const KERN_PROF: _bindgen_ty_11 = _bindgen_ty_11::KERN_PROF;
pub const KERN_NODENAME: _bindgen_ty_11 = _bindgen_ty_11::KERN_NODENAME;
pub const KERN_DOMAINNAME: _bindgen_ty_11 = _bindgen_ty_11::KERN_DOMAINNAME;
pub const KERN_PANIC: _bindgen_ty_11 = _bindgen_ty_11::KERN_PANIC;
pub const KERN_REALROOTDEV: _bindgen_ty_11 = _bindgen_ty_11::KERN_REALROOTDEV;
pub const KERN_SPARC_REBOOT: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_SPARC_REBOOT;
pub const KERN_CTLALTDEL: _bindgen_ty_11 = _bindgen_ty_11::KERN_CTLALTDEL;
pub const KERN_PRINTK: _bindgen_ty_11 = _bindgen_ty_11::KERN_PRINTK;
pub const KERN_NAMETRANS: _bindgen_ty_11 = _bindgen_ty_11::KERN_NAMETRANS;
pub const KERN_PPC_HTABRECLAIM: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_PPC_HTABRECLAIM;
pub const KERN_PPC_ZEROPAGED: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_PPC_ZEROPAGED;
pub const KERN_PPC_POWERSAVE_NAP: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_PPC_POWERSAVE_NAP;
pub const KERN_MODPROBE: _bindgen_ty_11 = _bindgen_ty_11::KERN_MODPROBE;
pub const KERN_SG_BIG_BUFF: _bindgen_ty_11 = _bindgen_ty_11::KERN_SG_BIG_BUFF;
pub const KERN_ACCT: _bindgen_ty_11 = _bindgen_ty_11::KERN_ACCT;
pub const KERN_PPC_L2CR: _bindgen_ty_11 = _bindgen_ty_11::KERN_PPC_L2CR;
pub const KERN_RTSIGNR: _bindgen_ty_11 = _bindgen_ty_11::KERN_RTSIGNR;
pub const KERN_RTSIGMAX: _bindgen_ty_11 = _bindgen_ty_11::KERN_RTSIGMAX;
pub const KERN_SHMMAX: _bindgen_ty_11 = _bindgen_ty_11::KERN_SHMMAX;
pub const KERN_MSGMAX: _bindgen_ty_11 = _bindgen_ty_11::KERN_MSGMAX;
pub const KERN_MSGMNB: _bindgen_ty_11 = _bindgen_ty_11::KERN_MSGMNB;
pub const KERN_MSGPOOL: _bindgen_ty_11 = _bindgen_ty_11::KERN_MSGPOOL;
pub const KERN_SYSRQ: _bindgen_ty_11 = _bindgen_ty_11::KERN_SYSRQ;
pub const KERN_MAX_THREADS: _bindgen_ty_11 = _bindgen_ty_11::KERN_MAX_THREADS;
pub const KERN_RANDOM: _bindgen_ty_11 = _bindgen_ty_11::KERN_RANDOM;
pub const KERN_SHMALL: _bindgen_ty_11 = _bindgen_ty_11::KERN_SHMALL;
pub const KERN_MSGMNI: _bindgen_ty_11 = _bindgen_ty_11::KERN_MSGMNI;
pub const KERN_SEM: _bindgen_ty_11 = _bindgen_ty_11::KERN_SEM;
pub const KERN_SPARC_STOP_A: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_SPARC_STOP_A;
pub const KERN_SHMMNI: _bindgen_ty_11 = _bindgen_ty_11::KERN_SHMMNI;
pub const KERN_OVERFLOWUID: _bindgen_ty_11 = _bindgen_ty_11::KERN_OVERFLOWUID;
pub const KERN_OVERFLOWGID: _bindgen_ty_11 = _bindgen_ty_11::KERN_OVERFLOWGID;
pub const KERN_SHMPATH: _bindgen_ty_11 = _bindgen_ty_11::KERN_SHMPATH;
pub const KERN_HOTPLUG: _bindgen_ty_11 = _bindgen_ty_11::KERN_HOTPLUG;
pub const KERN_IEEE_EMULATION_WARNINGS: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_IEEE_EMULATION_WARNINGS;
pub const KERN_S390_USER_DEBUG_LOGGING: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_S390_USER_DEBUG_LOGGING;
pub const KERN_CORE_USES_PID: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_CORE_USES_PID;
pub const KERN_TAINTED: _bindgen_ty_11 = _bindgen_ty_11::KERN_TAINTED;
pub const KERN_CADPID: _bindgen_ty_11 = _bindgen_ty_11::KERN_CADPID;
pub const KERN_PIDMAX: _bindgen_ty_11 = _bindgen_ty_11::KERN_PIDMAX;
pub const KERN_CORE_PATTERN: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_CORE_PATTERN;
pub const KERN_PANIC_ON_OOPS: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_PANIC_ON_OOPS;
pub const KERN_HPPA_PWRSW: _bindgen_ty_11 = _bindgen_ty_11::KERN_HPPA_PWRSW;
pub const KERN_HPPA_UNALIGNED: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_HPPA_UNALIGNED;
pub const KERN_PRINTK_RATELIMIT: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_PRINTK_RATELIMIT;
pub const KERN_PRINTK_RATELIMIT_BURST: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_PRINTK_RATELIMIT_BURST;
pub const KERN_PTY: _bindgen_ty_11 = _bindgen_ty_11::KERN_PTY;
pub const KERN_NGROUPS_MAX: _bindgen_ty_11 = _bindgen_ty_11::KERN_NGROUPS_MAX;
pub const KERN_SPARC_SCONS_PWROFF: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_SPARC_SCONS_PWROFF;
pub const KERN_HZ_TIMER: _bindgen_ty_11 = _bindgen_ty_11::KERN_HZ_TIMER;
pub const KERN_UNKNOWN_NMI_PANIC: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_UNKNOWN_NMI_PANIC;
pub const KERN_BOOTLOADER_TYPE: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_BOOTLOADER_TYPE;
pub const KERN_RANDOMIZE: _bindgen_ty_11 = _bindgen_ty_11::KERN_RANDOMIZE;
pub const KERN_SETUID_DUMPABLE: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_SETUID_DUMPABLE;
pub const KERN_SPIN_RETRY: _bindgen_ty_11 = _bindgen_ty_11::KERN_SPIN_RETRY;
pub const KERN_ACPI_VIDEO_FLAGS: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_ACPI_VIDEO_FLAGS;
pub const KERN_IA64_UNALIGNED: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_IA64_UNALIGNED;
pub const KERN_COMPAT_LOG: _bindgen_ty_11 = _bindgen_ty_11::KERN_COMPAT_LOG;
pub const KERN_MAX_LOCK_DEPTH: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_MAX_LOCK_DEPTH;
pub const KERN_NMI_WATCHDOG: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_NMI_WATCHDOG;
pub const KERN_PANIC_ON_NMI: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_PANIC_ON_NMI;
pub const KERN_PANIC_ON_WARN: _bindgen_ty_11 =
    _bindgen_ty_11::KERN_PANIC_ON_WARN;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_11 {
    KERN_OSTYPE = 1,
    KERN_OSRELEASE = 2,
    KERN_OSREV = 3,
    KERN_VERSION = 4,
    KERN_SECUREMASK = 5,
    KERN_PROF = 6,
    KERN_NODENAME = 7,
    KERN_DOMAINNAME = 8,
    KERN_PANIC = 15,
    KERN_REALROOTDEV = 16,
    KERN_SPARC_REBOOT = 21,
    KERN_CTLALTDEL = 22,
    KERN_PRINTK = 23,
    KERN_NAMETRANS = 24,
    KERN_PPC_HTABRECLAIM = 25,
    KERN_PPC_ZEROPAGED = 26,
    KERN_PPC_POWERSAVE_NAP = 27,
    KERN_MODPROBE = 28,
    KERN_SG_BIG_BUFF = 29,
    KERN_ACCT = 30,
    KERN_PPC_L2CR = 31,
    KERN_RTSIGNR = 32,
    KERN_RTSIGMAX = 33,
    KERN_SHMMAX = 34,
    KERN_MSGMAX = 35,
    KERN_MSGMNB = 36,
    KERN_MSGPOOL = 37,
    KERN_SYSRQ = 38,
    KERN_MAX_THREADS = 39,
    KERN_RANDOM = 40,
    KERN_SHMALL = 41,
    KERN_MSGMNI = 42,
    KERN_SEM = 43,
    KERN_SPARC_STOP_A = 44,
    KERN_SHMMNI = 45,
    KERN_OVERFLOWUID = 46,
    KERN_OVERFLOWGID = 47,
    KERN_SHMPATH = 48,
    KERN_HOTPLUG = 49,
    KERN_IEEE_EMULATION_WARNINGS = 50,
    KERN_S390_USER_DEBUG_LOGGING = 51,
    KERN_CORE_USES_PID = 52,
    KERN_TAINTED = 53,
    KERN_CADPID = 54,
    KERN_PIDMAX = 55,
    KERN_CORE_PATTERN = 56,
    KERN_PANIC_ON_OOPS = 57,
    KERN_HPPA_PWRSW = 58,
    KERN_HPPA_UNALIGNED = 59,
    KERN_PRINTK_RATELIMIT = 60,
    KERN_PRINTK_RATELIMIT_BURST = 61,
    KERN_PTY = 62,
    KERN_NGROUPS_MAX = 63,
    KERN_SPARC_SCONS_PWROFF = 64,
    KERN_HZ_TIMER = 65,
    KERN_UNKNOWN_NMI_PANIC = 66,
    KERN_BOOTLOADER_TYPE = 67,
    KERN_RANDOMIZE = 68,
    KERN_SETUID_DUMPABLE = 69,
    KERN_SPIN_RETRY = 70,
    KERN_ACPI_VIDEO_FLAGS = 71,
    KERN_IA64_UNALIGNED = 72,
    KERN_COMPAT_LOG = 73,
    KERN_MAX_LOCK_DEPTH = 74,
    KERN_NMI_WATCHDOG = 75,
    KERN_PANIC_ON_NMI = 76,
    KERN_PANIC_ON_WARN = 77,
}
pub const VM_UNUSED1: _bindgen_ty_12 = _bindgen_ty_12::VM_UNUSED1;
pub const VM_UNUSED2: _bindgen_ty_12 = _bindgen_ty_12::VM_UNUSED2;
pub const VM_UNUSED3: _bindgen_ty_12 = _bindgen_ty_12::VM_UNUSED3;
pub const VM_UNUSED4: _bindgen_ty_12 = _bindgen_ty_12::VM_UNUSED4;
pub const VM_OVERCOMMIT_MEMORY: _bindgen_ty_12 =
    _bindgen_ty_12::VM_OVERCOMMIT_MEMORY;
pub const VM_UNUSED5: _bindgen_ty_12 = _bindgen_ty_12::VM_UNUSED5;
pub const VM_UNUSED7: _bindgen_ty_12 = _bindgen_ty_12::VM_UNUSED7;
pub const VM_UNUSED8: _bindgen_ty_12 = _bindgen_ty_12::VM_UNUSED8;
pub const VM_UNUSED9: _bindgen_ty_12 = _bindgen_ty_12::VM_UNUSED9;
pub const VM_PAGE_CLUSTER: _bindgen_ty_12 = _bindgen_ty_12::VM_PAGE_CLUSTER;
pub const VM_DIRTY_BACKGROUND: _bindgen_ty_12 =
    _bindgen_ty_12::VM_DIRTY_BACKGROUND;
pub const VM_DIRTY_RATIO: _bindgen_ty_12 = _bindgen_ty_12::VM_DIRTY_RATIO;
pub const VM_DIRTY_WB_CS: _bindgen_ty_12 = _bindgen_ty_12::VM_DIRTY_WB_CS;
pub const VM_DIRTY_EXPIRE_CS: _bindgen_ty_12 =
    _bindgen_ty_12::VM_DIRTY_EXPIRE_CS;
pub const VM_NR_PDFLUSH_THREADS: _bindgen_ty_12 =
    _bindgen_ty_12::VM_NR_PDFLUSH_THREADS;
pub const VM_OVERCOMMIT_RATIO: _bindgen_ty_12 =
    _bindgen_ty_12::VM_OVERCOMMIT_RATIO;
pub const VM_PAGEBUF: _bindgen_ty_12 = _bindgen_ty_12::VM_PAGEBUF;
pub const VM_HUGETLB_PAGES: _bindgen_ty_12 = _bindgen_ty_12::VM_HUGETLB_PAGES;
pub const VM_SWAPPINESS: _bindgen_ty_12 = _bindgen_ty_12::VM_SWAPPINESS;
pub const VM_LOWMEM_RESERVE_RATIO: _bindgen_ty_12 =
    _bindgen_ty_12::VM_LOWMEM_RESERVE_RATIO;
pub const VM_MIN_FREE_KBYTES: _bindgen_ty_12 =
    _bindgen_ty_12::VM_MIN_FREE_KBYTES;
pub const VM_MAX_MAP_COUNT: _bindgen_ty_12 = _bindgen_ty_12::VM_MAX_MAP_COUNT;
pub const VM_LAPTOP_MODE: _bindgen_ty_12 = _bindgen_ty_12::VM_LAPTOP_MODE;
pub const VM_BLOCK_DUMP: _bindgen_ty_12 = _bindgen_ty_12::VM_BLOCK_DUMP;
pub const VM_HUGETLB_GROUP: _bindgen_ty_12 = _bindgen_ty_12::VM_HUGETLB_GROUP;
pub const VM_VFS_CACHE_PRESSURE: _bindgen_ty_12 =
    _bindgen_ty_12::VM_VFS_CACHE_PRESSURE;
pub const VM_LEGACY_VA_LAYOUT: _bindgen_ty_12 =
    _bindgen_ty_12::VM_LEGACY_VA_LAYOUT;
pub const VM_SWAP_TOKEN_TIMEOUT: _bindgen_ty_12 =
    _bindgen_ty_12::VM_SWAP_TOKEN_TIMEOUT;
pub const VM_DROP_PAGECACHE: _bindgen_ty_12 =
    _bindgen_ty_12::VM_DROP_PAGECACHE;
pub const VM_PERCPU_PAGELIST_FRACTION: _bindgen_ty_12 =
    _bindgen_ty_12::VM_PERCPU_PAGELIST_FRACTION;
pub const VM_ZONE_RECLAIM_MODE: _bindgen_ty_12 =
    _bindgen_ty_12::VM_ZONE_RECLAIM_MODE;
pub const VM_MIN_UNMAPPED: _bindgen_ty_12 = _bindgen_ty_12::VM_MIN_UNMAPPED;
pub const VM_PANIC_ON_OOM: _bindgen_ty_12 = _bindgen_ty_12::VM_PANIC_ON_OOM;
pub const VM_VDSO_ENABLED: _bindgen_ty_12 = _bindgen_ty_12::VM_VDSO_ENABLED;
pub const VM_MIN_SLAB: _bindgen_ty_12 = _bindgen_ty_12::VM_MIN_SLAB;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_12 {
    VM_UNUSED1 = 1,
    VM_UNUSED2 = 2,
    VM_UNUSED3 = 3,
    VM_UNUSED4 = 4,
    VM_OVERCOMMIT_MEMORY = 5,
    VM_UNUSED5 = 6,
    VM_UNUSED7 = 7,
    VM_UNUSED8 = 8,
    VM_UNUSED9 = 9,
    VM_PAGE_CLUSTER = 10,
    VM_DIRTY_BACKGROUND = 11,
    VM_DIRTY_RATIO = 12,
    VM_DIRTY_WB_CS = 13,
    VM_DIRTY_EXPIRE_CS = 14,
    VM_NR_PDFLUSH_THREADS = 15,
    VM_OVERCOMMIT_RATIO = 16,
    VM_PAGEBUF = 17,
    VM_HUGETLB_PAGES = 18,
    VM_SWAPPINESS = 19,
    VM_LOWMEM_RESERVE_RATIO = 20,
    VM_MIN_FREE_KBYTES = 21,
    VM_MAX_MAP_COUNT = 22,
    VM_LAPTOP_MODE = 23,
    VM_BLOCK_DUMP = 24,
    VM_HUGETLB_GROUP = 25,
    VM_VFS_CACHE_PRESSURE = 26,
    VM_LEGACY_VA_LAYOUT = 27,
    VM_SWAP_TOKEN_TIMEOUT = 28,
    VM_DROP_PAGECACHE = 29,
    VM_PERCPU_PAGELIST_FRACTION = 30,
    VM_ZONE_RECLAIM_MODE = 31,
    VM_MIN_UNMAPPED = 32,
    VM_PANIC_ON_OOM = 33,
    VM_VDSO_ENABLED = 34,
    VM_MIN_SLAB = 35,
}
pub const NET_CORE: _bindgen_ty_13 = _bindgen_ty_13::NET_CORE;
pub const NET_ETHER: _bindgen_ty_13 = _bindgen_ty_13::NET_ETHER;
pub const NET_802: _bindgen_ty_13 = _bindgen_ty_13::NET_802;
pub const NET_UNIX: _bindgen_ty_13 = _bindgen_ty_13::NET_UNIX;
pub const NET_IPV4: _bindgen_ty_13 = _bindgen_ty_13::NET_IPV4;
pub const NET_IPX: _bindgen_ty_13 = _bindgen_ty_13::NET_IPX;
pub const NET_ATALK: _bindgen_ty_13 = _bindgen_ty_13::NET_ATALK;
pub const NET_NETROM: _bindgen_ty_13 = _bindgen_ty_13::NET_NETROM;
pub const NET_AX25: _bindgen_ty_13 = _bindgen_ty_13::NET_AX25;
pub const NET_BRIDGE: _bindgen_ty_13 = _bindgen_ty_13::NET_BRIDGE;
pub const NET_ROSE: _bindgen_ty_13 = _bindgen_ty_13::NET_ROSE;
pub const NET_IPV6: _bindgen_ty_13 = _bindgen_ty_13::NET_IPV6;
pub const NET_X25: _bindgen_ty_13 = _bindgen_ty_13::NET_X25;
pub const NET_TR: _bindgen_ty_13 = _bindgen_ty_13::NET_TR;
pub const NET_DECNET: _bindgen_ty_13 = _bindgen_ty_13::NET_DECNET;
pub const NET_ECONET: _bindgen_ty_13 = _bindgen_ty_13::NET_ECONET;
pub const NET_SCTP: _bindgen_ty_13 = _bindgen_ty_13::NET_SCTP;
pub const NET_LLC: _bindgen_ty_13 = _bindgen_ty_13::NET_LLC;
pub const NET_NETFILTER: _bindgen_ty_13 = _bindgen_ty_13::NET_NETFILTER;
pub const NET_DCCP: _bindgen_ty_13 = _bindgen_ty_13::NET_DCCP;
pub const NET_IRDA: _bindgen_ty_13 = _bindgen_ty_13::NET_IRDA;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_13 {
    NET_CORE = 1,
    NET_ETHER = 2,
    NET_802 = 3,
    NET_UNIX = 4,
    NET_IPV4 = 5,
    NET_IPX = 6,
    NET_ATALK = 7,
    NET_NETROM = 8,
    NET_AX25 = 9,
    NET_BRIDGE = 10,
    NET_ROSE = 11,
    NET_IPV6 = 12,
    NET_X25 = 13,
    NET_TR = 14,
    NET_DECNET = 15,
    NET_ECONET = 16,
    NET_SCTP = 17,
    NET_LLC = 18,
    NET_NETFILTER = 19,
    NET_DCCP = 20,
    NET_IRDA = 412,
}
pub const RANDOM_POOLSIZE: _bindgen_ty_14 = _bindgen_ty_14::RANDOM_POOLSIZE;
pub const RANDOM_ENTROPY_COUNT: _bindgen_ty_14 =
    _bindgen_ty_14::RANDOM_ENTROPY_COUNT;
pub const RANDOM_READ_THRESH: _bindgen_ty_14 =
    _bindgen_ty_14::RANDOM_READ_THRESH;
pub const RANDOM_WRITE_THRESH: _bindgen_ty_14 =
    _bindgen_ty_14::RANDOM_WRITE_THRESH;
pub const RANDOM_BOOT_ID: _bindgen_ty_14 = _bindgen_ty_14::RANDOM_BOOT_ID;
pub const RANDOM_UUID: _bindgen_ty_14 = _bindgen_ty_14::RANDOM_UUID;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_14 {
    RANDOM_POOLSIZE = 1,
    RANDOM_ENTROPY_COUNT = 2,
    RANDOM_READ_THRESH = 3,
    RANDOM_WRITE_THRESH = 4,
    RANDOM_BOOT_ID = 5,
    RANDOM_UUID = 6,
}
pub const PTY_MAX: _bindgen_ty_15 = _bindgen_ty_15::PTY_MAX;
pub const PTY_NR: _bindgen_ty_15 = _bindgen_ty_15::PTY_NR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_15 { PTY_MAX = 1, PTY_NR = 2, }
pub const BUS_ISA_MEM_BASE: _bindgen_ty_16 = _bindgen_ty_16::BUS_ISA_MEM_BASE;
pub const BUS_ISA_PORT_BASE: _bindgen_ty_16 =
    _bindgen_ty_16::BUS_ISA_PORT_BASE;
pub const BUS_ISA_PORT_SHIFT: _bindgen_ty_16 =
    _bindgen_ty_16::BUS_ISA_PORT_SHIFT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_16 {
    BUS_ISA_MEM_BASE = 1,
    BUS_ISA_PORT_BASE = 2,
    BUS_ISA_PORT_SHIFT = 3,
}
pub const NET_CORE_WMEM_MAX: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_WMEM_MAX;
pub const NET_CORE_RMEM_MAX: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_RMEM_MAX;
pub const NET_CORE_WMEM_DEFAULT: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_WMEM_DEFAULT;
pub const NET_CORE_RMEM_DEFAULT: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_RMEM_DEFAULT;
pub const NET_CORE_MAX_BACKLOG: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_MAX_BACKLOG;
pub const NET_CORE_FASTROUTE: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_FASTROUTE;
pub const NET_CORE_MSG_COST: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_MSG_COST;
pub const NET_CORE_MSG_BURST: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_MSG_BURST;
pub const NET_CORE_OPTMEM_MAX: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_OPTMEM_MAX;
pub const NET_CORE_HOT_LIST_LENGTH: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_HOT_LIST_LENGTH;
pub const NET_CORE_DIVERT_VERSION: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_DIVERT_VERSION;
pub const NET_CORE_NO_CONG_THRESH: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_NO_CONG_THRESH;
pub const NET_CORE_NO_CONG: _bindgen_ty_17 = _bindgen_ty_17::NET_CORE_NO_CONG;
pub const NET_CORE_LO_CONG: _bindgen_ty_17 = _bindgen_ty_17::NET_CORE_LO_CONG;
pub const NET_CORE_MOD_CONG: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_MOD_CONG;
pub const NET_CORE_DEV_WEIGHT: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_DEV_WEIGHT;
pub const NET_CORE_SOMAXCONN: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_SOMAXCONN;
pub const NET_CORE_BUDGET: _bindgen_ty_17 = _bindgen_ty_17::NET_CORE_BUDGET;
pub const NET_CORE_AEVENT_ETIME: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_AEVENT_ETIME;
pub const NET_CORE_AEVENT_RSEQTH: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_AEVENT_RSEQTH;
pub const NET_CORE_WARNINGS: _bindgen_ty_17 =
    _bindgen_ty_17::NET_CORE_WARNINGS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_17 {
    NET_CORE_WMEM_MAX = 1,
    NET_CORE_RMEM_MAX = 2,
    NET_CORE_WMEM_DEFAULT = 3,
    NET_CORE_RMEM_DEFAULT = 4,
    NET_CORE_MAX_BACKLOG = 6,
    NET_CORE_FASTROUTE = 7,
    NET_CORE_MSG_COST = 8,
    NET_CORE_MSG_BURST = 9,
    NET_CORE_OPTMEM_MAX = 10,
    NET_CORE_HOT_LIST_LENGTH = 11,
    NET_CORE_DIVERT_VERSION = 12,
    NET_CORE_NO_CONG_THRESH = 13,
    NET_CORE_NO_CONG = 14,
    NET_CORE_LO_CONG = 15,
    NET_CORE_MOD_CONG = 16,
    NET_CORE_DEV_WEIGHT = 17,
    NET_CORE_SOMAXCONN = 18,
    NET_CORE_BUDGET = 19,
    NET_CORE_AEVENT_ETIME = 20,
    NET_CORE_AEVENT_RSEQTH = 21,
    NET_CORE_WARNINGS = 22,
}
pub const NET_UNIX_DESTROY_DELAY: _bindgen_ty_18 =
    _bindgen_ty_18::NET_UNIX_DESTROY_DELAY;
pub const NET_UNIX_DELETE_DELAY: _bindgen_ty_18 =
    _bindgen_ty_18::NET_UNIX_DELETE_DELAY;
pub const NET_UNIX_MAX_DGRAM_QLEN: _bindgen_ty_18 =
    _bindgen_ty_18::NET_UNIX_MAX_DGRAM_QLEN;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_18 {
    NET_UNIX_DESTROY_DELAY = 1,
    NET_UNIX_DELETE_DELAY = 2,
    NET_UNIX_MAX_DGRAM_QLEN = 3,
}
pub const NET_NF_CONNTRACK_MAX: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_MAX;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE;
pub const NET_NF_CONNTRACK_UDP_TIMEOUT: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_UDP_TIMEOUT;
pub const NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM;
pub const NET_NF_CONNTRACK_ICMP_TIMEOUT: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_ICMP_TIMEOUT;
pub const NET_NF_CONNTRACK_GENERIC_TIMEOUT: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_GENERIC_TIMEOUT;
pub const NET_NF_CONNTRACK_BUCKETS: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_BUCKETS;
pub const NET_NF_CONNTRACK_LOG_INVALID: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_LOG_INVALID;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS;
pub const NET_NF_CONNTRACK_TCP_LOOSE: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_TCP_LOOSE;
pub const NET_NF_CONNTRACK_TCP_BE_LIBERAL: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_TCP_BE_LIBERAL;
pub const NET_NF_CONNTRACK_TCP_MAX_RETRANS: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_TCP_MAX_RETRANS;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT;
pub const NET_NF_CONNTRACK_COUNT: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_COUNT;
pub const NET_NF_CONNTRACK_ICMPV6_TIMEOUT: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_ICMPV6_TIMEOUT;
pub const NET_NF_CONNTRACK_FRAG6_TIMEOUT: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_FRAG6_TIMEOUT;
pub const NET_NF_CONNTRACK_FRAG6_LOW_THRESH: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_FRAG6_LOW_THRESH;
pub const NET_NF_CONNTRACK_FRAG6_HIGH_THRESH: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_FRAG6_HIGH_THRESH;
pub const NET_NF_CONNTRACK_CHECKSUM: _bindgen_ty_19 =
    _bindgen_ty_19::NET_NF_CONNTRACK_CHECKSUM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_19 {
    NET_NF_CONNTRACK_MAX = 1,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
    NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
    NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
    NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
    NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
    NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
    NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
    NET_NF_CONNTRACK_UDP_TIMEOUT = 10,
    NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
    NET_NF_CONNTRACK_ICMP_TIMEOUT = 12,
    NET_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
    NET_NF_CONNTRACK_BUCKETS = 14,
    NET_NF_CONNTRACK_LOG_INVALID = 15,
    NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
    NET_NF_CONNTRACK_TCP_LOOSE = 17,
    NET_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
    NET_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
    NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
    NET_NF_CONNTRACK_COUNT = 27,
    NET_NF_CONNTRACK_ICMPV6_TIMEOUT = 28,
    NET_NF_CONNTRACK_FRAG6_TIMEOUT = 29,
    NET_NF_CONNTRACK_FRAG6_LOW_THRESH = 30,
    NET_NF_CONNTRACK_FRAG6_HIGH_THRESH = 31,
    NET_NF_CONNTRACK_CHECKSUM = 32,
}
pub const NET_IPV4_FORWARD: _bindgen_ty_20 = _bindgen_ty_20::NET_IPV4_FORWARD;
pub const NET_IPV4_DYNADDR: _bindgen_ty_20 = _bindgen_ty_20::NET_IPV4_DYNADDR;
pub const NET_IPV4_CONF: _bindgen_ty_20 = _bindgen_ty_20::NET_IPV4_CONF;
pub const NET_IPV4_NEIGH: _bindgen_ty_20 = _bindgen_ty_20::NET_IPV4_NEIGH;
pub const NET_IPV4_ROUTE: _bindgen_ty_20 = _bindgen_ty_20::NET_IPV4_ROUTE;
pub const NET_IPV4_FIB_HASH: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_FIB_HASH;
pub const NET_IPV4_NETFILTER: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_NETFILTER;
pub const NET_IPV4_TCP_TIMESTAMPS: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_TCP_TIMESTAMPS;
pub const NET_IPV4_TCP_WINDOW_SCALING: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_TCP_WINDOW_SCALING;
pub const NET_IPV4_TCP_SACK: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_TCP_SACK;
pub const NET_IPV4_TCP_RETRANS_COLLAPSE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_TCP_RETRANS_COLLAPSE;
pub const NET_IPV4_DEFAULT_TTL: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_DEFAULT_TTL;
pub const NET_IPV4_AUTOCONFIG: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_AUTOCONFIG;
pub const NET_IPV4_NO_PMTU_DISC: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_NO_PMTU_DISC;
pub const NET_IPV4_TCP_SYN_RETRIES: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_TCP_SYN_RETRIES;
pub const NET_IPV4_IPFRAG_HIGH_THRESH: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_IPFRAG_HIGH_THRESH;
pub const NET_IPV4_IPFRAG_LOW_THRESH: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_IPFRAG_LOW_THRESH;
pub const NET_IPV4_IPFRAG_TIME: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_IPFRAG_TIME;
pub const NET_IPV4_TCP_MAX_KA_PROBES: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_TCP_MAX_KA_PROBES;
pub const NET_IPV4_TCP_KEEPALIVE_TIME: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_TCP_KEEPALIVE_TIME;
pub const NET_IPV4_TCP_KEEPALIVE_PROBES: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_TCP_KEEPALIVE_PROBES;
pub const NET_IPV4_TCP_RETRIES1: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_TCP_RETRIES1;
pub const NET_IPV4_TCP_RETRIES2: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_TCP_RETRIES2;
pub const NET_IPV4_TCP_FIN_TIMEOUT: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_TCP_FIN_TIMEOUT;
pub const NET_IPV4_IP_MASQ_DEBUG: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_IP_MASQ_DEBUG;
pub const NET_TCP_SYNCOOKIES: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_SYNCOOKIES;
pub const NET_TCP_STDURG: _bindgen_ty_20 = _bindgen_ty_20::NET_TCP_STDURG;
pub const NET_TCP_RFC1337: _bindgen_ty_20 = _bindgen_ty_20::NET_TCP_RFC1337;
pub const NET_TCP_SYN_TAILDROP: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_SYN_TAILDROP;
pub const NET_TCP_MAX_SYN_BACKLOG: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_MAX_SYN_BACKLOG;
pub const NET_IPV4_LOCAL_PORT_RANGE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_LOCAL_PORT_RANGE;
pub const NET_IPV4_ICMP_ECHO_IGNORE_ALL: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_ICMP_ECHO_IGNORE_ALL;
pub const NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS;
pub const NET_IPV4_ICMP_SOURCEQUENCH_RATE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_ICMP_SOURCEQUENCH_RATE;
pub const NET_IPV4_ICMP_DESTUNREACH_RATE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_ICMP_DESTUNREACH_RATE;
pub const NET_IPV4_ICMP_TIMEEXCEED_RATE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_ICMP_TIMEEXCEED_RATE;
pub const NET_IPV4_ICMP_PARAMPROB_RATE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_ICMP_PARAMPROB_RATE;
pub const NET_IPV4_ICMP_ECHOREPLY_RATE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_ICMP_ECHOREPLY_RATE;
pub const NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES;
pub const NET_IPV4_IGMP_MAX_MEMBERSHIPS: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_IGMP_MAX_MEMBERSHIPS;
pub const NET_TCP_TW_RECYCLE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_TW_RECYCLE;
pub const NET_IPV4_ALWAYS_DEFRAG: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_ALWAYS_DEFRAG;
pub const NET_IPV4_TCP_KEEPALIVE_INTVL: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_TCP_KEEPALIVE_INTVL;
pub const NET_IPV4_INET_PEER_THRESHOLD: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_INET_PEER_THRESHOLD;
pub const NET_IPV4_INET_PEER_MINTTL: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_INET_PEER_MINTTL;
pub const NET_IPV4_INET_PEER_MAXTTL: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_INET_PEER_MAXTTL;
pub const NET_IPV4_INET_PEER_GC_MINTIME: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_INET_PEER_GC_MINTIME;
pub const NET_IPV4_INET_PEER_GC_MAXTIME: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_INET_PEER_GC_MAXTIME;
pub const NET_TCP_ORPHAN_RETRIES: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_ORPHAN_RETRIES;
pub const NET_TCP_ABORT_ON_OVERFLOW: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_ABORT_ON_OVERFLOW;
pub const NET_TCP_SYNACK_RETRIES: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_SYNACK_RETRIES;
pub const NET_TCP_MAX_ORPHANS: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_MAX_ORPHANS;
pub const NET_TCP_MAX_TW_BUCKETS: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_MAX_TW_BUCKETS;
pub const NET_TCP_FACK: _bindgen_ty_20 = _bindgen_ty_20::NET_TCP_FACK;
pub const NET_TCP_REORDERING: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_REORDERING;
pub const NET_TCP_ECN: _bindgen_ty_20 = _bindgen_ty_20::NET_TCP_ECN;
pub const NET_TCP_DSACK: _bindgen_ty_20 = _bindgen_ty_20::NET_TCP_DSACK;
pub const NET_TCP_MEM: _bindgen_ty_20 = _bindgen_ty_20::NET_TCP_MEM;
pub const NET_TCP_WMEM: _bindgen_ty_20 = _bindgen_ty_20::NET_TCP_WMEM;
pub const NET_TCP_RMEM: _bindgen_ty_20 = _bindgen_ty_20::NET_TCP_RMEM;
pub const NET_TCP_APP_WIN: _bindgen_ty_20 = _bindgen_ty_20::NET_TCP_APP_WIN;
pub const NET_TCP_ADV_WIN_SCALE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_ADV_WIN_SCALE;
pub const NET_IPV4_NONLOCAL_BIND: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_NONLOCAL_BIND;
pub const NET_IPV4_ICMP_RATELIMIT: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_ICMP_RATELIMIT;
pub const NET_IPV4_ICMP_RATEMASK: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_ICMP_RATEMASK;
pub const NET_TCP_TW_REUSE: _bindgen_ty_20 = _bindgen_ty_20::NET_TCP_TW_REUSE;
pub const NET_TCP_FRTO: _bindgen_ty_20 = _bindgen_ty_20::NET_TCP_FRTO;
pub const NET_TCP_LOW_LATENCY: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_LOW_LATENCY;
pub const NET_IPV4_IPFRAG_SECRET_INTERVAL: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_IPFRAG_SECRET_INTERVAL;
pub const NET_IPV4_IGMP_MAX_MSF: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_IGMP_MAX_MSF;
pub const NET_TCP_NO_METRICS_SAVE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_NO_METRICS_SAVE;
pub const NET_TCP_DEFAULT_WIN_SCALE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_DEFAULT_WIN_SCALE;
pub const NET_TCP_MODERATE_RCVBUF: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_MODERATE_RCVBUF;
pub const NET_TCP_TSO_WIN_DIVISOR: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_TSO_WIN_DIVISOR;
pub const NET_TCP_BIC_BETA: _bindgen_ty_20 = _bindgen_ty_20::NET_TCP_BIC_BETA;
pub const NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR;
pub const NET_TCP_CONG_CONTROL: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_CONG_CONTROL;
pub const NET_TCP_ABC: _bindgen_ty_20 = _bindgen_ty_20::NET_TCP_ABC;
pub const NET_IPV4_IPFRAG_MAX_DIST: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_IPFRAG_MAX_DIST;
pub const NET_TCP_MTU_PROBING: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_MTU_PROBING;
pub const NET_TCP_BASE_MSS: _bindgen_ty_20 = _bindgen_ty_20::NET_TCP_BASE_MSS;
pub const NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS: _bindgen_ty_20 =
    _bindgen_ty_20::NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS;
pub const NET_TCP_DMA_COPYBREAK: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_DMA_COPYBREAK;
pub const NET_TCP_SLOW_START_AFTER_IDLE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_SLOW_START_AFTER_IDLE;
pub const NET_CIPSOV4_CACHE_ENABLE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_CIPSOV4_CACHE_ENABLE;
pub const NET_CIPSOV4_CACHE_BUCKET_SIZE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_CIPSOV4_CACHE_BUCKET_SIZE;
pub const NET_CIPSOV4_RBM_OPTFMT: _bindgen_ty_20 =
    _bindgen_ty_20::NET_CIPSOV4_RBM_OPTFMT;
pub const NET_CIPSOV4_RBM_STRICTVALID: _bindgen_ty_20 =
    _bindgen_ty_20::NET_CIPSOV4_RBM_STRICTVALID;
pub const NET_TCP_AVAIL_CONG_CONTROL: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_AVAIL_CONG_CONTROL;
pub const NET_TCP_ALLOWED_CONG_CONTROL: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_ALLOWED_CONG_CONTROL;
pub const NET_TCP_MAX_SSTHRESH: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_MAX_SSTHRESH;
pub const NET_TCP_FRTO_RESPONSE: _bindgen_ty_20 =
    _bindgen_ty_20::NET_TCP_FRTO_RESPONSE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_20 {
    NET_IPV4_FORWARD = 8,
    NET_IPV4_DYNADDR = 9,
    NET_IPV4_CONF = 16,
    NET_IPV4_NEIGH = 17,
    NET_IPV4_ROUTE = 18,
    NET_IPV4_FIB_HASH = 19,
    NET_IPV4_NETFILTER = 20,
    NET_IPV4_TCP_TIMESTAMPS = 33,
    NET_IPV4_TCP_WINDOW_SCALING = 34,
    NET_IPV4_TCP_SACK = 35,
    NET_IPV4_TCP_RETRANS_COLLAPSE = 36,
    NET_IPV4_DEFAULT_TTL = 37,
    NET_IPV4_AUTOCONFIG = 38,
    NET_IPV4_NO_PMTU_DISC = 39,
    NET_IPV4_TCP_SYN_RETRIES = 40,
    NET_IPV4_IPFRAG_HIGH_THRESH = 41,
    NET_IPV4_IPFRAG_LOW_THRESH = 42,
    NET_IPV4_IPFRAG_TIME = 43,
    NET_IPV4_TCP_MAX_KA_PROBES = 44,
    NET_IPV4_TCP_KEEPALIVE_TIME = 45,
    NET_IPV4_TCP_KEEPALIVE_PROBES = 46,
    NET_IPV4_TCP_RETRIES1 = 47,
    NET_IPV4_TCP_RETRIES2 = 48,
    NET_IPV4_TCP_FIN_TIMEOUT = 49,
    NET_IPV4_IP_MASQ_DEBUG = 50,
    NET_TCP_SYNCOOKIES = 51,
    NET_TCP_STDURG = 52,
    NET_TCP_RFC1337 = 53,
    NET_TCP_SYN_TAILDROP = 54,
    NET_TCP_MAX_SYN_BACKLOG = 55,
    NET_IPV4_LOCAL_PORT_RANGE = 56,
    NET_IPV4_ICMP_ECHO_IGNORE_ALL = 57,
    NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS = 58,
    NET_IPV4_ICMP_SOURCEQUENCH_RATE = 59,
    NET_IPV4_ICMP_DESTUNREACH_RATE = 60,
    NET_IPV4_ICMP_TIMEEXCEED_RATE = 61,
    NET_IPV4_ICMP_PARAMPROB_RATE = 62,
    NET_IPV4_ICMP_ECHOREPLY_RATE = 63,
    NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES = 64,
    NET_IPV4_IGMP_MAX_MEMBERSHIPS = 65,
    NET_TCP_TW_RECYCLE = 66,
    NET_IPV4_ALWAYS_DEFRAG = 67,
    NET_IPV4_TCP_KEEPALIVE_INTVL = 68,
    NET_IPV4_INET_PEER_THRESHOLD = 69,
    NET_IPV4_INET_PEER_MINTTL = 70,
    NET_IPV4_INET_PEER_MAXTTL = 71,
    NET_IPV4_INET_PEER_GC_MINTIME = 72,
    NET_IPV4_INET_PEER_GC_MAXTIME = 73,
    NET_TCP_ORPHAN_RETRIES = 74,
    NET_TCP_ABORT_ON_OVERFLOW = 75,
    NET_TCP_SYNACK_RETRIES = 76,
    NET_TCP_MAX_ORPHANS = 77,
    NET_TCP_MAX_TW_BUCKETS = 78,
    NET_TCP_FACK = 79,
    NET_TCP_REORDERING = 80,
    NET_TCP_ECN = 81,
    NET_TCP_DSACK = 82,
    NET_TCP_MEM = 83,
    NET_TCP_WMEM = 84,
    NET_TCP_RMEM = 85,
    NET_TCP_APP_WIN = 86,
    NET_TCP_ADV_WIN_SCALE = 87,
    NET_IPV4_NONLOCAL_BIND = 88,
    NET_IPV4_ICMP_RATELIMIT = 89,
    NET_IPV4_ICMP_RATEMASK = 90,
    NET_TCP_TW_REUSE = 91,
    NET_TCP_FRTO = 92,
    NET_TCP_LOW_LATENCY = 93,
    NET_IPV4_IPFRAG_SECRET_INTERVAL = 94,
    NET_IPV4_IGMP_MAX_MSF = 96,
    NET_TCP_NO_METRICS_SAVE = 97,
    NET_TCP_DEFAULT_WIN_SCALE = 105,
    NET_TCP_MODERATE_RCVBUF = 106,
    NET_TCP_TSO_WIN_DIVISOR = 107,
    NET_TCP_BIC_BETA = 108,
    NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR = 109,
    NET_TCP_CONG_CONTROL = 110,
    NET_TCP_ABC = 111,
    NET_IPV4_IPFRAG_MAX_DIST = 112,
    NET_TCP_MTU_PROBING = 113,
    NET_TCP_BASE_MSS = 114,
    NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS = 115,
    NET_TCP_DMA_COPYBREAK = 116,
    NET_TCP_SLOW_START_AFTER_IDLE = 117,
    NET_CIPSOV4_CACHE_ENABLE = 118,
    NET_CIPSOV4_CACHE_BUCKET_SIZE = 119,
    NET_CIPSOV4_RBM_OPTFMT = 120,
    NET_CIPSOV4_RBM_STRICTVALID = 121,
    NET_TCP_AVAIL_CONG_CONTROL = 122,
    NET_TCP_ALLOWED_CONG_CONTROL = 123,
    NET_TCP_MAX_SSTHRESH = 124,
    NET_TCP_FRTO_RESPONSE = 125,
}
pub const NET_IPV4_ROUTE_FLUSH: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_FLUSH;
pub const NET_IPV4_ROUTE_MIN_DELAY: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_MIN_DELAY;
pub const NET_IPV4_ROUTE_MAX_DELAY: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_MAX_DELAY;
pub const NET_IPV4_ROUTE_GC_THRESH: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_GC_THRESH;
pub const NET_IPV4_ROUTE_MAX_SIZE: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_MAX_SIZE;
pub const NET_IPV4_ROUTE_GC_MIN_INTERVAL: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_GC_MIN_INTERVAL;
pub const NET_IPV4_ROUTE_GC_TIMEOUT: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_GC_TIMEOUT;
pub const NET_IPV4_ROUTE_GC_INTERVAL: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_GC_INTERVAL;
pub const NET_IPV4_ROUTE_REDIRECT_LOAD: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_REDIRECT_LOAD;
pub const NET_IPV4_ROUTE_REDIRECT_NUMBER: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_REDIRECT_NUMBER;
pub const NET_IPV4_ROUTE_REDIRECT_SILENCE: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_REDIRECT_SILENCE;
pub const NET_IPV4_ROUTE_ERROR_COST: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_ERROR_COST;
pub const NET_IPV4_ROUTE_ERROR_BURST: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_ERROR_BURST;
pub const NET_IPV4_ROUTE_GC_ELASTICITY: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_GC_ELASTICITY;
pub const NET_IPV4_ROUTE_MTU_EXPIRES: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_MTU_EXPIRES;
pub const NET_IPV4_ROUTE_MIN_PMTU: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_MIN_PMTU;
pub const NET_IPV4_ROUTE_MIN_ADVMSS: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_MIN_ADVMSS;
pub const NET_IPV4_ROUTE_SECRET_INTERVAL: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_SECRET_INTERVAL;
pub const NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS: _bindgen_ty_21 =
    _bindgen_ty_21::NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_21 {
    NET_IPV4_ROUTE_FLUSH = 1,
    NET_IPV4_ROUTE_MIN_DELAY = 2,
    NET_IPV4_ROUTE_MAX_DELAY = 3,
    NET_IPV4_ROUTE_GC_THRESH = 4,
    NET_IPV4_ROUTE_MAX_SIZE = 5,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL = 6,
    NET_IPV4_ROUTE_GC_TIMEOUT = 7,
    NET_IPV4_ROUTE_GC_INTERVAL = 8,
    NET_IPV4_ROUTE_REDIRECT_LOAD = 9,
    NET_IPV4_ROUTE_REDIRECT_NUMBER = 10,
    NET_IPV4_ROUTE_REDIRECT_SILENCE = 11,
    NET_IPV4_ROUTE_ERROR_COST = 12,
    NET_IPV4_ROUTE_ERROR_BURST = 13,
    NET_IPV4_ROUTE_GC_ELASTICITY = 14,
    NET_IPV4_ROUTE_MTU_EXPIRES = 15,
    NET_IPV4_ROUTE_MIN_PMTU = 16,
    NET_IPV4_ROUTE_MIN_ADVMSS = 17,
    NET_IPV4_ROUTE_SECRET_INTERVAL = 18,
    NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS = 19,
}
pub const NET_PROTO_CONF_ALL: _bindgen_ty_22 =
    _bindgen_ty_22::NET_PROTO_CONF_ALL;
pub const NET_PROTO_CONF_DEFAULT: _bindgen_ty_22 =
    _bindgen_ty_22::NET_PROTO_CONF_DEFAULT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_22 {
    NET_PROTO_CONF_ALL = -2,
    NET_PROTO_CONF_DEFAULT = -3,
}
pub const NET_IPV4_CONF_FORWARDING: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_FORWARDING;
pub const NET_IPV4_CONF_MC_FORWARDING: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_MC_FORWARDING;
pub const NET_IPV4_CONF_PROXY_ARP: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_PROXY_ARP;
pub const NET_IPV4_CONF_ACCEPT_REDIRECTS: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_ACCEPT_REDIRECTS;
pub const NET_IPV4_CONF_SECURE_REDIRECTS: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_SECURE_REDIRECTS;
pub const NET_IPV4_CONF_SEND_REDIRECTS: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_SEND_REDIRECTS;
pub const NET_IPV4_CONF_SHARED_MEDIA: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_SHARED_MEDIA;
pub const NET_IPV4_CONF_RP_FILTER: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_RP_FILTER;
pub const NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE;
pub const NET_IPV4_CONF_BOOTP_RELAY: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_BOOTP_RELAY;
pub const NET_IPV4_CONF_LOG_MARTIANS: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_LOG_MARTIANS;
pub const NET_IPV4_CONF_TAG: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_TAG;
pub const NET_IPV4_CONF_ARPFILTER: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_ARPFILTER;
pub const NET_IPV4_CONF_MEDIUM_ID: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_MEDIUM_ID;
pub const NET_IPV4_CONF_NOXFRM: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_NOXFRM;
pub const NET_IPV4_CONF_NOPOLICY: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_NOPOLICY;
pub const NET_IPV4_CONF_FORCE_IGMP_VERSION: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_FORCE_IGMP_VERSION;
pub const NET_IPV4_CONF_ARP_ANNOUNCE: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_ARP_ANNOUNCE;
pub const NET_IPV4_CONF_ARP_IGNORE: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_ARP_IGNORE;
pub const NET_IPV4_CONF_PROMOTE_SECONDARIES: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_PROMOTE_SECONDARIES;
pub const NET_IPV4_CONF_ARP_ACCEPT: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_ARP_ACCEPT;
pub const NET_IPV4_CONF_ARP_NOTIFY: _bindgen_ty_23 =
    _bindgen_ty_23::NET_IPV4_CONF_ARP_NOTIFY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_23 {
    NET_IPV4_CONF_FORWARDING = 1,
    NET_IPV4_CONF_MC_FORWARDING = 2,
    NET_IPV4_CONF_PROXY_ARP = 3,
    NET_IPV4_CONF_ACCEPT_REDIRECTS = 4,
    NET_IPV4_CONF_SECURE_REDIRECTS = 5,
    NET_IPV4_CONF_SEND_REDIRECTS = 6,
    NET_IPV4_CONF_SHARED_MEDIA = 7,
    NET_IPV4_CONF_RP_FILTER = 8,
    NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE = 9,
    NET_IPV4_CONF_BOOTP_RELAY = 10,
    NET_IPV4_CONF_LOG_MARTIANS = 11,
    NET_IPV4_CONF_TAG = 12,
    NET_IPV4_CONF_ARPFILTER = 13,
    NET_IPV4_CONF_MEDIUM_ID = 14,
    NET_IPV4_CONF_NOXFRM = 15,
    NET_IPV4_CONF_NOPOLICY = 16,
    NET_IPV4_CONF_FORCE_IGMP_VERSION = 17,
    NET_IPV4_CONF_ARP_ANNOUNCE = 18,
    NET_IPV4_CONF_ARP_IGNORE = 19,
    NET_IPV4_CONF_PROMOTE_SECONDARIES = 20,
    NET_IPV4_CONF_ARP_ACCEPT = 21,
    NET_IPV4_CONF_ARP_NOTIFY = 22,
}
pub const NET_IPV4_NF_CONNTRACK_MAX: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_MAX;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE;
pub const NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT;
pub const NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM;
pub const NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT;
pub const NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT;
pub const NET_IPV4_NF_CONNTRACK_BUCKETS: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_BUCKETS;
pub const NET_IPV4_NF_CONNTRACK_LOG_INVALID: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_LOG_INVALID;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS;
pub const NET_IPV4_NF_CONNTRACK_TCP_LOOSE: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_TCP_LOOSE;
pub const NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL;
pub const NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT: _bindgen_ty_24
          =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT;
pub const NET_IPV4_NF_CONNTRACK_COUNT: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_COUNT;
pub const NET_IPV4_NF_CONNTRACK_CHECKSUM: _bindgen_ty_24 =
    _bindgen_ty_24::NET_IPV4_NF_CONNTRACK_CHECKSUM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_24 {
    NET_IPV4_NF_CONNTRACK_MAX = 1,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT = 10,
    NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
    NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT = 12,
    NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
    NET_IPV4_NF_CONNTRACK_BUCKETS = 14,
    NET_IPV4_NF_CONNTRACK_LOG_INVALID = 15,
    NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
    NET_IPV4_NF_CONNTRACK_TCP_LOOSE = 17,
    NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
    NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
    NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
    NET_IPV4_NF_CONNTRACK_COUNT = 27,
    NET_IPV4_NF_CONNTRACK_CHECKSUM = 28,
}
pub const NET_IPV6_CONF: _bindgen_ty_25 = _bindgen_ty_25::NET_IPV6_CONF;
pub const NET_IPV6_NEIGH: _bindgen_ty_25 = _bindgen_ty_25::NET_IPV6_NEIGH;
pub const NET_IPV6_ROUTE: _bindgen_ty_25 = _bindgen_ty_25::NET_IPV6_ROUTE;
pub const NET_IPV6_ICMP: _bindgen_ty_25 = _bindgen_ty_25::NET_IPV6_ICMP;
pub const NET_IPV6_BINDV6ONLY: _bindgen_ty_25 =
    _bindgen_ty_25::NET_IPV6_BINDV6ONLY;
pub const NET_IPV6_IP6FRAG_HIGH_THRESH: _bindgen_ty_25 =
    _bindgen_ty_25::NET_IPV6_IP6FRAG_HIGH_THRESH;
pub const NET_IPV6_IP6FRAG_LOW_THRESH: _bindgen_ty_25 =
    _bindgen_ty_25::NET_IPV6_IP6FRAG_LOW_THRESH;
pub const NET_IPV6_IP6FRAG_TIME: _bindgen_ty_25 =
    _bindgen_ty_25::NET_IPV6_IP6FRAG_TIME;
pub const NET_IPV6_IP6FRAG_SECRET_INTERVAL: _bindgen_ty_25 =
    _bindgen_ty_25::NET_IPV6_IP6FRAG_SECRET_INTERVAL;
pub const NET_IPV6_MLD_MAX_MSF: _bindgen_ty_25 =
    _bindgen_ty_25::NET_IPV6_MLD_MAX_MSF;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_25 {
    NET_IPV6_CONF = 16,
    NET_IPV6_NEIGH = 17,
    NET_IPV6_ROUTE = 18,
    NET_IPV6_ICMP = 19,
    NET_IPV6_BINDV6ONLY = 20,
    NET_IPV6_IP6FRAG_HIGH_THRESH = 21,
    NET_IPV6_IP6FRAG_LOW_THRESH = 22,
    NET_IPV6_IP6FRAG_TIME = 23,
    NET_IPV6_IP6FRAG_SECRET_INTERVAL = 24,
    NET_IPV6_MLD_MAX_MSF = 25,
}
pub const NET_IPV6_ROUTE_FLUSH: _bindgen_ty_26 =
    _bindgen_ty_26::NET_IPV6_ROUTE_FLUSH;
pub const NET_IPV6_ROUTE_GC_THRESH: _bindgen_ty_26 =
    _bindgen_ty_26::NET_IPV6_ROUTE_GC_THRESH;
pub const NET_IPV6_ROUTE_MAX_SIZE: _bindgen_ty_26 =
    _bindgen_ty_26::NET_IPV6_ROUTE_MAX_SIZE;
pub const NET_IPV6_ROUTE_GC_MIN_INTERVAL: _bindgen_ty_26 =
    _bindgen_ty_26::NET_IPV6_ROUTE_GC_MIN_INTERVAL;
pub const NET_IPV6_ROUTE_GC_TIMEOUT: _bindgen_ty_26 =
    _bindgen_ty_26::NET_IPV6_ROUTE_GC_TIMEOUT;
pub const NET_IPV6_ROUTE_GC_INTERVAL: _bindgen_ty_26 =
    _bindgen_ty_26::NET_IPV6_ROUTE_GC_INTERVAL;
pub const NET_IPV6_ROUTE_GC_ELASTICITY: _bindgen_ty_26 =
    _bindgen_ty_26::NET_IPV6_ROUTE_GC_ELASTICITY;
pub const NET_IPV6_ROUTE_MTU_EXPIRES: _bindgen_ty_26 =
    _bindgen_ty_26::NET_IPV6_ROUTE_MTU_EXPIRES;
pub const NET_IPV6_ROUTE_MIN_ADVMSS: _bindgen_ty_26 =
    _bindgen_ty_26::NET_IPV6_ROUTE_MIN_ADVMSS;
pub const NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS: _bindgen_ty_26 =
    _bindgen_ty_26::NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_26 {
    NET_IPV6_ROUTE_FLUSH = 1,
    NET_IPV6_ROUTE_GC_THRESH = 2,
    NET_IPV6_ROUTE_MAX_SIZE = 3,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL = 4,
    NET_IPV6_ROUTE_GC_TIMEOUT = 5,
    NET_IPV6_ROUTE_GC_INTERVAL = 6,
    NET_IPV6_ROUTE_GC_ELASTICITY = 7,
    NET_IPV6_ROUTE_MTU_EXPIRES = 8,
    NET_IPV6_ROUTE_MIN_ADVMSS = 9,
    NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS = 10,
}
pub const NET_IPV6_FORWARDING: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_FORWARDING;
pub const NET_IPV6_HOP_LIMIT: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_HOP_LIMIT;
pub const NET_IPV6_MTU: _bindgen_ty_27 = _bindgen_ty_27::NET_IPV6_MTU;
pub const NET_IPV6_ACCEPT_RA: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_ACCEPT_RA;
pub const NET_IPV6_ACCEPT_REDIRECTS: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_ACCEPT_REDIRECTS;
pub const NET_IPV6_AUTOCONF: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_AUTOCONF;
pub const NET_IPV6_DAD_TRANSMITS: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_DAD_TRANSMITS;
pub const NET_IPV6_RTR_SOLICITS: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_RTR_SOLICITS;
pub const NET_IPV6_RTR_SOLICIT_INTERVAL: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_RTR_SOLICIT_INTERVAL;
pub const NET_IPV6_RTR_SOLICIT_DELAY: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_RTR_SOLICIT_DELAY;
pub const NET_IPV6_USE_TEMPADDR: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_USE_TEMPADDR;
pub const NET_IPV6_TEMP_VALID_LFT: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_TEMP_VALID_LFT;
pub const NET_IPV6_TEMP_PREFERED_LFT: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_TEMP_PREFERED_LFT;
pub const NET_IPV6_REGEN_MAX_RETRY: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_REGEN_MAX_RETRY;
pub const NET_IPV6_MAX_DESYNC_FACTOR: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_MAX_DESYNC_FACTOR;
pub const NET_IPV6_MAX_ADDRESSES: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_MAX_ADDRESSES;
pub const NET_IPV6_FORCE_MLD_VERSION: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_FORCE_MLD_VERSION;
pub const NET_IPV6_ACCEPT_RA_DEFRTR: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_ACCEPT_RA_DEFRTR;
pub const NET_IPV6_ACCEPT_RA_PINFO: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_ACCEPT_RA_PINFO;
pub const NET_IPV6_ACCEPT_RA_RTR_PREF: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_ACCEPT_RA_RTR_PREF;
pub const NET_IPV6_RTR_PROBE_INTERVAL: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_RTR_PROBE_INTERVAL;
pub const NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN;
pub const NET_IPV6_PROXY_NDP: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_PROXY_NDP;
pub const NET_IPV6_ACCEPT_SOURCE_ROUTE: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_ACCEPT_SOURCE_ROUTE;
pub const NET_IPV6_ACCEPT_RA_FROM_LOCAL: _bindgen_ty_27 =
    _bindgen_ty_27::NET_IPV6_ACCEPT_RA_FROM_LOCAL;
pub const __NET_IPV6_MAX: _bindgen_ty_27 = _bindgen_ty_27::__NET_IPV6_MAX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_27 {
    NET_IPV6_FORWARDING = 1,
    NET_IPV6_HOP_LIMIT = 2,
    NET_IPV6_MTU = 3,
    NET_IPV6_ACCEPT_RA = 4,
    NET_IPV6_ACCEPT_REDIRECTS = 5,
    NET_IPV6_AUTOCONF = 6,
    NET_IPV6_DAD_TRANSMITS = 7,
    NET_IPV6_RTR_SOLICITS = 8,
    NET_IPV6_RTR_SOLICIT_INTERVAL = 9,
    NET_IPV6_RTR_SOLICIT_DELAY = 10,
    NET_IPV6_USE_TEMPADDR = 11,
    NET_IPV6_TEMP_VALID_LFT = 12,
    NET_IPV6_TEMP_PREFERED_LFT = 13,
    NET_IPV6_REGEN_MAX_RETRY = 14,
    NET_IPV6_MAX_DESYNC_FACTOR = 15,
    NET_IPV6_MAX_ADDRESSES = 16,
    NET_IPV6_FORCE_MLD_VERSION = 17,
    NET_IPV6_ACCEPT_RA_DEFRTR = 18,
    NET_IPV6_ACCEPT_RA_PINFO = 19,
    NET_IPV6_ACCEPT_RA_RTR_PREF = 20,
    NET_IPV6_RTR_PROBE_INTERVAL = 21,
    NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN = 22,
    NET_IPV6_PROXY_NDP = 23,
    NET_IPV6_ACCEPT_SOURCE_ROUTE = 25,
    NET_IPV6_ACCEPT_RA_FROM_LOCAL = 26,
    __NET_IPV6_MAX = 27,
}
pub const NET_IPV6_ICMP_RATELIMIT: _bindgen_ty_28 =
    _bindgen_ty_28::NET_IPV6_ICMP_RATELIMIT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_28 { NET_IPV6_ICMP_RATELIMIT = 1, }
pub const NET_NEIGH_MCAST_SOLICIT: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_MCAST_SOLICIT;
pub const NET_NEIGH_UCAST_SOLICIT: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_UCAST_SOLICIT;
pub const NET_NEIGH_APP_SOLICIT: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_APP_SOLICIT;
pub const NET_NEIGH_RETRANS_TIME: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_RETRANS_TIME;
pub const NET_NEIGH_REACHABLE_TIME: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_REACHABLE_TIME;
pub const NET_NEIGH_DELAY_PROBE_TIME: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_DELAY_PROBE_TIME;
pub const NET_NEIGH_GC_STALE_TIME: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_GC_STALE_TIME;
pub const NET_NEIGH_UNRES_QLEN: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_UNRES_QLEN;
pub const NET_NEIGH_PROXY_QLEN: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_PROXY_QLEN;
pub const NET_NEIGH_ANYCAST_DELAY: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_ANYCAST_DELAY;
pub const NET_NEIGH_PROXY_DELAY: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_PROXY_DELAY;
pub const NET_NEIGH_LOCKTIME: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_LOCKTIME;
pub const NET_NEIGH_GC_INTERVAL: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_GC_INTERVAL;
pub const NET_NEIGH_GC_THRESH1: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_GC_THRESH1;
pub const NET_NEIGH_GC_THRESH2: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_GC_THRESH2;
pub const NET_NEIGH_GC_THRESH3: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_GC_THRESH3;
pub const NET_NEIGH_RETRANS_TIME_MS: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_RETRANS_TIME_MS;
pub const NET_NEIGH_REACHABLE_TIME_MS: _bindgen_ty_29 =
    _bindgen_ty_29::NET_NEIGH_REACHABLE_TIME_MS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_29 {
    NET_NEIGH_MCAST_SOLICIT = 1,
    NET_NEIGH_UCAST_SOLICIT = 2,
    NET_NEIGH_APP_SOLICIT = 3,
    NET_NEIGH_RETRANS_TIME = 4,
    NET_NEIGH_REACHABLE_TIME = 5,
    NET_NEIGH_DELAY_PROBE_TIME = 6,
    NET_NEIGH_GC_STALE_TIME = 7,
    NET_NEIGH_UNRES_QLEN = 8,
    NET_NEIGH_PROXY_QLEN = 9,
    NET_NEIGH_ANYCAST_DELAY = 10,
    NET_NEIGH_PROXY_DELAY = 11,
    NET_NEIGH_LOCKTIME = 12,
    NET_NEIGH_GC_INTERVAL = 13,
    NET_NEIGH_GC_THRESH1 = 14,
    NET_NEIGH_GC_THRESH2 = 15,
    NET_NEIGH_GC_THRESH3 = 16,
    NET_NEIGH_RETRANS_TIME_MS = 17,
    NET_NEIGH_REACHABLE_TIME_MS = 18,
}
pub const NET_DCCP_DEFAULT: _bindgen_ty_30 = _bindgen_ty_30::NET_DCCP_DEFAULT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_30 { NET_DCCP_DEFAULT = 1, }
pub const NET_IPX_PPROP_BROADCASTING: _bindgen_ty_31 =
    _bindgen_ty_31::NET_IPX_PPROP_BROADCASTING;
pub const NET_IPX_FORWARDING: _bindgen_ty_31 =
    _bindgen_ty_31::NET_IPX_FORWARDING;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_31 {
    NET_IPX_PPROP_BROADCASTING = 1,
    NET_IPX_FORWARDING = 2,
}
pub const NET_LLC2: _bindgen_ty_32 = _bindgen_ty_32::NET_LLC2;
pub const NET_LLC_STATION: _bindgen_ty_32 = _bindgen_ty_32::NET_LLC_STATION;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_32 { NET_LLC2 = 1, NET_LLC_STATION = 2, }
pub const NET_LLC2_TIMEOUT: _bindgen_ty_33 = _bindgen_ty_33::NET_LLC2_TIMEOUT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_33 { NET_LLC2_TIMEOUT = 1, }
pub const NET_LLC_STATION_ACK_TIMEOUT: _bindgen_ty_34 =
    _bindgen_ty_34::NET_LLC_STATION_ACK_TIMEOUT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_34 { NET_LLC_STATION_ACK_TIMEOUT = 1, }
pub const NET_LLC2_ACK_TIMEOUT: _bindgen_ty_35 =
    _bindgen_ty_35::NET_LLC2_ACK_TIMEOUT;
pub const NET_LLC2_P_TIMEOUT: _bindgen_ty_35 =
    _bindgen_ty_35::NET_LLC2_P_TIMEOUT;
pub const NET_LLC2_REJ_TIMEOUT: _bindgen_ty_35 =
    _bindgen_ty_35::NET_LLC2_REJ_TIMEOUT;
pub const NET_LLC2_BUSY_TIMEOUT: _bindgen_ty_35 =
    _bindgen_ty_35::NET_LLC2_BUSY_TIMEOUT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_35 {
    NET_LLC2_ACK_TIMEOUT = 1,
    NET_LLC2_P_TIMEOUT = 2,
    NET_LLC2_REJ_TIMEOUT = 3,
    NET_LLC2_BUSY_TIMEOUT = 4,
}
pub const NET_ATALK_AARP_EXPIRY_TIME: _bindgen_ty_36 =
    _bindgen_ty_36::NET_ATALK_AARP_EXPIRY_TIME;
pub const NET_ATALK_AARP_TICK_TIME: _bindgen_ty_36 =
    _bindgen_ty_36::NET_ATALK_AARP_TICK_TIME;
pub const NET_ATALK_AARP_RETRANSMIT_LIMIT: _bindgen_ty_36 =
    _bindgen_ty_36::NET_ATALK_AARP_RETRANSMIT_LIMIT;
pub const NET_ATALK_AARP_RESOLVE_TIME: _bindgen_ty_36 =
    _bindgen_ty_36::NET_ATALK_AARP_RESOLVE_TIME;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_36 {
    NET_ATALK_AARP_EXPIRY_TIME = 1,
    NET_ATALK_AARP_TICK_TIME = 2,
    NET_ATALK_AARP_RETRANSMIT_LIMIT = 3,
    NET_ATALK_AARP_RESOLVE_TIME = 4,
}
pub const NET_NETROM_DEFAULT_PATH_QUALITY: _bindgen_ty_37 =
    _bindgen_ty_37::NET_NETROM_DEFAULT_PATH_QUALITY;
pub const NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER: _bindgen_ty_37 =
    _bindgen_ty_37::NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER;
pub const NET_NETROM_NETWORK_TTL_INITIALISER: _bindgen_ty_37 =
    _bindgen_ty_37::NET_NETROM_NETWORK_TTL_INITIALISER;
pub const NET_NETROM_TRANSPORT_TIMEOUT: _bindgen_ty_37 =
    _bindgen_ty_37::NET_NETROM_TRANSPORT_TIMEOUT;
pub const NET_NETROM_TRANSPORT_MAXIMUM_TRIES: _bindgen_ty_37 =
    _bindgen_ty_37::NET_NETROM_TRANSPORT_MAXIMUM_TRIES;
pub const NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY: _bindgen_ty_37 =
    _bindgen_ty_37::NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY;
pub const NET_NETROM_TRANSPORT_BUSY_DELAY: _bindgen_ty_37 =
    _bindgen_ty_37::NET_NETROM_TRANSPORT_BUSY_DELAY;
pub const NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE: _bindgen_ty_37 =
    _bindgen_ty_37::NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE;
pub const NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT: _bindgen_ty_37 =
    _bindgen_ty_37::NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT;
pub const NET_NETROM_ROUTING_CONTROL: _bindgen_ty_37 =
    _bindgen_ty_37::NET_NETROM_ROUTING_CONTROL;
pub const NET_NETROM_LINK_FAILS_COUNT: _bindgen_ty_37 =
    _bindgen_ty_37::NET_NETROM_LINK_FAILS_COUNT;
pub const NET_NETROM_RESET: _bindgen_ty_37 = _bindgen_ty_37::NET_NETROM_RESET;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_37 {
    NET_NETROM_DEFAULT_PATH_QUALITY = 1,
    NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER = 2,
    NET_NETROM_NETWORK_TTL_INITIALISER = 3,
    NET_NETROM_TRANSPORT_TIMEOUT = 4,
    NET_NETROM_TRANSPORT_MAXIMUM_TRIES = 5,
    NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY = 6,
    NET_NETROM_TRANSPORT_BUSY_DELAY = 7,
    NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE = 8,
    NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT = 9,
    NET_NETROM_ROUTING_CONTROL = 10,
    NET_NETROM_LINK_FAILS_COUNT = 11,
    NET_NETROM_RESET = 12,
}
pub const NET_AX25_IP_DEFAULT_MODE: _bindgen_ty_38 =
    _bindgen_ty_38::NET_AX25_IP_DEFAULT_MODE;
pub const NET_AX25_DEFAULT_MODE: _bindgen_ty_38 =
    _bindgen_ty_38::NET_AX25_DEFAULT_MODE;
pub const NET_AX25_BACKOFF_TYPE: _bindgen_ty_38 =
    _bindgen_ty_38::NET_AX25_BACKOFF_TYPE;
pub const NET_AX25_CONNECT_MODE: _bindgen_ty_38 =
    _bindgen_ty_38::NET_AX25_CONNECT_MODE;
pub const NET_AX25_STANDARD_WINDOW: _bindgen_ty_38 =
    _bindgen_ty_38::NET_AX25_STANDARD_WINDOW;
pub const NET_AX25_EXTENDED_WINDOW: _bindgen_ty_38 =
    _bindgen_ty_38::NET_AX25_EXTENDED_WINDOW;
pub const NET_AX25_T1_TIMEOUT: _bindgen_ty_38 =
    _bindgen_ty_38::NET_AX25_T1_TIMEOUT;
pub const NET_AX25_T2_TIMEOUT: _bindgen_ty_38 =
    _bindgen_ty_38::NET_AX25_T2_TIMEOUT;
pub const NET_AX25_T3_TIMEOUT: _bindgen_ty_38 =
    _bindgen_ty_38::NET_AX25_T3_TIMEOUT;
pub const NET_AX25_IDLE_TIMEOUT: _bindgen_ty_38 =
    _bindgen_ty_38::NET_AX25_IDLE_TIMEOUT;
pub const NET_AX25_N2: _bindgen_ty_38 = _bindgen_ty_38::NET_AX25_N2;
pub const NET_AX25_PACLEN: _bindgen_ty_38 = _bindgen_ty_38::NET_AX25_PACLEN;
pub const NET_AX25_PROTOCOL: _bindgen_ty_38 =
    _bindgen_ty_38::NET_AX25_PROTOCOL;
pub const NET_AX25_DAMA_SLAVE_TIMEOUT: _bindgen_ty_38 =
    _bindgen_ty_38::NET_AX25_DAMA_SLAVE_TIMEOUT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_38 {
    NET_AX25_IP_DEFAULT_MODE = 1,
    NET_AX25_DEFAULT_MODE = 2,
    NET_AX25_BACKOFF_TYPE = 3,
    NET_AX25_CONNECT_MODE = 4,
    NET_AX25_STANDARD_WINDOW = 5,
    NET_AX25_EXTENDED_WINDOW = 6,
    NET_AX25_T1_TIMEOUT = 7,
    NET_AX25_T2_TIMEOUT = 8,
    NET_AX25_T3_TIMEOUT = 9,
    NET_AX25_IDLE_TIMEOUT = 10,
    NET_AX25_N2 = 11,
    NET_AX25_PACLEN = 12,
    NET_AX25_PROTOCOL = 13,
    NET_AX25_DAMA_SLAVE_TIMEOUT = 14,
}
pub const NET_ROSE_RESTART_REQUEST_TIMEOUT: _bindgen_ty_39 =
    _bindgen_ty_39::NET_ROSE_RESTART_REQUEST_TIMEOUT;
pub const NET_ROSE_CALL_REQUEST_TIMEOUT: _bindgen_ty_39 =
    _bindgen_ty_39::NET_ROSE_CALL_REQUEST_TIMEOUT;
pub const NET_ROSE_RESET_REQUEST_TIMEOUT: _bindgen_ty_39 =
    _bindgen_ty_39::NET_ROSE_RESET_REQUEST_TIMEOUT;
pub const NET_ROSE_CLEAR_REQUEST_TIMEOUT: _bindgen_ty_39 =
    _bindgen_ty_39::NET_ROSE_CLEAR_REQUEST_TIMEOUT;
pub const NET_ROSE_ACK_HOLD_BACK_TIMEOUT: _bindgen_ty_39 =
    _bindgen_ty_39::NET_ROSE_ACK_HOLD_BACK_TIMEOUT;
pub const NET_ROSE_ROUTING_CONTROL: _bindgen_ty_39 =
    _bindgen_ty_39::NET_ROSE_ROUTING_CONTROL;
pub const NET_ROSE_LINK_FAIL_TIMEOUT: _bindgen_ty_39 =
    _bindgen_ty_39::NET_ROSE_LINK_FAIL_TIMEOUT;
pub const NET_ROSE_MAX_VCS: _bindgen_ty_39 = _bindgen_ty_39::NET_ROSE_MAX_VCS;
pub const NET_ROSE_WINDOW_SIZE: _bindgen_ty_39 =
    _bindgen_ty_39::NET_ROSE_WINDOW_SIZE;
pub const NET_ROSE_NO_ACTIVITY_TIMEOUT: _bindgen_ty_39 =
    _bindgen_ty_39::NET_ROSE_NO_ACTIVITY_TIMEOUT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_39 {
    NET_ROSE_RESTART_REQUEST_TIMEOUT = 1,
    NET_ROSE_CALL_REQUEST_TIMEOUT = 2,
    NET_ROSE_RESET_REQUEST_TIMEOUT = 3,
    NET_ROSE_CLEAR_REQUEST_TIMEOUT = 4,
    NET_ROSE_ACK_HOLD_BACK_TIMEOUT = 5,
    NET_ROSE_ROUTING_CONTROL = 6,
    NET_ROSE_LINK_FAIL_TIMEOUT = 7,
    NET_ROSE_MAX_VCS = 8,
    NET_ROSE_WINDOW_SIZE = 9,
    NET_ROSE_NO_ACTIVITY_TIMEOUT = 10,
}
pub const NET_X25_RESTART_REQUEST_TIMEOUT: _bindgen_ty_40 =
    _bindgen_ty_40::NET_X25_RESTART_REQUEST_TIMEOUT;
pub const NET_X25_CALL_REQUEST_TIMEOUT: _bindgen_ty_40 =
    _bindgen_ty_40::NET_X25_CALL_REQUEST_TIMEOUT;
pub const NET_X25_RESET_REQUEST_TIMEOUT: _bindgen_ty_40 =
    _bindgen_ty_40::NET_X25_RESET_REQUEST_TIMEOUT;
pub const NET_X25_CLEAR_REQUEST_TIMEOUT: _bindgen_ty_40 =
    _bindgen_ty_40::NET_X25_CLEAR_REQUEST_TIMEOUT;
pub const NET_X25_ACK_HOLD_BACK_TIMEOUT: _bindgen_ty_40 =
    _bindgen_ty_40::NET_X25_ACK_HOLD_BACK_TIMEOUT;
pub const NET_X25_FORWARD: _bindgen_ty_40 = _bindgen_ty_40::NET_X25_FORWARD;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_40 {
    NET_X25_RESTART_REQUEST_TIMEOUT = 1,
    NET_X25_CALL_REQUEST_TIMEOUT = 2,
    NET_X25_RESET_REQUEST_TIMEOUT = 3,
    NET_X25_CLEAR_REQUEST_TIMEOUT = 4,
    NET_X25_ACK_HOLD_BACK_TIMEOUT = 5,
    NET_X25_FORWARD = 6,
}
pub const NET_TR_RIF_TIMEOUT: _bindgen_ty_41 =
    _bindgen_ty_41::NET_TR_RIF_TIMEOUT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_41 { NET_TR_RIF_TIMEOUT = 1, }
pub const NET_DECNET_NODE_TYPE: _bindgen_ty_42 =
    _bindgen_ty_42::NET_DECNET_NODE_TYPE;
pub const NET_DECNET_NODE_ADDRESS: _bindgen_ty_42 =
    _bindgen_ty_42::NET_DECNET_NODE_ADDRESS;
pub const NET_DECNET_NODE_NAME: _bindgen_ty_42 =
    _bindgen_ty_42::NET_DECNET_NODE_NAME;
pub const NET_DECNET_DEFAULT_DEVICE: _bindgen_ty_42 =
    _bindgen_ty_42::NET_DECNET_DEFAULT_DEVICE;
pub const NET_DECNET_TIME_WAIT: _bindgen_ty_42 =
    _bindgen_ty_42::NET_DECNET_TIME_WAIT;
pub const NET_DECNET_DN_COUNT: _bindgen_ty_42 =
    _bindgen_ty_42::NET_DECNET_DN_COUNT;
pub const NET_DECNET_DI_COUNT: _bindgen_ty_42 =
    _bindgen_ty_42::NET_DECNET_DI_COUNT;
pub const NET_DECNET_DR_COUNT: _bindgen_ty_42 =
    _bindgen_ty_42::NET_DECNET_DR_COUNT;
pub const NET_DECNET_DST_GC_INTERVAL: _bindgen_ty_42 =
    _bindgen_ty_42::NET_DECNET_DST_GC_INTERVAL;
pub const NET_DECNET_CONF: _bindgen_ty_42 = _bindgen_ty_42::NET_DECNET_CONF;
pub const NET_DECNET_NO_FC_MAX_CWND: _bindgen_ty_42 =
    _bindgen_ty_42::NET_DECNET_NO_FC_MAX_CWND;
pub const NET_DECNET_MEM: _bindgen_ty_42 = _bindgen_ty_42::NET_DECNET_MEM;
pub const NET_DECNET_RMEM: _bindgen_ty_42 = _bindgen_ty_42::NET_DECNET_RMEM;
pub const NET_DECNET_WMEM: _bindgen_ty_42 = _bindgen_ty_42::NET_DECNET_WMEM;
pub const NET_DECNET_DEBUG_LEVEL: _bindgen_ty_42 =
    _bindgen_ty_42::NET_DECNET_DEBUG_LEVEL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_42 {
    NET_DECNET_NODE_TYPE = 1,
    NET_DECNET_NODE_ADDRESS = 2,
    NET_DECNET_NODE_NAME = 3,
    NET_DECNET_DEFAULT_DEVICE = 4,
    NET_DECNET_TIME_WAIT = 5,
    NET_DECNET_DN_COUNT = 6,
    NET_DECNET_DI_COUNT = 7,
    NET_DECNET_DR_COUNT = 8,
    NET_DECNET_DST_GC_INTERVAL = 9,
    NET_DECNET_CONF = 10,
    NET_DECNET_NO_FC_MAX_CWND = 11,
    NET_DECNET_MEM = 12,
    NET_DECNET_RMEM = 13,
    NET_DECNET_WMEM = 14,
    NET_DECNET_DEBUG_LEVEL = 255,
}
pub const NET_DECNET_CONF_LOOPBACK: _bindgen_ty_43 =
    _bindgen_ty_43::NET_DECNET_CONF_LOOPBACK;
pub const NET_DECNET_CONF_DDCMP: _bindgen_ty_43 =
    _bindgen_ty_43::NET_DECNET_CONF_DDCMP;
pub const NET_DECNET_CONF_PPP: _bindgen_ty_43 =
    _bindgen_ty_43::NET_DECNET_CONF_PPP;
pub const NET_DECNET_CONF_X25: _bindgen_ty_43 =
    _bindgen_ty_43::NET_DECNET_CONF_X25;
pub const NET_DECNET_CONF_GRE: _bindgen_ty_43 =
    _bindgen_ty_43::NET_DECNET_CONF_GRE;
pub const NET_DECNET_CONF_ETHER: _bindgen_ty_43 =
    _bindgen_ty_43::NET_DECNET_CONF_ETHER;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_43 {
    NET_DECNET_CONF_LOOPBACK = -2,
    NET_DECNET_CONF_DDCMP = -3,
    NET_DECNET_CONF_PPP = -4,
    NET_DECNET_CONF_X25 = -5,
    NET_DECNET_CONF_GRE = -6,
    NET_DECNET_CONF_ETHER = -7,
}
pub const NET_DECNET_CONF_DEV_PRIORITY: _bindgen_ty_44 =
    _bindgen_ty_44::NET_DECNET_CONF_DEV_PRIORITY;
pub const NET_DECNET_CONF_DEV_T1: _bindgen_ty_44 =
    _bindgen_ty_44::NET_DECNET_CONF_DEV_T1;
pub const NET_DECNET_CONF_DEV_T2: _bindgen_ty_44 =
    _bindgen_ty_44::NET_DECNET_CONF_DEV_T2;
pub const NET_DECNET_CONF_DEV_T3: _bindgen_ty_44 =
    _bindgen_ty_44::NET_DECNET_CONF_DEV_T3;
pub const NET_DECNET_CONF_DEV_FORWARDING: _bindgen_ty_44 =
    _bindgen_ty_44::NET_DECNET_CONF_DEV_FORWARDING;
pub const NET_DECNET_CONF_DEV_BLKSIZE: _bindgen_ty_44 =
    _bindgen_ty_44::NET_DECNET_CONF_DEV_BLKSIZE;
pub const NET_DECNET_CONF_DEV_STATE: _bindgen_ty_44 =
    _bindgen_ty_44::NET_DECNET_CONF_DEV_STATE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_44 {
    NET_DECNET_CONF_DEV_PRIORITY = 1,
    NET_DECNET_CONF_DEV_T1 = 2,
    NET_DECNET_CONF_DEV_T2 = 3,
    NET_DECNET_CONF_DEV_T3 = 4,
    NET_DECNET_CONF_DEV_FORWARDING = 5,
    NET_DECNET_CONF_DEV_BLKSIZE = 6,
    NET_DECNET_CONF_DEV_STATE = 7,
}
pub const NET_SCTP_RTO_INITIAL: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_RTO_INITIAL;
pub const NET_SCTP_RTO_MIN: _bindgen_ty_45 = _bindgen_ty_45::NET_SCTP_RTO_MIN;
pub const NET_SCTP_RTO_MAX: _bindgen_ty_45 = _bindgen_ty_45::NET_SCTP_RTO_MAX;
pub const NET_SCTP_RTO_ALPHA: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_RTO_ALPHA;
pub const NET_SCTP_RTO_BETA: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_RTO_BETA;
pub const NET_SCTP_VALID_COOKIE_LIFE: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_VALID_COOKIE_LIFE;
pub const NET_SCTP_ASSOCIATION_MAX_RETRANS: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_ASSOCIATION_MAX_RETRANS;
pub const NET_SCTP_PATH_MAX_RETRANS: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_PATH_MAX_RETRANS;
pub const NET_SCTP_MAX_INIT_RETRANSMITS: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_MAX_INIT_RETRANSMITS;
pub const NET_SCTP_HB_INTERVAL: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_HB_INTERVAL;
pub const NET_SCTP_PRESERVE_ENABLE: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_PRESERVE_ENABLE;
pub const NET_SCTP_MAX_BURST: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_MAX_BURST;
pub const NET_SCTP_ADDIP_ENABLE: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_ADDIP_ENABLE;
pub const NET_SCTP_PRSCTP_ENABLE: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_PRSCTP_ENABLE;
pub const NET_SCTP_SNDBUF_POLICY: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_SNDBUF_POLICY;
pub const NET_SCTP_SACK_TIMEOUT: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_SACK_TIMEOUT;
pub const NET_SCTP_RCVBUF_POLICY: _bindgen_ty_45 =
    _bindgen_ty_45::NET_SCTP_RCVBUF_POLICY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_45 {
    NET_SCTP_RTO_INITIAL = 1,
    NET_SCTP_RTO_MIN = 2,
    NET_SCTP_RTO_MAX = 3,
    NET_SCTP_RTO_ALPHA = 4,
    NET_SCTP_RTO_BETA = 5,
    NET_SCTP_VALID_COOKIE_LIFE = 6,
    NET_SCTP_ASSOCIATION_MAX_RETRANS = 7,
    NET_SCTP_PATH_MAX_RETRANS = 8,
    NET_SCTP_MAX_INIT_RETRANSMITS = 9,
    NET_SCTP_HB_INTERVAL = 10,
    NET_SCTP_PRESERVE_ENABLE = 11,
    NET_SCTP_MAX_BURST = 12,
    NET_SCTP_ADDIP_ENABLE = 13,
    NET_SCTP_PRSCTP_ENABLE = 14,
    NET_SCTP_SNDBUF_POLICY = 15,
    NET_SCTP_SACK_TIMEOUT = 16,
    NET_SCTP_RCVBUF_POLICY = 17,
}
pub const NET_BRIDGE_NF_CALL_ARPTABLES: _bindgen_ty_46 =
    _bindgen_ty_46::NET_BRIDGE_NF_CALL_ARPTABLES;
pub const NET_BRIDGE_NF_CALL_IPTABLES: _bindgen_ty_46 =
    _bindgen_ty_46::NET_BRIDGE_NF_CALL_IPTABLES;
pub const NET_BRIDGE_NF_CALL_IP6TABLES: _bindgen_ty_46 =
    _bindgen_ty_46::NET_BRIDGE_NF_CALL_IP6TABLES;
pub const NET_BRIDGE_NF_FILTER_VLAN_TAGGED: _bindgen_ty_46 =
    _bindgen_ty_46::NET_BRIDGE_NF_FILTER_VLAN_TAGGED;
pub const NET_BRIDGE_NF_FILTER_PPPOE_TAGGED: _bindgen_ty_46 =
    _bindgen_ty_46::NET_BRIDGE_NF_FILTER_PPPOE_TAGGED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_46 {
    NET_BRIDGE_NF_CALL_ARPTABLES = 1,
    NET_BRIDGE_NF_CALL_IPTABLES = 2,
    NET_BRIDGE_NF_CALL_IP6TABLES = 3,
    NET_BRIDGE_NF_FILTER_VLAN_TAGGED = 4,
    NET_BRIDGE_NF_FILTER_PPPOE_TAGGED = 5,
}
pub const NET_IRDA_DISCOVERY: _bindgen_ty_47 =
    _bindgen_ty_47::NET_IRDA_DISCOVERY;
pub const NET_IRDA_DEVNAME: _bindgen_ty_47 = _bindgen_ty_47::NET_IRDA_DEVNAME;
pub const NET_IRDA_DEBUG: _bindgen_ty_47 = _bindgen_ty_47::NET_IRDA_DEBUG;
pub const NET_IRDA_FAST_POLL: _bindgen_ty_47 =
    _bindgen_ty_47::NET_IRDA_FAST_POLL;
pub const NET_IRDA_DISCOVERY_SLOTS: _bindgen_ty_47 =
    _bindgen_ty_47::NET_IRDA_DISCOVERY_SLOTS;
pub const NET_IRDA_DISCOVERY_TIMEOUT: _bindgen_ty_47 =
    _bindgen_ty_47::NET_IRDA_DISCOVERY_TIMEOUT;
pub const NET_IRDA_SLOT_TIMEOUT: _bindgen_ty_47 =
    _bindgen_ty_47::NET_IRDA_SLOT_TIMEOUT;
pub const NET_IRDA_MAX_BAUD_RATE: _bindgen_ty_47 =
    _bindgen_ty_47::NET_IRDA_MAX_BAUD_RATE;
pub const NET_IRDA_MIN_TX_TURN_TIME: _bindgen_ty_47 =
    _bindgen_ty_47::NET_IRDA_MIN_TX_TURN_TIME;
pub const NET_IRDA_MAX_TX_DATA_SIZE: _bindgen_ty_47 =
    _bindgen_ty_47::NET_IRDA_MAX_TX_DATA_SIZE;
pub const NET_IRDA_MAX_TX_WINDOW: _bindgen_ty_47 =
    _bindgen_ty_47::NET_IRDA_MAX_TX_WINDOW;
pub const NET_IRDA_MAX_NOREPLY_TIME: _bindgen_ty_47 =
    _bindgen_ty_47::NET_IRDA_MAX_NOREPLY_TIME;
pub const NET_IRDA_WARN_NOREPLY_TIME: _bindgen_ty_47 =
    _bindgen_ty_47::NET_IRDA_WARN_NOREPLY_TIME;
pub const NET_IRDA_LAP_KEEPALIVE_TIME: _bindgen_ty_47 =
    _bindgen_ty_47::NET_IRDA_LAP_KEEPALIVE_TIME;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_47 {
    NET_IRDA_DISCOVERY = 1,
    NET_IRDA_DEVNAME = 2,
    NET_IRDA_DEBUG = 3,
    NET_IRDA_FAST_POLL = 4,
    NET_IRDA_DISCOVERY_SLOTS = 5,
    NET_IRDA_DISCOVERY_TIMEOUT = 6,
    NET_IRDA_SLOT_TIMEOUT = 7,
    NET_IRDA_MAX_BAUD_RATE = 8,
    NET_IRDA_MIN_TX_TURN_TIME = 9,
    NET_IRDA_MAX_TX_DATA_SIZE = 10,
    NET_IRDA_MAX_TX_WINDOW = 11,
    NET_IRDA_MAX_NOREPLY_TIME = 12,
    NET_IRDA_WARN_NOREPLY_TIME = 13,
    NET_IRDA_LAP_KEEPALIVE_TIME = 14,
}
pub const FS_NRINODE: _bindgen_ty_48 = _bindgen_ty_48::FS_NRINODE;
pub const FS_STATINODE: _bindgen_ty_48 = _bindgen_ty_48::FS_STATINODE;
pub const FS_MAXINODE: _bindgen_ty_48 = _bindgen_ty_48::FS_MAXINODE;
pub const FS_NRDQUOT: _bindgen_ty_48 = _bindgen_ty_48::FS_NRDQUOT;
pub const FS_MAXDQUOT: _bindgen_ty_48 = _bindgen_ty_48::FS_MAXDQUOT;
pub const FS_NRFILE: _bindgen_ty_48 = _bindgen_ty_48::FS_NRFILE;
pub const FS_MAXFILE: _bindgen_ty_48 = _bindgen_ty_48::FS_MAXFILE;
pub const FS_DENTRY: _bindgen_ty_48 = _bindgen_ty_48::FS_DENTRY;
pub const FS_NRSUPER: _bindgen_ty_48 = _bindgen_ty_48::FS_NRSUPER;
pub const FS_MAXSUPER: _bindgen_ty_48 = _bindgen_ty_48::FS_MAXSUPER;
pub const FS_OVERFLOWUID: _bindgen_ty_48 = _bindgen_ty_48::FS_OVERFLOWUID;
pub const FS_OVERFLOWGID: _bindgen_ty_48 = _bindgen_ty_48::FS_OVERFLOWGID;
pub const FS_LEASES: _bindgen_ty_48 = _bindgen_ty_48::FS_LEASES;
pub const FS_DIR_NOTIFY: _bindgen_ty_48 = _bindgen_ty_48::FS_DIR_NOTIFY;
pub const FS_LEASE_TIME: _bindgen_ty_48 = _bindgen_ty_48::FS_LEASE_TIME;
pub const FS_DQSTATS: _bindgen_ty_48 = _bindgen_ty_48::FS_DQSTATS;
pub const FS_XFS: _bindgen_ty_48 = _bindgen_ty_48::FS_XFS;
pub const FS_AIO_NR: _bindgen_ty_48 = _bindgen_ty_48::FS_AIO_NR;
pub const FS_AIO_MAX_NR: _bindgen_ty_48 = _bindgen_ty_48::FS_AIO_MAX_NR;
pub const FS_INOTIFY: _bindgen_ty_48 = _bindgen_ty_48::FS_INOTIFY;
pub const FS_OCFS2: _bindgen_ty_48 = _bindgen_ty_48::FS_OCFS2;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_48 {
    FS_NRINODE = 1,
    FS_STATINODE = 2,
    FS_MAXINODE = 3,
    FS_NRDQUOT = 4,
    FS_MAXDQUOT = 5,
    FS_NRFILE = 6,
    FS_MAXFILE = 7,
    FS_DENTRY = 8,
    FS_NRSUPER = 9,
    FS_MAXSUPER = 10,
    FS_OVERFLOWUID = 11,
    FS_OVERFLOWGID = 12,
    FS_LEASES = 13,
    FS_DIR_NOTIFY = 14,
    FS_LEASE_TIME = 15,
    FS_DQSTATS = 16,
    FS_XFS = 17,
    FS_AIO_NR = 18,
    FS_AIO_MAX_NR = 19,
    FS_INOTIFY = 20,
    FS_OCFS2 = 988,
}
pub const FS_DQ_LOOKUPS: _bindgen_ty_49 = _bindgen_ty_49::FS_DQ_LOOKUPS;
pub const FS_DQ_DROPS: _bindgen_ty_49 = _bindgen_ty_49::FS_DQ_DROPS;
pub const FS_DQ_READS: _bindgen_ty_49 = _bindgen_ty_49::FS_DQ_READS;
pub const FS_DQ_WRITES: _bindgen_ty_49 = _bindgen_ty_49::FS_DQ_WRITES;
pub const FS_DQ_CACHE_HITS: _bindgen_ty_49 = _bindgen_ty_49::FS_DQ_CACHE_HITS;
pub const FS_DQ_ALLOCATED: _bindgen_ty_49 = _bindgen_ty_49::FS_DQ_ALLOCATED;
pub const FS_DQ_FREE: _bindgen_ty_49 = _bindgen_ty_49::FS_DQ_FREE;
pub const FS_DQ_SYNCS: _bindgen_ty_49 = _bindgen_ty_49::FS_DQ_SYNCS;
pub const FS_DQ_WARNINGS: _bindgen_ty_49 = _bindgen_ty_49::FS_DQ_WARNINGS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_49 {
    FS_DQ_LOOKUPS = 1,
    FS_DQ_DROPS = 2,
    FS_DQ_READS = 3,
    FS_DQ_WRITES = 4,
    FS_DQ_CACHE_HITS = 5,
    FS_DQ_ALLOCATED = 6,
    FS_DQ_FREE = 7,
    FS_DQ_SYNCS = 8,
    FS_DQ_WARNINGS = 9,
}
pub const DEV_CDROM: _bindgen_ty_50 = _bindgen_ty_50::DEV_CDROM;
pub const DEV_HWMON: _bindgen_ty_50 = _bindgen_ty_50::DEV_HWMON;
pub const DEV_PARPORT: _bindgen_ty_50 = _bindgen_ty_50::DEV_PARPORT;
pub const DEV_RAID: _bindgen_ty_50 = _bindgen_ty_50::DEV_RAID;
pub const DEV_MAC_HID: _bindgen_ty_50 = _bindgen_ty_50::DEV_MAC_HID;
pub const DEV_SCSI: _bindgen_ty_50 = _bindgen_ty_50::DEV_SCSI;
pub const DEV_IPMI: _bindgen_ty_50 = _bindgen_ty_50::DEV_IPMI;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_50 {
    DEV_CDROM = 1,
    DEV_HWMON = 2,
    DEV_PARPORT = 3,
    DEV_RAID = 4,
    DEV_MAC_HID = 5,
    DEV_SCSI = 6,
    DEV_IPMI = 7,
}
pub const DEV_CDROM_INFO: _bindgen_ty_51 = _bindgen_ty_51::DEV_CDROM_INFO;
pub const DEV_CDROM_AUTOCLOSE: _bindgen_ty_51 =
    _bindgen_ty_51::DEV_CDROM_AUTOCLOSE;
pub const DEV_CDROM_AUTOEJECT: _bindgen_ty_51 =
    _bindgen_ty_51::DEV_CDROM_AUTOEJECT;
pub const DEV_CDROM_DEBUG: _bindgen_ty_51 = _bindgen_ty_51::DEV_CDROM_DEBUG;
pub const DEV_CDROM_LOCK: _bindgen_ty_51 = _bindgen_ty_51::DEV_CDROM_LOCK;
pub const DEV_CDROM_CHECK_MEDIA: _bindgen_ty_51 =
    _bindgen_ty_51::DEV_CDROM_CHECK_MEDIA;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_51 {
    DEV_CDROM_INFO = 1,
    DEV_CDROM_AUTOCLOSE = 2,
    DEV_CDROM_AUTOEJECT = 3,
    DEV_CDROM_DEBUG = 4,
    DEV_CDROM_LOCK = 5,
    DEV_CDROM_CHECK_MEDIA = 6,
}
pub const DEV_PARPORT_DEFAULT: _bindgen_ty_52 =
    _bindgen_ty_52::DEV_PARPORT_DEFAULT;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_52 { DEV_PARPORT_DEFAULT = -3, }
pub const DEV_RAID_SPEED_LIMIT_MIN: _bindgen_ty_53 =
    _bindgen_ty_53::DEV_RAID_SPEED_LIMIT_MIN;
pub const DEV_RAID_SPEED_LIMIT_MAX: _bindgen_ty_53 =
    _bindgen_ty_53::DEV_RAID_SPEED_LIMIT_MAX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_53 {
    DEV_RAID_SPEED_LIMIT_MIN = 1,
    DEV_RAID_SPEED_LIMIT_MAX = 2,
}
pub const DEV_PARPORT_DEFAULT_TIMESLICE: _bindgen_ty_54 =
    _bindgen_ty_54::DEV_PARPORT_DEFAULT_TIMESLICE;
pub const DEV_PARPORT_DEFAULT_SPINTIME: _bindgen_ty_54 =
    _bindgen_ty_54::DEV_PARPORT_DEFAULT_SPINTIME;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_54 {
    DEV_PARPORT_DEFAULT_TIMESLICE = 1,
    DEV_PARPORT_DEFAULT_SPINTIME = 2,
}
pub const DEV_PARPORT_SPINTIME: _bindgen_ty_55 =
    _bindgen_ty_55::DEV_PARPORT_SPINTIME;
pub const DEV_PARPORT_BASE_ADDR: _bindgen_ty_55 =
    _bindgen_ty_55::DEV_PARPORT_BASE_ADDR;
pub const DEV_PARPORT_IRQ: _bindgen_ty_55 = _bindgen_ty_55::DEV_PARPORT_IRQ;
pub const DEV_PARPORT_DMA: _bindgen_ty_55 = _bindgen_ty_55::DEV_PARPORT_DMA;
pub const DEV_PARPORT_MODES: _bindgen_ty_55 =
    _bindgen_ty_55::DEV_PARPORT_MODES;
pub const DEV_PARPORT_DEVICES: _bindgen_ty_55 =
    _bindgen_ty_55::DEV_PARPORT_DEVICES;
pub const DEV_PARPORT_AUTOPROBE: _bindgen_ty_55 =
    _bindgen_ty_55::DEV_PARPORT_AUTOPROBE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_55 {
    DEV_PARPORT_SPINTIME = 1,
    DEV_PARPORT_BASE_ADDR = 2,
    DEV_PARPORT_IRQ = 3,
    DEV_PARPORT_DMA = 4,
    DEV_PARPORT_MODES = 5,
    DEV_PARPORT_DEVICES = 6,
    DEV_PARPORT_AUTOPROBE = 16,
}
pub const DEV_PARPORT_DEVICES_ACTIVE: _bindgen_ty_56 =
    _bindgen_ty_56::DEV_PARPORT_DEVICES_ACTIVE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_56 { DEV_PARPORT_DEVICES_ACTIVE = -3, }
pub const DEV_PARPORT_DEVICE_TIMESLICE: _bindgen_ty_57 =
    _bindgen_ty_57::DEV_PARPORT_DEVICE_TIMESLICE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_57 { DEV_PARPORT_DEVICE_TIMESLICE = 1, }
pub const DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES: _bindgen_ty_58 =
    _bindgen_ty_58::DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES;
pub const DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES: _bindgen_ty_58 =
    _bindgen_ty_58::DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES;
pub const DEV_MAC_HID_MOUSE_BUTTON_EMULATION: _bindgen_ty_58 =
    _bindgen_ty_58::DEV_MAC_HID_MOUSE_BUTTON_EMULATION;
pub const DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE: _bindgen_ty_58 =
    _bindgen_ty_58::DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE;
pub const DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE: _bindgen_ty_58 =
    _bindgen_ty_58::DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE;
pub const DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES: _bindgen_ty_58 =
    _bindgen_ty_58::DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_58 {
    DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES = 1,
    DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES = 2,
    DEV_MAC_HID_MOUSE_BUTTON_EMULATION = 3,
    DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE = 4,
    DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE = 5,
    DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES = 6,
}
pub const DEV_SCSI_LOGGING_LEVEL: _bindgen_ty_59 =
    _bindgen_ty_59::DEV_SCSI_LOGGING_LEVEL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_59 { DEV_SCSI_LOGGING_LEVEL = 1, }
pub const DEV_IPMI_POWEROFF_POWERCYCLE: _bindgen_ty_60 =
    _bindgen_ty_60::DEV_IPMI_POWEROFF_POWERCYCLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_60 { DEV_IPMI_POWEROFF_POWERCYCLE = 1, }
pub const ABI_DEFHANDLER_COFF: _bindgen_ty_61 =
    _bindgen_ty_61::ABI_DEFHANDLER_COFF;
pub const ABI_DEFHANDLER_ELF: _bindgen_ty_61 =
    _bindgen_ty_61::ABI_DEFHANDLER_ELF;
pub const ABI_DEFHANDLER_LCALL7: _bindgen_ty_61 =
    _bindgen_ty_61::ABI_DEFHANDLER_LCALL7;
pub const ABI_DEFHANDLER_LIBCSO: _bindgen_ty_61 =
    _bindgen_ty_61::ABI_DEFHANDLER_LIBCSO;
pub const ABI_TRACE: _bindgen_ty_61 = _bindgen_ty_61::ABI_TRACE;
pub const ABI_FAKE_UTSNAME: _bindgen_ty_61 = _bindgen_ty_61::ABI_FAKE_UTSNAME;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_61 {
    ABI_DEFHANDLER_COFF = 1,
    ABI_DEFHANDLER_ELF = 2,
    ABI_DEFHANDLER_LCALL7 = 3,
    ABI_DEFHANDLER_LIBCSO = 4,
    ABI_TRACE = 5,
    ABI_FAKE_UTSNAME = 6,
}
#[repr(C)]
#[derive(Copy)]
pub struct ctl_table {
    pub procname: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub maxlen: ::std::os::raw::c_int,
    pub mode: umode_t,
    pub child: *mut ctl_table,
    pub proc_handler: proc_handler,
    pub poll: *mut ctl_table_poll,
    pub extra1: *mut ::std::os::raw::c_void,
    pub extra2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ctl_table() {
    assert_eq!(::std::mem::size_of::<ctl_table>() , 64usize , concat ! (
               "Size of: " , stringify ! ( ctl_table ) ));
    assert_eq! (::std::mem::align_of::<ctl_table>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ctl_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table ) ) . procname as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table ) , "::" ,
                stringify ! ( procname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table ) ) . data as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table ) ) . maxlen as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table ) , "::" ,
                stringify ! ( maxlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table ) ) . mode as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table ) , "::" ,
                stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table ) ) . child as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table ) , "::" ,
                stringify ! ( child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table ) ) . proc_handler as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table ) , "::" ,
                stringify ! ( proc_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table ) ) . poll as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table ) , "::" ,
                stringify ! ( poll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table ) ) . extra1 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table ) , "::" ,
                stringify ! ( extra1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table ) ) . extra2 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table ) , "::" ,
                stringify ! ( extra2 ) ));
}
impl Clone for ctl_table {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsproxy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct ctl_table_root {
    pub default_set: ctl_table_set,
    pub lookup: ::std::option::Option<unsafe extern "C" fn(root:
                                                               *mut ctl_table_root,
                                                           namespaces:
                                                               *mut nsproxy)
                                          -> *mut ctl_table_set>,
    pub permissions: ::std::option::Option<unsafe extern "C" fn(head:
                                                                    *mut ctl_table_header,
                                                                table:
                                                                    *mut ctl_table)
                                               -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_ctl_table_root() {
    assert_eq!(::std::mem::size_of::<ctl_table_root>() , 104usize , concat ! (
               "Size of: " , stringify ! ( ctl_table_root ) ));
    assert_eq! (::std::mem::align_of::<ctl_table_root>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ctl_table_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table_root ) ) . default_set as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table_root ) , "::"
                , stringify ! ( default_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table_root ) ) . lookup as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table_root ) , "::"
                , stringify ! ( lookup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table_root ) ) . permissions as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table_root ) , "::"
                , stringify ! ( permissions ) ));
}
impl Clone for ctl_table_root {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ctl_table_header {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1,
    pub unregistering: *mut completion,
    pub ctl_table_arg: *mut ctl_table,
    pub root: *mut ctl_table_root,
    pub set: *mut ctl_table_set,
    pub parent: *mut ctl_dir,
    pub node: *mut ctl_node,
}
#[repr(C)]
#[derive(Copy)]
pub struct ctl_table_header__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<ctl_table_header__bindgen_ty_1__bindgen_ty_1>,
    pub rcu: __BindgenUnionField<callback_head>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    pub ctl_table: *mut ctl_table,
    pub used: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub nreg: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ctl_table_header__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               ctl_table_header__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                ctl_table_header__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const ctl_table_header__bindgen_ty_1__bindgen_ty_1
                ) ) . ctl_table as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ctl_table_header__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( ctl_table ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const ctl_table_header__bindgen_ty_1__bindgen_ty_1
                ) ) . used as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                ctl_table_header__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( used ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const ctl_table_header__bindgen_ty_1__bindgen_ty_1
                ) ) . count as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                ctl_table_header__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const ctl_table_header__bindgen_ty_1__bindgen_ty_1
                ) ) . nreg as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                ctl_table_header__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( nreg ) ));
}
impl Clone for ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ctl_table_header__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ctl_table_header__bindgen_ty_1>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( ctl_table_header__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<ctl_table_header__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( ctl_table_header__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table_header__bindgen_ty_1 ) ) . rcu
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ctl_table_header__bindgen_ty_1 ) , "::" , stringify ! ( rcu )
                ));
}
impl Clone for ctl_table_header__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ctl_table_header() {
    assert_eq!(::std::mem::size_of::<ctl_table_header>() , 72usize , concat !
               ( "Size of: " , stringify ! ( ctl_table_header ) ));
    assert_eq! (::std::mem::align_of::<ctl_table_header>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ctl_table_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table_header ) ) . unregistering as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table_header ) ,
                "::" , stringify ! ( unregistering ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table_header ) ) . ctl_table_arg as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table_header ) ,
                "::" , stringify ! ( ctl_table_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table_header ) ) . root as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table_header ) ,
                "::" , stringify ! ( root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table_header ) ) . set as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table_header ) ,
                "::" , stringify ! ( set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table_header ) ) . parent as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table_header ) ,
                "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table_header ) ) . node as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table_header ) ,
                "::" , stringify ! ( node ) ));
}
impl Clone for ctl_table_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ctl_dir {
    pub header: ctl_table_header,
    pub root: rb_root,
}
#[test]
fn bindgen_test_layout_ctl_dir() {
    assert_eq!(::std::mem::size_of::<ctl_dir>() , 80usize , concat ! (
               "Size of: " , stringify ! ( ctl_dir ) ));
    assert_eq! (::std::mem::align_of::<ctl_dir>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ctl_dir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_dir ) ) . header as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_dir ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_dir ) ) . root as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_dir ) , "::" ,
                stringify ! ( root ) ));
}
impl Clone for ctl_dir {
    fn clone(&self) -> Self { *self }
}
pub type proc_handler =
    ::std::option::Option<unsafe extern "C" fn(ctl: *mut ctl_table,
                                               write: ::std::os::raw::c_int,
                                               buffer:
                                                   *mut ::std::os::raw::c_void,
                                               lenp: *mut usize,
                                               ppos: *mut loff_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn proc_dostring(arg1: *mut ctl_table, arg2: ::std::os::raw::c_int,
                         arg3: *mut ::std::os::raw::c_void, arg4: *mut usize,
                         arg5: *mut loff_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_dointvec(arg1: *mut ctl_table, arg2: ::std::os::raw::c_int,
                         arg3: *mut ::std::os::raw::c_void, arg4: *mut usize,
                         arg5: *mut loff_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_dointvec_minmax(arg1: *mut ctl_table,
                                arg2: ::std::os::raw::c_int,
                                arg3: *mut ::std::os::raw::c_void,
                                arg4: *mut usize, arg5: *mut loff_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_dointvec_jiffies(arg1: *mut ctl_table,
                                 arg2: ::std::os::raw::c_int,
                                 arg3: *mut ::std::os::raw::c_void,
                                 arg4: *mut usize, arg5: *mut loff_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_dointvec_userhz_jiffies(arg1: *mut ctl_table,
                                        arg2: ::std::os::raw::c_int,
                                        arg3: *mut ::std::os::raw::c_void,
                                        arg4: *mut usize, arg5: *mut loff_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_dointvec_ms_jiffies(arg1: *mut ctl_table,
                                    arg2: ::std::os::raw::c_int,
                                    arg3: *mut ::std::os::raw::c_void,
                                    arg4: *mut usize, arg5: *mut loff_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_doulongvec_minmax(arg1: *mut ctl_table,
                                  arg2: ::std::os::raw::c_int,
                                  arg3: *mut ::std::os::raw::c_void,
                                  arg4: *mut usize, arg5: *mut loff_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_doulongvec_ms_jiffies_minmax(table: *mut ctl_table,
                                             arg1: ::std::os::raw::c_int,
                                             arg2:
                                                 *mut ::std::os::raw::c_void,
                                             arg3: *mut usize,
                                             arg4: *mut loff_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_do_large_bitmap(arg1: *mut ctl_table,
                                arg2: ::std::os::raw::c_int,
                                arg3: *mut ::std::os::raw::c_void,
                                arg4: *mut usize, arg5: *mut loff_t)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct ctl_table_poll {
    pub event: atomic_t,
    pub wait: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_ctl_table_poll() {
    assert_eq!(::std::mem::size_of::<ctl_table_poll>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ctl_table_poll ) ));
    assert_eq! (::std::mem::align_of::<ctl_table_poll>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ctl_table_poll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table_poll ) ) . event as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table_poll ) , "::"
                , stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table_poll ) ) . wait as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table_poll ) , "::"
                , stringify ! ( wait ) ));
}
impl Clone for ctl_table_poll {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ctl_node {
    pub node: rb_node,
    pub header: *mut ctl_table_header,
}
#[test]
fn bindgen_test_layout_ctl_node() {
    assert_eq!(::std::mem::size_of::<ctl_node>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ctl_node ) ));
    assert_eq! (::std::mem::align_of::<ctl_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ctl_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_node ) ) . node as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_node ) , "::" ,
                stringify ! ( node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_node ) ) . header as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_node ) , "::" ,
                stringify ! ( header ) ));
}
impl Clone for ctl_node {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ctl_table_set {
    pub is_seen: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut ctl_table_set)
                                           -> ::std::os::raw::c_int>,
    pub dir: ctl_dir,
}
#[test]
fn bindgen_test_layout_ctl_table_set() {
    assert_eq!(::std::mem::size_of::<ctl_table_set>() , 88usize , concat ! (
               "Size of: " , stringify ! ( ctl_table_set ) ));
    assert_eq! (::std::mem::align_of::<ctl_table_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ctl_table_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table_set ) ) . is_seen as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table_set ) , "::"
                , stringify ! ( is_seen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_table_set ) ) . dir as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_table_set ) , "::"
                , stringify ! ( dir ) ));
}
impl Clone for ctl_table_set {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ctl_path {
    pub procname: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ctl_path() {
    assert_eq!(::std::mem::size_of::<ctl_path>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ctl_path ) ));
    assert_eq! (::std::mem::align_of::<ctl_path>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ctl_path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctl_path ) ) . procname as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ctl_path ) , "::" ,
                stringify ! ( procname ) ));
}
impl Clone for ctl_path {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn proc_sys_poll_notify(poll: *mut ctl_table_poll);
}
extern "C" {
    pub fn setup_sysctl_set(p: *mut ctl_table_set, root: *mut ctl_table_root,
                            is_seen:
                                ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                               *mut ctl_table_set)
                                                          ->
                                                              ::std::os::raw::c_int>);
}
extern "C" {
    pub fn retire_sysctl_set(set: *mut ctl_table_set);
}
extern "C" {
    pub fn register_sysctl_root(root: *mut ctl_table_root);
}
extern "C" {
    pub fn __register_sysctl_table(set: *mut ctl_table_set,
                                   path: *const ::std::os::raw::c_char,
                                   table: *mut ctl_table)
     -> *mut ctl_table_header;
}
extern "C" {
    pub fn __register_sysctl_paths(set: *mut ctl_table_set,
                                   path: *const ctl_path,
                                   table: *mut ctl_table)
     -> *mut ctl_table_header;
}
extern "C" {
    pub fn register_sysctl(path: *const ::std::os::raw::c_char,
                           table: *mut ctl_table) -> *mut ctl_table_header;
}
extern "C" {
    pub fn register_sysctl_table(table: *mut ctl_table)
     -> *mut ctl_table_header;
}
extern "C" {
    pub fn register_sysctl_paths(path: *const ctl_path, table: *mut ctl_table)
     -> *mut ctl_table_header;
}
extern "C" {
    pub fn unregister_sysctl_table(table: *mut ctl_table_header);
}
extern "C" {
    pub fn sysctl_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sysctl_mount_point"]
    pub static mut sysctl_mount_point: [ctl_table; 0usize];
}
extern "C" {
    pub fn sysctl_max_threads(table: *mut ctl_table,
                              write: ::std::os::raw::c_int,
                              buffer: *mut ::std::os::raw::c_void,
                              lenp: *mut usize, ppos: *mut loff_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sysctl_timer_migration"]
    pub static mut sysctl_timer_migration: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn timer_migration_handler(table: *mut ctl_table,
                                   write: ::std::os::raw::c_int,
                                   buffer: *mut ::std::os::raw::c_void,
                                   lenp: *mut usize, ppos: *mut loff_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __round_jiffies(j: ::std::os::raw::c_ulong,
                           cpu: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_relative(j: ::std::os::raw::c_ulong,
                                    cpu: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn round_jiffies(j: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn round_jiffies_relative(j: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_up(j: ::std::os::raw::c_ulong,
                              cpu: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_up_relative(j: ::std::os::raw::c_ulong,
                                       cpu: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn round_jiffies_up(j: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn round_jiffies_up_relative(j: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct workqueue_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct work_struct {
    pub data: atomic_long_t,
    pub entry: list_head,
    pub func: work_func_t,
}
#[test]
fn bindgen_test_layout_work_struct() {
    assert_eq!(::std::mem::size_of::<work_struct>() , 32usize , concat ! (
               "Size of: " , stringify ! ( work_struct ) ));
    assert_eq! (::std::mem::align_of::<work_struct>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( work_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const work_struct ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( work_struct ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const work_struct ) ) . entry as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( work_struct ) , "::" ,
                stringify ! ( entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const work_struct ) ) . func as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( work_struct ) , "::" ,
                stringify ! ( func ) ));
}
impl Clone for work_struct {
    fn clone(&self) -> Self { *self }
}
pub type work_func_t =
    ::std::option::Option<unsafe extern "C" fn(work: *mut work_struct)>;
extern "C" {
    pub fn delayed_work_timer_fn(__data: ::std::os::raw::c_ulong);
}
pub const WORK_STRUCT_PENDING_BIT: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_PENDING_BIT;
pub const WORK_STRUCT_DELAYED_BIT: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_DELAYED_BIT;
pub const WORK_STRUCT_PWQ_BIT: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_PWQ_BIT;
pub const WORK_STRUCT_LINKED_BIT: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_LINKED_BIT;
pub const WORK_STRUCT_COLOR_SHIFT: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_COLOR_SHIFT;
pub const WORK_STRUCT_COLOR_BITS: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_COLOR_SHIFT;
pub const WORK_STRUCT_PENDING: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_DELAYED_BIT;
pub const WORK_STRUCT_DELAYED: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_PWQ_BIT;
pub const WORK_STRUCT_PWQ: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_COLOR_SHIFT;
pub const WORK_STRUCT_LINKED: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_LINKED;
pub const WORK_STRUCT_STATIC: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_PENDING_BIT;
pub const WORK_NR_COLORS: _bindgen_ty_62 = _bindgen_ty_62::WORK_NR_COLORS;
pub const WORK_NO_COLOR: _bindgen_ty_62 = _bindgen_ty_62::WORK_NR_COLORS;
pub const WORK_CPU_UNBOUND: _bindgen_ty_62 = _bindgen_ty_62::WORK_CPU_UNBOUND;
pub const WORK_STRUCT_FLAG_BITS: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_LINKED;
pub const WORK_OFFQ_FLAG_BASE: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_COLOR_SHIFT;
pub const __WORK_OFFQ_CANCELING: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_COLOR_SHIFT;
pub const WORK_OFFQ_CANCELING: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_OFFQ_CANCELING;
pub const WORK_OFFQ_FLAG_BITS: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_DELAYED_BIT;
pub const WORK_OFFQ_POOL_SHIFT: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_OFFQ_POOL_SHIFT;
pub const WORK_OFFQ_LEFT: _bindgen_ty_62 = _bindgen_ty_62::WORK_OFFQ_LEFT;
pub const WORK_OFFQ_POOL_BITS: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_OFFQ_POOL_BITS;
pub const WORK_OFFQ_POOL_NONE: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_OFFQ_POOL_NONE;
pub const WORK_STRUCT_FLAG_MASK: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_FLAG_MASK;
pub const WORK_STRUCT_WQ_DATA_MASK: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_WQ_DATA_MASK;
pub const WORK_STRUCT_NO_POOL: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_NO_POOL;
pub const WORK_BUSY_PENDING: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_DELAYED_BIT;
pub const WORK_BUSY_RUNNING: _bindgen_ty_62 =
    _bindgen_ty_62::WORK_STRUCT_PWQ_BIT;
pub const WORKER_DESC_LEN: _bindgen_ty_62 = _bindgen_ty_62::WORKER_DESC_LEN;
#[repr(i64)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_62 {
    WORK_STRUCT_PENDING_BIT = 0,
    WORK_STRUCT_DELAYED_BIT = 1,
    WORK_STRUCT_PWQ_BIT = 2,
    WORK_STRUCT_LINKED_BIT = 3,
    WORK_STRUCT_COLOR_SHIFT = 4,
    WORK_STRUCT_LINKED = 8,
    WORK_NR_COLORS = 15,
    WORK_CPU_UNBOUND = 256,
    WORK_OFFQ_CANCELING = 16,
    WORK_OFFQ_POOL_SHIFT = 5,
    WORK_OFFQ_LEFT = 59,
    WORK_OFFQ_POOL_BITS = 31,
    WORK_OFFQ_POOL_NONE = 2147483647,
    WORK_STRUCT_FLAG_MASK = 255,
    WORK_STRUCT_WQ_DATA_MASK = -256,
    WORK_STRUCT_NO_POOL = 68719476704,
    WORKER_DESC_LEN = 24,
}
#[repr(C)]
#[derive(Copy)]
pub struct delayed_work {
    pub work: work_struct,
    pub timer: timer_list,
    pub wq: *mut workqueue_struct,
    pub cpu: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_delayed_work() {
    assert_eq!(::std::mem::size_of::<delayed_work>() , 128usize , concat ! (
               "Size of: " , stringify ! ( delayed_work ) ));
    assert_eq! (::std::mem::align_of::<delayed_work>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( delayed_work ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const delayed_work ) ) . work as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( delayed_work ) , "::" ,
                stringify ! ( work ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const delayed_work ) ) . timer as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( delayed_work ) , "::" ,
                stringify ! ( timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const delayed_work ) ) . wq as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( delayed_work ) , "::" ,
                stringify ! ( wq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const delayed_work ) ) . cpu as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( delayed_work ) , "::" ,
                stringify ! ( cpu ) ));
}
impl Clone for delayed_work {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct workqueue_attrs {
    pub nice: ::std::os::raw::c_int,
    pub cpumask: cpumask_var_t,
    pub no_numa: bool_,
}
#[test]
fn bindgen_test_layout_workqueue_attrs() {
    assert_eq!(::std::mem::size_of::<workqueue_attrs>() , 48usize , concat ! (
               "Size of: " , stringify ! ( workqueue_attrs ) ));
    assert_eq! (::std::mem::align_of::<workqueue_attrs>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( workqueue_attrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const workqueue_attrs ) ) . nice as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( workqueue_attrs ) ,
                "::" , stringify ! ( nice ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const workqueue_attrs ) ) . cpumask as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( workqueue_attrs ) ,
                "::" , stringify ! ( cpumask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const workqueue_attrs ) ) . no_numa as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( workqueue_attrs ) ,
                "::" , stringify ! ( no_numa ) ));
}
impl Clone for workqueue_attrs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct execute_work {
    pub work: work_struct,
}
#[test]
fn bindgen_test_layout_execute_work() {
    assert_eq!(::std::mem::size_of::<execute_work>() , 32usize , concat ! (
               "Size of: " , stringify ! ( execute_work ) ));
    assert_eq! (::std::mem::align_of::<execute_work>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( execute_work ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const execute_work ) ) . work as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( execute_work ) , "::" ,
                stringify ! ( work ) ));
}
impl Clone for execute_work {
    fn clone(&self) -> Self { *self }
}
pub const WQ_UNBOUND: _bindgen_ty_63 = _bindgen_ty_63::WQ_UNBOUND;
pub const WQ_FREEZABLE: _bindgen_ty_63 = _bindgen_ty_63::WQ_FREEZABLE;
pub const WQ_MEM_RECLAIM: _bindgen_ty_63 = _bindgen_ty_63::WQ_MEM_RECLAIM;
pub const WQ_HIGHPRI: _bindgen_ty_63 = _bindgen_ty_63::WQ_HIGHPRI;
pub const WQ_CPU_INTENSIVE: _bindgen_ty_63 = _bindgen_ty_63::WQ_CPU_INTENSIVE;
pub const WQ_SYSFS: _bindgen_ty_63 = _bindgen_ty_63::WQ_SYSFS;
pub const WQ_POWER_EFFICIENT: _bindgen_ty_63 =
    _bindgen_ty_63::WQ_POWER_EFFICIENT;
pub const __WQ_DRAINING: _bindgen_ty_63 = _bindgen_ty_63::__WQ_DRAINING;
pub const __WQ_ORDERED: _bindgen_ty_63 = _bindgen_ty_63::__WQ_ORDERED;
pub const WQ_MAX_ACTIVE: _bindgen_ty_63 = _bindgen_ty_63::WQ_MAX_ACTIVE;
pub const WQ_MAX_UNBOUND_PER_CPU: _bindgen_ty_63 =
    _bindgen_ty_63::WQ_FREEZABLE;
pub const WQ_DFL_ACTIVE: _bindgen_ty_63 = _bindgen_ty_63::WQ_DFL_ACTIVE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_63 {
    WQ_UNBOUND = 2,
    WQ_FREEZABLE = 4,
    WQ_MEM_RECLAIM = 8,
    WQ_HIGHPRI = 16,
    WQ_CPU_INTENSIVE = 32,
    WQ_SYSFS = 64,
    WQ_POWER_EFFICIENT = 128,
    __WQ_DRAINING = 65536,
    __WQ_ORDERED = 131072,
    WQ_MAX_ACTIVE = 512,
    WQ_DFL_ACTIVE = 256,
}
extern "C" {
    #[link_name = "system_wq"]
    pub static mut system_wq: *mut workqueue_struct;
}
extern "C" {
    #[link_name = "system_highpri_wq"]
    pub static mut system_highpri_wq: *mut workqueue_struct;
}
extern "C" {
    #[link_name = "system_long_wq"]
    pub static mut system_long_wq: *mut workqueue_struct;
}
extern "C" {
    #[link_name = "system_unbound_wq"]
    pub static mut system_unbound_wq: *mut workqueue_struct;
}
extern "C" {
    #[link_name = "system_freezable_wq"]
    pub static mut system_freezable_wq: *mut workqueue_struct;
}
extern "C" {
    #[link_name = "system_power_efficient_wq"]
    pub static mut system_power_efficient_wq: *mut workqueue_struct;
}
extern "C" {
    #[link_name = "system_freezable_power_efficient_wq"]
    pub static mut system_freezable_power_efficient_wq: *mut workqueue_struct;
}
extern "C" {
    pub fn __alloc_workqueue_key(fmt: *const ::std::os::raw::c_char,
                                 flags: ::std::os::raw::c_uint,
                                 max_active: ::std::os::raw::c_int,
                                 key: *mut lock_class_key,
                                 lock_name:
                                     *const ::std::os::raw::c_char, ...)
     -> *mut workqueue_struct;
}
extern "C" {
    pub fn destroy_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn alloc_workqueue_attrs(gfp_mask: gfp_t) -> *mut workqueue_attrs;
}
extern "C" {
    pub fn free_workqueue_attrs(attrs: *mut workqueue_attrs);
}
extern "C" {
    pub fn apply_workqueue_attrs(wq: *mut workqueue_struct,
                                 attrs: *const workqueue_attrs)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn workqueue_set_unbound_cpumask(cpumask: *mut cpumask)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn queue_work_on(cpu: ::std::os::raw::c_int,
                         wq: *mut workqueue_struct, work: *mut work_struct)
     -> bool_;
}
extern "C" {
    pub fn queue_delayed_work_on(cpu: ::std::os::raw::c_int,
                                 wq: *mut workqueue_struct,
                                 work: *mut delayed_work,
                                 delay: ::std::os::raw::c_ulong) -> bool_;
}
extern "C" {
    pub fn mod_delayed_work_on(cpu: ::std::os::raw::c_int,
                               wq: *mut workqueue_struct,
                               dwork: *mut delayed_work,
                               delay: ::std::os::raw::c_ulong) -> bool_;
}
extern "C" {
    pub fn flush_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn drain_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn schedule_on_each_cpu(func: work_func_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execute_in_process_context(fn_: work_func_t,
                                      arg1: *mut execute_work)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flush_work(work: *mut work_struct) -> bool_;
}
extern "C" {
    pub fn cancel_work_sync(work: *mut work_struct) -> bool_;
}
extern "C" {
    pub fn flush_delayed_work(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn cancel_delayed_work(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn cancel_delayed_work_sync(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn workqueue_set_max_active(wq: *mut workqueue_struct,
                                    max_active: ::std::os::raw::c_int);
}
extern "C" {
    pub fn current_is_workqueue_rescuer() -> bool_;
}
extern "C" {
    pub fn workqueue_congested(cpu: ::std::os::raw::c_int,
                               wq: *mut workqueue_struct) -> bool_;
}
extern "C" {
    pub fn work_busy(work: *mut work_struct) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn set_worker_desc(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn print_worker_info(log_lvl: *const ::std::os::raw::c_char,
                             task: *mut task_struct);
}
extern "C" {
    pub fn show_workqueue_state();
}
extern "C" {
    pub fn work_on_cpu(cpu: ::std::os::raw::c_int,
                       fn_:
                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::std::os::raw::c_void)
                                                     ->
                                                         ::std::os::raw::c_long>,
                       arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn freeze_workqueues_begin();
}
extern "C" {
    pub fn freeze_workqueues_busy() -> bool_;
}
extern "C" {
    pub fn thaw_workqueues();
}
extern "C" {
    pub fn workqueue_sysfs_register(wq: *mut workqueue_struct)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct srcu_struct_array {
    pub c: [::std::os::raw::c_ulong; 2usize],
    pub seq: [::std::os::raw::c_ulong; 2usize],
}
#[test]
fn bindgen_test_layout_srcu_struct_array() {
    assert_eq!(::std::mem::size_of::<srcu_struct_array>() , 32usize , concat !
               ( "Size of: " , stringify ! ( srcu_struct_array ) ));
    assert_eq! (::std::mem::align_of::<srcu_struct_array>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( srcu_struct_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const srcu_struct_array ) ) . c as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( srcu_struct_array ) ,
                "::" , stringify ! ( c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const srcu_struct_array ) ) . seq as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( srcu_struct_array ) ,
                "::" , stringify ! ( seq ) ));
}
impl Clone for srcu_struct_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rcu_batch {
    pub head: *mut callback_head,
    pub tail: *mut *mut callback_head,
}
#[test]
fn bindgen_test_layout_rcu_batch() {
    assert_eq!(::std::mem::size_of::<rcu_batch>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rcu_batch ) ));
    assert_eq! (::std::mem::align_of::<rcu_batch>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rcu_batch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rcu_batch ) ) . head as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rcu_batch ) , "::" ,
                stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rcu_batch ) ) . tail as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rcu_batch ) , "::" ,
                stringify ! ( tail ) ));
}
impl Clone for rcu_batch {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct srcu_struct {
    pub completed: ::std::os::raw::c_ulong,
    pub per_cpu_ref: *mut srcu_struct_array,
    pub queue_lock: spinlock_t,
    pub running: bool_,
    pub batch_queue: rcu_batch,
    pub batch_check0: rcu_batch,
    pub batch_check1: rcu_batch,
    pub batch_done: rcu_batch,
    pub work: delayed_work,
}
#[test]
fn bindgen_test_layout_srcu_struct() {
    assert_eq!(::std::mem::size_of::<srcu_struct>() , 216usize , concat ! (
               "Size of: " , stringify ! ( srcu_struct ) ));
    assert_eq! (::std::mem::align_of::<srcu_struct>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( srcu_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const srcu_struct ) ) . completed as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( srcu_struct ) , "::" ,
                stringify ! ( completed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const srcu_struct ) ) . per_cpu_ref as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( srcu_struct ) , "::" ,
                stringify ! ( per_cpu_ref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const srcu_struct ) ) . queue_lock as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( srcu_struct ) , "::" ,
                stringify ! ( queue_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const srcu_struct ) ) . running as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( srcu_struct ) , "::" ,
                stringify ! ( running ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const srcu_struct ) ) . batch_queue as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( srcu_struct ) , "::" ,
                stringify ! ( batch_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const srcu_struct ) ) . batch_check0 as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( srcu_struct ) , "::" ,
                stringify ! ( batch_check0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const srcu_struct ) ) . batch_check1 as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( srcu_struct ) , "::" ,
                stringify ! ( batch_check1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const srcu_struct ) ) . batch_done as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( srcu_struct ) , "::" ,
                stringify ! ( batch_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const srcu_struct ) ) . work as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( srcu_struct ) , "::" ,
                stringify ! ( work ) ));
}
impl Clone for srcu_struct {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn init_srcu_struct(sp: *mut srcu_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn process_srcu(work: *mut work_struct);
}
extern "C" {
    /// call_srcu() - Queue a callback for invocation after an SRCU grace period
/// @sp: srcu_struct in queue the callback
/// @head: structure to be used for queueing the SRCU callback.
/// @func: function to be invoked after the SRCU grace period
///
/// The callback function will be invoked some time after a full SRCU
/// grace period elapses, in other words after all pre-existing SRCU
/// read-side critical sections have completed.  However, the callback
/// function might well execute concurrently with other SRCU read-side
/// critical sections that started after call_srcu() was invoked.  SRCU
/// read-side critical sections are delimited by srcu_read_lock() and
/// srcu_read_unlock(), and may be nested.
///
/// The callback will be invoked from process context, but must nevertheless
/// be fast and must not block.
    pub fn call_srcu(sp: *mut srcu_struct, head: *mut callback_head,
                     func:
                         ::std::option::Option<unsafe extern "C" fn(head:
                                                                        *mut callback_head)>);
}
extern "C" {
    pub fn cleanup_srcu_struct(sp: *mut srcu_struct);
}
extern "C" {
    pub fn __srcu_read_lock(sp: *mut srcu_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __srcu_read_unlock(sp: *mut srcu_struct,
                              idx: ::std::os::raw::c_int);
}
extern "C" {
    pub fn synchronize_srcu(sp: *mut srcu_struct);
}
extern "C" {
    pub fn synchronize_srcu_expedited(sp: *mut srcu_struct);
}
extern "C" {
    pub fn srcu_batches_completed(sp: *mut srcu_struct)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn srcu_barrier(sp: *mut srcu_struct);
}
pub type notifier_fn_t =
    ::std::option::Option<unsafe extern "C" fn(nb: *mut notifier_block,
                                               action:
                                                   ::std::os::raw::c_ulong,
                                               data:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct blocking_notifier_head {
    pub rwsem: rw_semaphore,
    pub head: *mut notifier_block,
}
#[test]
fn bindgen_test_layout_blocking_notifier_head() {
    assert_eq!(::std::mem::size_of::<blocking_notifier_head>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( blocking_notifier_head )
               ));
    assert_eq! (::std::mem::align_of::<blocking_notifier_head>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( blocking_notifier_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blocking_notifier_head ) ) . rwsem as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( blocking_notifier_head
                ) , "::" , stringify ! ( rwsem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blocking_notifier_head ) ) . head as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( blocking_notifier_head
                ) , "::" , stringify ! ( head ) ));
}
impl Clone for blocking_notifier_head {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct raw_notifier_head {
    pub head: *mut notifier_block,
}
#[test]
fn bindgen_test_layout_raw_notifier_head() {
    assert_eq!(::std::mem::size_of::<raw_notifier_head>() , 8usize , concat !
               ( "Size of: " , stringify ! ( raw_notifier_head ) ));
    assert_eq! (::std::mem::align_of::<raw_notifier_head>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( raw_notifier_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const raw_notifier_head ) ) . head as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( raw_notifier_head ) ,
                "::" , stringify ! ( head ) ));
}
impl Clone for raw_notifier_head {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct srcu_notifier_head {
    pub mutex: mutex,
    pub srcu: srcu_struct,
    pub head: *mut notifier_block,
}
#[test]
fn bindgen_test_layout_srcu_notifier_head() {
    assert_eq!(::std::mem::size_of::<srcu_notifier_head>() , 264usize , concat
               ! ( "Size of: " , stringify ! ( srcu_notifier_head ) ));
    assert_eq! (::std::mem::align_of::<srcu_notifier_head>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( srcu_notifier_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const srcu_notifier_head ) ) . mutex as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( srcu_notifier_head ) ,
                "::" , stringify ! ( mutex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const srcu_notifier_head ) ) . srcu as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( srcu_notifier_head ) ,
                "::" , stringify ! ( srcu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const srcu_notifier_head ) ) . head as * const
                _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( srcu_notifier_head ) ,
                "::" , stringify ! ( head ) ));
}
impl Clone for srcu_notifier_head {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn srcu_init_notifier_head(nh: *mut srcu_notifier_head);
}
extern "C" {
    pub fn atomic_notifier_chain_register(nh: *mut atomic_notifier_head,
                                          nb: *mut notifier_block)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_register(nh: *mut blocking_notifier_head,
                                            nb: *mut notifier_block)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raw_notifier_chain_register(nh: *mut raw_notifier_head,
                                       nb: *mut notifier_block)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srcu_notifier_chain_register(nh: *mut srcu_notifier_head,
                                        nb: *mut notifier_block)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_cond_register(nh:
                                                     *mut blocking_notifier_head,
                                                 nb: *mut notifier_block)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_notifier_chain_unregister(nh: *mut atomic_notifier_head,
                                            nb: *mut notifier_block)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_unregister(nh: *mut blocking_notifier_head,
                                              nb: *mut notifier_block)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raw_notifier_chain_unregister(nh: *mut raw_notifier_head,
                                         nb: *mut notifier_block)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srcu_notifier_chain_unregister(nh: *mut srcu_notifier_head,
                                          nb: *mut notifier_block)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_notifier_call_chain(nh: *mut atomic_notifier_head,
                                      val: ::std::os::raw::c_ulong,
                                      v: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __atomic_notifier_call_chain(nh: *mut atomic_notifier_head,
                                        val: ::std::os::raw::c_ulong,
                                        v: *mut ::std::os::raw::c_void,
                                        nr_to_call: ::std::os::raw::c_int,
                                        nr_calls: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blocking_notifier_call_chain(nh: *mut blocking_notifier_head,
                                        val: ::std::os::raw::c_ulong,
                                        v: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __blocking_notifier_call_chain(nh: *mut blocking_notifier_head,
                                          val: ::std::os::raw::c_ulong,
                                          v: *mut ::std::os::raw::c_void,
                                          nr_to_call: ::std::os::raw::c_int,
                                          nr_calls:
                                              *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raw_notifier_call_chain(nh: *mut raw_notifier_head,
                                   val: ::std::os::raw::c_ulong,
                                   v: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __raw_notifier_call_chain(nh: *mut raw_notifier_head,
                                     val: ::std::os::raw::c_ulong,
                                     v: *mut ::std::os::raw::c_void,
                                     nr_to_call: ::std::os::raw::c_int,
                                     nr_calls: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srcu_notifier_call_chain(nh: *mut srcu_notifier_head,
                                    val: ::std::os::raw::c_ulong,
                                    v: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __srcu_notifier_call_chain(nh: *mut srcu_notifier_head,
                                      val: ::std::os::raw::c_ulong,
                                      v: *mut ::std::os::raw::c_void,
                                      nr_to_call: ::std::os::raw::c_int,
                                      nr_calls: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "reboot_notifier_list"]
    pub static mut reboot_notifier_list: blocking_notifier_head;
}
#[repr(C)]
#[derive(Copy)]
pub struct mem_section {
    pub section_mem_map: ::std::os::raw::c_ulong,
    pub pageblock_flags: *mut ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_mem_section() {
    assert_eq!(::std::mem::size_of::<mem_section>() , 16usize , concat ! (
               "Size of: " , stringify ! ( mem_section ) ));
    assert_eq! (::std::mem::align_of::<mem_section>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mem_section ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mem_section ) ) . section_mem_map as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mem_section ) , "::" ,
                stringify ! ( section_mem_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mem_section ) ) . pageblock_flags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mem_section ) , "::" ,
                stringify ! ( pageblock_flags ) ));
}
impl Clone for mem_section {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memory_block {
    _unused: [u8; 0],
}
pub const MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE: _bindgen_ty_64 =
    _bindgen_ty_64::MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE;
pub const SECTION_INFO: _bindgen_ty_64 =
    _bindgen_ty_64::MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE;
pub const MIX_SECTION_INFO: _bindgen_ty_64 = _bindgen_ty_64::MIX_SECTION_INFO;
pub const NODE_INFO: _bindgen_ty_64 = _bindgen_ty_64::NODE_INFO;
pub const MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE: _bindgen_ty_64 =
    _bindgen_ty_64::NODE_INFO;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_64 {
    MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE = 12,
    MIX_SECTION_INFO = 13,
    NODE_INFO = 14,
}
pub const MMOP_OFFLINE: _bindgen_ty_65 = _bindgen_ty_65::MMOP_OFFLINE;
pub const MMOP_ONLINE_KEEP: _bindgen_ty_65 = _bindgen_ty_65::MMOP_ONLINE_KEEP;
pub const MMOP_ONLINE_KERNEL: _bindgen_ty_65 =
    _bindgen_ty_65::MMOP_ONLINE_KERNEL;
pub const MMOP_ONLINE_MOVABLE: _bindgen_ty_65 =
    _bindgen_ty_65::MMOP_ONLINE_MOVABLE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_65 {
    MMOP_OFFLINE = -1,
    MMOP_ONLINE_KEEP = 0,
    MMOP_ONLINE_KERNEL = 1,
    MMOP_ONLINE_MOVABLE = 2,
}
extern "C" {
    pub fn zone_grow_free_lists(zone: *mut zone,
                                new_nr_pages: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zone_grow_waitqueues(zone: *mut zone,
                                nr_pages: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_one_highpage(page: *mut page, pfn: ::std::os::raw::c_int,
                            bad_ppro: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn online_pages(arg1: ::std::os::raw::c_ulong,
                        arg2: ::std::os::raw::c_ulong,
                        arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn test_pages_in_a_zone(arg1: ::std::os::raw::c_ulong,
                                arg2: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __offline_isolated_pages(arg1: ::std::os::raw::c_ulong,
                                    arg2: ::std::os::raw::c_ulong);
}
pub type online_page_callback_t =
    ::std::option::Option<unsafe extern "C" fn(page: *mut page)>;
extern "C" {
    pub fn set_online_page_callback(callback: online_page_callback_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn restore_online_page_callback(callback: online_page_callback_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __online_page_set_limits(page: *mut page);
}
extern "C" {
    pub fn __online_page_increment_counters(page: *mut page);
}
extern "C" {
    pub fn __online_page_free(page: *mut page);
}
extern "C" {
    pub fn try_online_node(nid: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_pageblock_removable_nolock(page: *mut page) -> bool_;
}
extern "C" {
    pub fn arch_remove_memory(start: u64, size: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __remove_pages(zone: *mut zone, start_pfn: ::std::os::raw::c_ulong,
                          nr_pages: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __add_pages(nid: ::std::os::raw::c_int, zone: *mut zone,
                       start_pfn: ::std::os::raw::c_ulong,
                       nr_pages: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memory_add_physaddr_to_nid(start: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "node_data"]
    pub static mut node_data: [*mut pg_data_t; 0usize];
}
extern "C" {
    pub fn register_page_bootmem_info_node(pgdat: *mut pglist_data);
}
extern "C" {
    pub fn put_page_bootmem(page: *mut page);
}
extern "C" {
    pub fn get_page_bootmem(ingo: ::std::os::raw::c_ulong, page: *mut page,
                            type_: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn get_online_mems();
}
extern "C" {
    pub fn put_online_mems();
}
extern "C" {
    pub fn mem_hotplug_begin();
}
extern "C" {
    pub fn mem_hotplug_done();
}
extern "C" {
    pub fn is_mem_section_removable(pfn: ::std::os::raw::c_ulong,
                                    nr_pages: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn try_offline_node(nid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn offline_pages(start_pfn: ::std::os::raw::c_ulong,
                         nr_pages: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove_memory(nid: ::std::os::raw::c_int, start: u64, size: u64);
}
extern "C" {
    pub fn walk_memory_range(start_pfn: ::std::os::raw::c_ulong,
                             end_pfn: ::std::os::raw::c_ulong,
                             arg: *mut ::std::os::raw::c_void,
                             func:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                *mut memory_block,
                                                                            arg2:
                                                                                *mut ::std::os::raw::c_void)
                                                           ->
                                                               ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_memory(nid: ::std::os::raw::c_int, start: u64, size: u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zone_for_memory(nid: ::std::os::raw::c_int, start: u64, size: u64,
                           zone_default: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_add_memory(nid: ::std::os::raw::c_int, start: u64, size: u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_memblock_offlined(mem: *mut memory_block) -> bool_;
}
extern "C" {
    pub fn sparse_add_one_section(zone: *mut zone,
                                  start_pfn: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sparse_remove_one_section(zone: *mut zone, ms: *mut mem_section);
}
extern "C" {
    pub fn sparse_decode_mem_map(coded_mem_map: ::std::os::raw::c_ulong,
                                 pnum: ::std::os::raw::c_ulong) -> *mut page;
}
extern "C" {
    #[link_name = "zonelists_mutex"]
    pub static mut zonelists_mutex: mutex;
}
extern "C" {
    pub fn build_all_zonelists(pgdat: *mut pg_data_t, zone: *mut zone);
}
extern "C" {
    pub fn wakeup_kswapd(zone: *mut zone, order: ::std::os::raw::c_int,
                         classzone_idx: zone_type);
}
extern "C" {
    pub fn zone_watermark_ok(z: *mut zone, order: ::std::os::raw::c_uint,
                             mark: ::std::os::raw::c_ulong,
                             classzone_idx: ::std::os::raw::c_int,
                             alloc_flags: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn zone_watermark_ok_safe(z: *mut zone, order: ::std::os::raw::c_uint,
                                  mark: ::std::os::raw::c_ulong,
                                  classzone_idx: ::std::os::raw::c_int,
                                  alloc_flags: ::std::os::raw::c_int)
     -> bool_;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum memmap_context { MEMMAP_EARLY = 0, MEMMAP_HOTPLUG = 1, }
extern "C" {
    pub fn init_currently_empty_zone(zone: *mut zone,
                                     start_pfn: ::std::os::raw::c_ulong,
                                     size: ::std::os::raw::c_ulong,
                                     context: memmap_context)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lruvec_init(lruvec: *mut lruvec);
}
extern "C" {
    pub fn memory_present(nid: ::std::os::raw::c_int,
                          start: ::std::os::raw::c_ulong,
                          end: ::std::os::raw::c_ulong);
}
extern "C" {
    #[link_name = "movable_zone"]
    pub static mut movable_zone: ::std::os::raw::c_int;
}
extern "C" {
    pub fn min_free_kbytes_sysctl_handler(arg1: *mut ctl_table,
                                          arg2: ::std::os::raw::c_int,
                                          arg3: *mut ::std::os::raw::c_void,
                                          arg4: *mut usize, arg5: *mut loff_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sysctl_lowmem_reserve_ratio"]
    pub static mut sysctl_lowmem_reserve_ratio:
               [::std::os::raw::c_int; 3usize];
}
extern "C" {
    pub fn lowmem_reserve_ratio_sysctl_handler(arg1: *mut ctl_table,
                                               arg2: ::std::os::raw::c_int,
                                               arg3:
                                                   *mut ::std::os::raw::c_void,
                                               arg4: *mut usize,
                                               arg5: *mut loff_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn percpu_pagelist_fraction_sysctl_handler(arg1: *mut ctl_table,
                                                   arg2:
                                                       ::std::os::raw::c_int,
                                                   arg3:
                                                       *mut ::std::os::raw::c_void,
                                                   arg4: *mut usize,
                                                   arg5: *mut loff_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sysctl_min_unmapped_ratio_sysctl_handler(arg1: *mut ctl_table,
                                                    arg2:
                                                        ::std::os::raw::c_int,
                                                    arg3:
                                                        *mut ::std::os::raw::c_void,
                                                    arg4: *mut usize,
                                                    arg5: *mut loff_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sysctl_min_slab_ratio_sysctl_handler(arg1: *mut ctl_table,
                                                arg2: ::std::os::raw::c_int,
                                                arg3:
                                                    *mut ::std::os::raw::c_void,
                                                arg4: *mut usize,
                                                arg5: *mut loff_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_zonelist_order_handler(arg1: *mut ctl_table,
                                       arg2: ::std::os::raw::c_int,
                                       arg3: *mut ::std::os::raw::c_void,
                                       arg4: *mut usize, arg5: *mut loff_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "numa_zonelist_order"]
    pub static mut numa_zonelist_order: [::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct mpf_intel {
    pub signature: [::std::os::raw::c_char; 4usize],
    pub physptr: ::std::os::raw::c_uint,
    pub length: ::std::os::raw::c_uchar,
    pub specification: ::std::os::raw::c_uchar,
    pub checksum: ::std::os::raw::c_uchar,
    pub feature1: ::std::os::raw::c_uchar,
    pub feature2: ::std::os::raw::c_uchar,
    pub feature3: ::std::os::raw::c_uchar,
    pub feature4: ::std::os::raw::c_uchar,
    pub feature5: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_mpf_intel() {
    assert_eq!(::std::mem::size_of::<mpf_intel>() , 16usize , concat ! (
               "Size of: " , stringify ! ( mpf_intel ) ));
    assert_eq! (::std::mem::align_of::<mpf_intel>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( mpf_intel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpf_intel ) ) . signature as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpf_intel ) , "::" ,
                stringify ! ( signature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpf_intel ) ) . physptr as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mpf_intel ) , "::" ,
                stringify ! ( physptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpf_intel ) ) . length as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mpf_intel ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpf_intel ) ) . specification as * const
                _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( mpf_intel ) , "::" ,
                stringify ! ( specification ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpf_intel ) ) . checksum as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( mpf_intel ) , "::" ,
                stringify ! ( checksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpf_intel ) ) . feature1 as * const _ as
                usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( mpf_intel ) , "::" ,
                stringify ! ( feature1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpf_intel ) ) . feature2 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( mpf_intel ) , "::" ,
                stringify ! ( feature2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpf_intel ) ) . feature3 as * const _ as
                usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( mpf_intel ) , "::" ,
                stringify ! ( feature3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpf_intel ) ) . feature4 as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( mpf_intel ) , "::" ,
                stringify ! ( feature4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpf_intel ) ) . feature5 as * const _ as
                usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( mpf_intel ) , "::" ,
                stringify ! ( feature5 ) ));
}
impl Clone for mpf_intel {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct mpc_table {
    pub signature: [::std::os::raw::c_char; 4usize],
    pub length: ::std::os::raw::c_ushort,
    pub spec: ::std::os::raw::c_char,
    pub checksum: ::std::os::raw::c_char,
    pub oem: [::std::os::raw::c_char; 8usize],
    pub productid: [::std::os::raw::c_char; 12usize],
    pub oemptr: ::std::os::raw::c_uint,
    pub oemsize: ::std::os::raw::c_ushort,
    pub oemcount: ::std::os::raw::c_ushort,
    pub lapic: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mpc_table() {
    assert_eq!(::std::mem::size_of::<mpc_table>() , 44usize , concat ! (
               "Size of: " , stringify ! ( mpc_table ) ));
    assert_eq! (::std::mem::align_of::<mpc_table>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( mpc_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_table ) ) . signature as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_table ) , "::" ,
                stringify ! ( signature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_table ) ) . length as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_table ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_table ) ) . spec as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_table ) , "::" ,
                stringify ! ( spec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_table ) ) . checksum as * const _ as
                usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_table ) , "::" ,
                stringify ! ( checksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_table ) ) . oem as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_table ) , "::" ,
                stringify ! ( oem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_table ) ) . productid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_table ) , "::" ,
                stringify ! ( productid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_table ) ) . oemptr as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_table ) , "::" ,
                stringify ! ( oemptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_table ) ) . oemsize as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_table ) , "::" ,
                stringify ! ( oemsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_table ) ) . oemcount as * const _ as
                usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_table ) , "::" ,
                stringify ! ( oemcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_table ) ) . lapic as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_table ) , "::" ,
                stringify ! ( lapic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_table ) ) . reserved as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_table ) , "::" ,
                stringify ! ( reserved ) ));
}
impl Clone for mpc_table {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct mpc_cpu {
    pub type_: ::std::os::raw::c_uchar,
    pub apicid: ::std::os::raw::c_uchar,
    pub apicver: ::std::os::raw::c_uchar,
    pub cpuflag: ::std::os::raw::c_uchar,
    pub cpufeature: ::std::os::raw::c_uint,
    pub featureflag: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_mpc_cpu() {
    assert_eq!(::std::mem::size_of::<mpc_cpu>() , 20usize , concat ! (
               "Size of: " , stringify ! ( mpc_cpu ) ));
    assert_eq! (::std::mem::align_of::<mpc_cpu>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( mpc_cpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_cpu ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_cpu ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_cpu ) ) . apicid as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_cpu ) , "::" ,
                stringify ! ( apicid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_cpu ) ) . apicver as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_cpu ) , "::" ,
                stringify ! ( apicver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_cpu ) ) . cpuflag as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_cpu ) , "::" ,
                stringify ! ( cpuflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_cpu ) ) . cpufeature as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_cpu ) , "::" ,
                stringify ! ( cpufeature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_cpu ) ) . featureflag as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_cpu ) , "::" ,
                stringify ! ( featureflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_cpu ) ) . reserved as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_cpu ) , "::" ,
                stringify ! ( reserved ) ));
}
impl Clone for mpc_cpu {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct mpc_bus {
    pub type_: ::std::os::raw::c_uchar,
    pub busid: ::std::os::raw::c_uchar,
    pub bustype: [::std::os::raw::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_mpc_bus() {
    assert_eq!(::std::mem::size_of::<mpc_bus>() , 8usize , concat ! (
               "Size of: " , stringify ! ( mpc_bus ) ));
    assert_eq! (::std::mem::align_of::<mpc_bus>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( mpc_bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_bus ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_bus ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_bus ) ) . busid as * const _ as usize
                } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_bus ) , "::" ,
                stringify ! ( busid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_bus ) ) . bustype as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_bus ) , "::" ,
                stringify ! ( bustype ) ));
}
impl Clone for mpc_bus {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct mpc_ioapic {
    pub type_: ::std::os::raw::c_uchar,
    pub apicid: ::std::os::raw::c_uchar,
    pub apicver: ::std::os::raw::c_uchar,
    pub flags: ::std::os::raw::c_uchar,
    pub apicaddr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mpc_ioapic() {
    assert_eq!(::std::mem::size_of::<mpc_ioapic>() , 8usize , concat ! (
               "Size of: " , stringify ! ( mpc_ioapic ) ));
    assert_eq! (::std::mem::align_of::<mpc_ioapic>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( mpc_ioapic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_ioapic ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_ioapic ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_ioapic ) ) . apicid as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_ioapic ) , "::" ,
                stringify ! ( apicid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_ioapic ) ) . apicver as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_ioapic ) , "::" ,
                stringify ! ( apicver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_ioapic ) ) . flags as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_ioapic ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_ioapic ) ) . apicaddr as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_ioapic ) , "::" ,
                stringify ! ( apicaddr ) ));
}
impl Clone for mpc_ioapic {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct mpc_intsrc {
    pub type_: ::std::os::raw::c_uchar,
    pub irqtype: ::std::os::raw::c_uchar,
    pub irqflag: ::std::os::raw::c_ushort,
    pub srcbus: ::std::os::raw::c_uchar,
    pub srcbusirq: ::std::os::raw::c_uchar,
    pub dstapic: ::std::os::raw::c_uchar,
    pub dstirq: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_mpc_intsrc() {
    assert_eq!(::std::mem::size_of::<mpc_intsrc>() , 8usize , concat ! (
               "Size of: " , stringify ! ( mpc_intsrc ) ));
    assert_eq! (::std::mem::align_of::<mpc_intsrc>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( mpc_intsrc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_intsrc ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_intsrc ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_intsrc ) ) . irqtype as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_intsrc ) , "::" ,
                stringify ! ( irqtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_intsrc ) ) . irqflag as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_intsrc ) , "::" ,
                stringify ! ( irqflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_intsrc ) ) . srcbus as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_intsrc ) , "::" ,
                stringify ! ( srcbus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_intsrc ) ) . srcbusirq as * const _
                as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_intsrc ) , "::" ,
                stringify ! ( srcbusirq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_intsrc ) ) . dstapic as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_intsrc ) , "::" ,
                stringify ! ( dstapic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_intsrc ) ) . dstirq as * const _ as
                usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_intsrc ) , "::" ,
                stringify ! ( dstirq ) ));
}
impl Clone for mpc_intsrc {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mp_irq_source_types {
    mp_INT = 0,
    mp_NMI = 1,
    mp_SMI = 2,
    mp_ExtINT = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct mpc_lintsrc {
    pub type_: ::std::os::raw::c_uchar,
    pub irqtype: ::std::os::raw::c_uchar,
    pub irqflag: ::std::os::raw::c_ushort,
    pub srcbusid: ::std::os::raw::c_uchar,
    pub srcbusirq: ::std::os::raw::c_uchar,
    pub destapic: ::std::os::raw::c_uchar,
    pub destapiclint: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_mpc_lintsrc() {
    assert_eq!(::std::mem::size_of::<mpc_lintsrc>() , 8usize , concat ! (
               "Size of: " , stringify ! ( mpc_lintsrc ) ));
    assert_eq! (::std::mem::align_of::<mpc_lintsrc>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( mpc_lintsrc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_lintsrc ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_lintsrc ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_lintsrc ) ) . irqtype as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_lintsrc ) , "::" ,
                stringify ! ( irqtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_lintsrc ) ) . irqflag as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_lintsrc ) , "::" ,
                stringify ! ( irqflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_lintsrc ) ) . srcbusid as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_lintsrc ) , "::" ,
                stringify ! ( srcbusid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_lintsrc ) ) . srcbusirq as * const _
                as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_lintsrc ) , "::" ,
                stringify ! ( srcbusirq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_lintsrc ) ) . destapic as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_lintsrc ) , "::" ,
                stringify ! ( destapic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_lintsrc ) ) . destapiclint as * const
                _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_lintsrc ) , "::" ,
                stringify ! ( destapiclint ) ));
}
impl Clone for mpc_lintsrc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct mpc_oemtable {
    pub signature: [::std::os::raw::c_char; 4usize],
    pub length: ::std::os::raw::c_ushort,
    pub rev: ::std::os::raw::c_char,
    pub checksum: ::std::os::raw::c_char,
    pub mpc: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_mpc_oemtable() {
    assert_eq!(::std::mem::size_of::<mpc_oemtable>() , 16usize , concat ! (
               "Size of: " , stringify ! ( mpc_oemtable ) ));
    assert_eq! (::std::mem::align_of::<mpc_oemtable>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( mpc_oemtable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_oemtable ) ) . signature as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_oemtable ) , "::" ,
                stringify ! ( signature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_oemtable ) ) . length as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_oemtable ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_oemtable ) ) . rev as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_oemtable ) , "::" ,
                stringify ! ( rev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_oemtable ) ) . checksum as * const _
                as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_oemtable ) , "::" ,
                stringify ! ( checksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpc_oemtable ) ) . mpc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mpc_oemtable ) , "::" ,
                stringify ! ( mpc ) ));
}
impl Clone for mpc_oemtable {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mp_bustype { MP_BUS_ISA = 1, MP_BUS_EISA = 2, MP_BUS_PCI = 3, }
#[repr(C, packed)]
#[derive(Copy)]
pub struct screen_info {
    pub orig_x: __u8,
    pub orig_y: __u8,
    pub ext_mem_k: __u16,
    pub orig_video_page: __u16,
    pub orig_video_mode: __u8,
    pub orig_video_cols: __u8,
    pub flags: __u8,
    pub unused2: __u8,
    pub orig_video_ega_bx: __u16,
    pub unused3: __u16,
    pub orig_video_lines: __u8,
    pub orig_video_isVGA: __u8,
    pub orig_video_points: __u16,
    pub lfb_width: __u16,
    pub lfb_height: __u16,
    pub lfb_depth: __u16,
    pub lfb_base: __u32,
    pub lfb_size: __u32,
    pub cl_magic: __u16,
    pub cl_offset: __u16,
    pub lfb_linelength: __u16,
    pub red_size: __u8,
    pub red_pos: __u8,
    pub green_size: __u8,
    pub green_pos: __u8,
    pub blue_size: __u8,
    pub blue_pos: __u8,
    pub rsvd_size: __u8,
    pub rsvd_pos: __u8,
    pub vesapm_seg: __u16,
    pub vesapm_off: __u16,
    pub pages: __u16,
    pub vesa_attributes: __u16,
    pub capabilities: __u32,
    pub _reserved: [__u8; 6usize],
}
#[test]
fn bindgen_test_layout_screen_info() {
    assert_eq!(::std::mem::size_of::<screen_info>() , 64usize , concat ! (
               "Size of: " , stringify ! ( screen_info ) ));
    assert_eq! (::std::mem::align_of::<screen_info>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( screen_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . orig_x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( orig_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . orig_y as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( orig_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . ext_mem_k as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( ext_mem_k ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . orig_video_page as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( orig_video_page ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . orig_video_mode as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( orig_video_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . orig_video_cols as *
                const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( orig_video_cols ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . unused2 as * const _ as
                usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( unused2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . orig_video_ega_bx as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( orig_video_ega_bx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . unused3 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( unused3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . orig_video_lines as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( orig_video_lines ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . orig_video_isVGA as *
                const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( orig_video_isVGA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . orig_video_points as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( orig_video_points ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . lfb_width as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( lfb_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . lfb_height as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( lfb_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . lfb_depth as * const _
                as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( lfb_depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . lfb_base as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( lfb_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . lfb_size as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( lfb_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . cl_magic as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( cl_magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . cl_offset as * const _
                as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( cl_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . lfb_linelength as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( lfb_linelength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . red_size as * const _
                as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( red_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . red_pos as * const _ as
                usize } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( red_pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . green_size as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( green_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . green_pos as * const _
                as usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( green_pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . blue_size as * const _
                as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( blue_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . blue_pos as * const _
                as usize } , 43usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( blue_pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . rsvd_size as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( rsvd_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . rsvd_pos as * const _
                as usize } , 45usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( rsvd_pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . vesapm_seg as * const _
                as usize } , 46usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( vesapm_seg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . vesapm_off as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( vesapm_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . pages as * const _ as
                usize } , 50usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . vesa_attributes as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( vesa_attributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . capabilities as * const
                _ as usize } , 54usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( capabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const screen_info ) ) . _reserved as * const _
                as usize } , 58usize , concat ! (
                "Alignment of field: " , stringify ! ( screen_info ) , "::" ,
                stringify ! ( _reserved ) ));
}
impl Clone for screen_info {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "screen_info"]
    pub static mut screen_info: screen_info;
}
pub type apm_event_t = ::std::os::raw::c_ushort;
pub type apm_eventinfo_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Copy)]
pub struct apm_bios_info {
    pub version: __u16,
    pub cseg: __u16,
    pub offset: __u32,
    pub cseg_16: __u16,
    pub dseg: __u16,
    pub flags: __u16,
    pub cseg_len: __u16,
    pub cseg_16_len: __u16,
    pub dseg_len: __u16,
}
#[test]
fn bindgen_test_layout_apm_bios_info() {
    assert_eq!(::std::mem::size_of::<apm_bios_info>() , 20usize , concat ! (
               "Size of: " , stringify ! ( apm_bios_info ) ));
    assert_eq! (::std::mem::align_of::<apm_bios_info>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( apm_bios_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_bios_info ) ) . version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_bios_info ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_bios_info ) ) . cseg as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_bios_info ) , "::"
                , stringify ! ( cseg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_bios_info ) ) . offset as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_bios_info ) , "::"
                , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_bios_info ) ) . cseg_16 as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_bios_info ) , "::"
                , stringify ! ( cseg_16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_bios_info ) ) . dseg as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_bios_info ) , "::"
                , stringify ! ( dseg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_bios_info ) ) . flags as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_bios_info ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_bios_info ) ) . cseg_len as * const _
                as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_bios_info ) , "::"
                , stringify ! ( cseg_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_bios_info ) ) . cseg_16_len as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_bios_info ) , "::"
                , stringify ! ( cseg_16_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_bios_info ) ) . dseg_len as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_bios_info ) , "::"
                , stringify ! ( dseg_len ) ));
}
impl Clone for apm_bios_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct apm_info {
    pub bios: apm_bios_info,
    pub connection_version: ::std::os::raw::c_ushort,
    pub get_power_status_broken: ::std::os::raw::c_int,
    pub get_power_status_swabinminutes: ::std::os::raw::c_int,
    pub allow_ints: ::std::os::raw::c_int,
    pub forbid_idle: ::std::os::raw::c_int,
    pub realmode_power_off: ::std::os::raw::c_int,
    pub disabled: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_apm_info() {
    assert_eq!(::std::mem::size_of::<apm_info>() , 48usize , concat ! (
               "Size of: " , stringify ! ( apm_info ) ));
    assert_eq! (::std::mem::align_of::<apm_info>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( apm_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_info ) ) . bios as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_info ) , "::" ,
                stringify ! ( bios ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_info ) ) . connection_version as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_info ) , "::" ,
                stringify ! ( connection_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_info ) ) . get_power_status_broken as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_info ) , "::" ,
                stringify ! ( get_power_status_broken ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_info ) ) .
                get_power_status_swabinminutes as * const _ as usize } ,
                28usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_info ) , "::" ,
                stringify ! ( get_power_status_swabinminutes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_info ) ) . allow_ints as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_info ) , "::" ,
                stringify ! ( allow_ints ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_info ) ) . forbid_idle as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_info ) , "::" ,
                stringify ! ( forbid_idle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_info ) ) . realmode_power_off as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_info ) , "::" ,
                stringify ! ( realmode_power_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apm_info ) ) . disabled as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( apm_info ) , "::" ,
                stringify ! ( disabled ) ));
}
impl Clone for apm_info {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "apm_info"]
    pub static mut apm_info: apm_info;
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params {
    pub length: __u16,
    pub info_flags: __u16,
    pub num_default_cylinders: __u32,
    pub num_default_heads: __u32,
    pub sectors_per_track: __u32,
    pub number_of_sectors: __u64,
    pub bytes_per_sector: __u16,
    pub dpte_ptr: __u32,
    pub key: __u16,
    pub device_path_info_length: __u8,
    pub reserved2: __u8,
    pub reserved3: __u16,
    pub host_bus_type: [__u8; 4usize],
    pub interface_type: [__u8; 8usize],
    pub interface_path: edd_device_params__bindgen_ty_1,
    pub device_path: edd_device_params__bindgen_ty_2,
    pub reserved4: __u8,
    pub checksum: __u8,
}
#[repr(C)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_1 {
    pub isa: __BindgenUnionField<edd_device_params__bindgen_ty_1__bindgen_ty_1>,
    pub pci: __BindgenUnionField<edd_device_params__bindgen_ty_1__bindgen_ty_2>,
    pub ibnd: __BindgenUnionField<edd_device_params__bindgen_ty_1__bindgen_ty_3>,
    pub xprs: __BindgenUnionField<edd_device_params__bindgen_ty_1__bindgen_ty_4>,
    pub htpt: __BindgenUnionField<edd_device_params__bindgen_ty_1__bindgen_ty_5>,
    pub unknown: __BindgenUnionField<edd_device_params__bindgen_ty_1__bindgen_ty_6>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_1 {
    pub base_address: __u16,
    pub reserved1: __u16,
    pub reserved2: __u32,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_1__bindgen_ty_1
                ) ) . base_address as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( base_address ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_1__bindgen_ty_1
                ) ) . reserved1 as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_1__bindgen_ty_1
                ) ) . reserved2 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( reserved2 ) ));
}
impl Clone for edd_device_params__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_2 {
    pub bus: __u8,
    pub slot: __u8,
    pub function: __u8,
    pub channel: __u8,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_2>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_1__bindgen_ty_2
                ) ) . bus as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( bus ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_1__bindgen_ty_2
                ) ) . slot as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( slot ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_1__bindgen_ty_2
                ) ) . function as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( function ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_1__bindgen_ty_2
                ) ) . channel as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( channel ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_1__bindgen_ty_2
                ) ) . reserved as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( reserved ) ));
}
impl Clone for edd_device_params__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_3 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_3>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_3>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_1__bindgen_ty_3
                ) ) . reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( reserved ) ));
}
impl Clone for edd_device_params__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_4 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_4>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_4>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_1__bindgen_ty_4
                ) ) . reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_4 ) , "::" ,
                stringify ! ( reserved ) ));
}
impl Clone for edd_device_params__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_5>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_5>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_1__bindgen_ty_5
                ) ) . reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_5 ) , "::" ,
                stringify ! ( reserved ) ));
}
impl Clone for edd_device_params__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_6 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_6>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_1__bindgen_ty_6 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_6>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_6 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_1__bindgen_ty_6
                ) ) . reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1__bindgen_ty_6 ) , "::" ,
                stringify ! ( reserved ) ));
}
impl Clone for edd_device_params__bindgen_ty_1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( edd_device_params__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_1>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_1 ) ) . isa
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1 ) , "::" , stringify ! ( isa )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_1 ) ) . pci
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1 ) , "::" , stringify ! ( pci )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_1 ) ) .
                ibnd as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1 ) , "::" , stringify ! ( ibnd
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_1 ) ) .
                xprs as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1 ) , "::" , stringify ! ( xprs
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_1 ) ) .
                htpt as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1 ) , "::" , stringify ! ( htpt
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_1 ) ) .
                unknown as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_1 ) , "::" , stringify ! (
                unknown ) ));
}
impl Clone for edd_device_params__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_2 {
    pub ata: __BindgenUnionField<edd_device_params__bindgen_ty_2__bindgen_ty_1>,
    pub atapi: __BindgenUnionField<edd_device_params__bindgen_ty_2__bindgen_ty_2>,
    pub scsi: __BindgenUnionField<edd_device_params__bindgen_ty_2__bindgen_ty_3>,
    pub usb: __BindgenUnionField<edd_device_params__bindgen_ty_2__bindgen_ty_4>,
    pub i1394: __BindgenUnionField<edd_device_params__bindgen_ty_2__bindgen_ty_5>,
    pub fibre: __BindgenUnionField<edd_device_params__bindgen_ty_2__bindgen_ty_6>,
    pub i2o: __BindgenUnionField<edd_device_params__bindgen_ty_2__bindgen_ty_7>,
    pub raid: __BindgenUnionField<edd_device_params__bindgen_ty_2__bindgen_ty_8>,
    pub sata: __BindgenUnionField<edd_device_params__bindgen_ty_2__bindgen_ty_9>,
    pub unknown: __BindgenUnionField<edd_device_params__bindgen_ty_2__bindgen_ty_10>,
    pub bindgen_union_field: [u8; 16usize],
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_1 {
    pub device: __u8,
    pub reserved1: __u8,
    pub reserved2: __u16,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_1
                ) ) . device as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( device ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_1
                ) ) . reserved1 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_1
                ) ) . reserved2 as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( reserved2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_1
                ) ) . reserved3 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( reserved3 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_1
                ) ) . reserved4 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( reserved4 ) ));
}
impl Clone for edd_device_params__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_2 {
    pub device: __u8,
    pub lun: __u8,
    pub reserved1: __u8,
    pub reserved2: __u8,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_2>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_2>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_2
                ) ) . device as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_2 ) , "::" ,
                stringify ! ( device ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_2
                ) ) . lun as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_2 ) , "::" ,
                stringify ! ( lun ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_2
                ) ) . reserved1 as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_2 ) , "::" ,
                stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_2
                ) ) . reserved2 as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_2 ) , "::" ,
                stringify ! ( reserved2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_2
                ) ) . reserved3 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_2 ) , "::" ,
                stringify ! ( reserved3 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_2
                ) ) . reserved4 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_2 ) , "::" ,
                stringify ! ( reserved4 ) ));
}
impl Clone for edd_device_params__bindgen_ty_2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_3 {
    pub id: __u16,
    pub lun: __u64,
    pub reserved1: __u16,
    pub reserved2: __u32,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_3>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_2__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_3>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_3
                ) ) . id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_3 ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_3
                ) ) . lun as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_3 ) , "::" ,
                stringify ! ( lun ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_3
                ) ) . reserved1 as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_3 ) , "::" ,
                stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_3
                ) ) . reserved2 as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_3 ) , "::" ,
                stringify ! ( reserved2 ) ));
}
impl Clone for edd_device_params__bindgen_ty_2__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_4 {
    pub serial_number: __u64,
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_4>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_2__bindgen_ty_4 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_4>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_4
                ) ) . serial_number as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_4 ) , "::" ,
                stringify ! ( serial_number ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_4
                ) ) . reserved as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_4 ) , "::" ,
                stringify ! ( reserved ) ));
}
impl Clone for edd_device_params__bindgen_ty_2__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_5 {
    pub eui: __u64,
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_5>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_2__bindgen_ty_5 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_5>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_5
                ) ) . eui as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_5 ) , "::" ,
                stringify ! ( eui ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_5
                ) ) . reserved as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_5 ) , "::" ,
                stringify ! ( reserved ) ));
}
impl Clone for edd_device_params__bindgen_ty_2__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_6 {
    pub wwid: __u64,
    pub lun: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_6>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_2__bindgen_ty_6 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_6>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_6 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_6
                ) ) . wwid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_6 ) , "::" ,
                stringify ! ( wwid ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_6
                ) ) . lun as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_6 ) , "::" ,
                stringify ! ( lun ) ));
}
impl Clone for edd_device_params__bindgen_ty_2__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_7 {
    pub identity_tag: __u64,
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_7>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_2__bindgen_ty_7 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_7>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_7 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_7
                ) ) . identity_tag as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_7 ) , "::" ,
                stringify ! ( identity_tag ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_7
                ) ) . reserved as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_7 ) , "::" ,
                stringify ! ( reserved ) ));
}
impl Clone for edd_device_params__bindgen_ty_2__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_8 {
    pub array_number: __u32,
    pub reserved1: __u32,
    pub reserved2: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_8>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_2__bindgen_ty_8 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_8>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_8 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_8
                ) ) . array_number as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_8 ) , "::" ,
                stringify ! ( array_number ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_8
                ) ) . reserved1 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_8 ) , "::" ,
                stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_8
                ) ) . reserved2 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_8 ) , "::" ,
                stringify ! ( reserved2 ) ));
}
impl Clone for edd_device_params__bindgen_ty_2__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_9 {
    pub device: __u8,
    pub reserved1: __u8,
    pub reserved2: __u16,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_9>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_2__bindgen_ty_9 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_9>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_9 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_9
                ) ) . device as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_9 ) , "::" ,
                stringify ! ( device ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_9
                ) ) . reserved1 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_9 ) , "::" ,
                stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_9
                ) ) . reserved2 as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_9 ) , "::" ,
                stringify ! ( reserved2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_9
                ) ) . reserved3 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_9 ) , "::" ,
                stringify ! ( reserved3 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_9
                ) ) . reserved4 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_9 ) , "::" ,
                stringify ! ( reserved4 ) ));
}
impl Clone for edd_device_params__bindgen_ty_2__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_10 {
    pub reserved1: __u64,
    pub reserved2: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_10() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_10>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               edd_device_params__bindgen_ty_2__bindgen_ty_10 ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_10>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_10 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_10 )
                ) . reserved1 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_10 ) , "::" ,
                stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const edd_device_params__bindgen_ty_2__bindgen_ty_10 )
                ) . reserved2 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2__bindgen_ty_10 ) , "::" ,
                stringify ! ( reserved2 ) ));
}
impl Clone for edd_device_params__bindgen_ty_2__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<edd_device_params__bindgen_ty_2>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( edd_device_params__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<edd_device_params__bindgen_ty_2>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                edd_device_params__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_2 ) ) . ata
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2 ) , "::" , stringify ! ( ata )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_2 ) ) .
                atapi as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2 ) , "::" , stringify ! ( atapi
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_2 ) ) .
                scsi as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2 ) , "::" , stringify ! ( scsi
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_2 ) ) . usb
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2 ) , "::" , stringify ! ( usb )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_2 ) ) .
                i1394 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2 ) , "::" , stringify ! ( i1394
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_2 ) ) .
                fibre as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2 ) , "::" , stringify ! ( fibre
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_2 ) ) . i2o
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2 ) , "::" , stringify ! ( i2o )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_2 ) ) .
                raid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2 ) , "::" , stringify ! ( raid
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_2 ) ) .
                sata as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2 ) , "::" , stringify ! ( sata
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params__bindgen_ty_2 ) ) .
                unknown as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                edd_device_params__bindgen_ty_2 ) , "::" , stringify ! (
                unknown ) ));
}
impl Clone for edd_device_params__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_edd_device_params() {
    assert_eq!(::std::mem::size_of::<edd_device_params>() , 74usize , concat !
               ( "Size of: " , stringify ! ( edd_device_params ) ));
    assert_eq! (::std::mem::align_of::<edd_device_params>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( edd_device_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . length as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . info_flags as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( info_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) .
                num_default_cylinders as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( num_default_cylinders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . num_default_heads
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( num_default_heads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . sectors_per_track
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( sectors_per_track ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . number_of_sectors
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( number_of_sectors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . bytes_per_sector
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( bytes_per_sector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . dpte_ptr as *
                const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( dpte_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . key as * const _
                as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) .
                device_path_info_length as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( device_path_info_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . reserved2 as *
                const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . reserved3 as *
                const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . host_bus_type as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( host_bus_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . interface_type as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( interface_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . interface_path as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( interface_path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . device_path as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( device_path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . reserved4 as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_device_params ) ) . checksum as *
                const _ as usize } , 73usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_device_params ) ,
                "::" , stringify ! ( checksum ) ));
}
impl Clone for edd_device_params {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct edd_info {
    pub device: __u8,
    pub version: __u8,
    pub interface_support: __u16,
    pub legacy_max_cylinder: __u16,
    pub legacy_max_head: __u8,
    pub legacy_sectors_per_track: __u8,
    pub params: edd_device_params,
}
#[test]
fn bindgen_test_layout_edd_info() {
    assert_eq!(::std::mem::size_of::<edd_info>() , 82usize , concat ! (
               "Size of: " , stringify ! ( edd_info ) ));
    assert_eq! (::std::mem::align_of::<edd_info>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( edd_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_info ) ) . device as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_info ) , "::" ,
                stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_info ) ) . version as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_info ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_info ) ) . interface_support as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_info ) , "::" ,
                stringify ! ( interface_support ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_info ) ) . legacy_max_cylinder as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_info ) , "::" ,
                stringify ! ( legacy_max_cylinder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_info ) ) . legacy_max_head as * const
                _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_info ) , "::" ,
                stringify ! ( legacy_max_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_info ) ) . legacy_sectors_per_track
                as * const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_info ) , "::" ,
                stringify ! ( legacy_sectors_per_track ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd_info ) ) . params as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( edd_info ) , "::" ,
                stringify ! ( params ) ));
}
impl Clone for edd_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct edd {
    pub mbr_signature: [::std::os::raw::c_uint; 16usize],
    pub edd_info: [edd_info; 6usize],
    pub mbr_signature_nr: ::std::os::raw::c_uchar,
    pub edd_info_nr: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_edd() {
    assert_eq!(::std::mem::size_of::<edd>() , 560usize , concat ! (
               "Size of: " , stringify ! ( edd ) ));
    assert_eq! (::std::mem::align_of::<edd>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( edd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd ) ) . mbr_signature as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( edd ) , "::" ,
                stringify ! ( mbr_signature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd ) ) . edd_info as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( edd ) , "::" ,
                stringify ! ( edd_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd ) ) . mbr_signature_nr as * const _
                as usize } , 556usize , concat ! (
                "Alignment of field: " , stringify ! ( edd ) , "::" ,
                stringify ! ( mbr_signature_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edd ) ) . edd_info_nr as * const _ as
                usize } , 557usize , concat ! (
                "Alignment of field: " , stringify ! ( edd ) , "::" ,
                stringify ! ( edd_info_nr ) ));
}
impl Clone for edd {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "edd"]
    pub static mut edd: edd;
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct e820entry {
    pub addr: __u64,
    pub size: __u64,
    pub type_: __u32,
}
#[test]
fn bindgen_test_layout_e820entry() {
    assert_eq!(::std::mem::size_of::<e820entry>() , 20usize , concat ! (
               "Size of: " , stringify ! ( e820entry ) ));
    assert_eq! (::std::mem::align_of::<e820entry>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( e820entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e820entry ) ) . addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e820entry ) , "::" ,
                stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e820entry ) ) . size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e820entry ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e820entry ) ) . type_ as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( e820entry ) , "::" ,
                stringify ! ( type_ ) ));
}
impl Clone for e820entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct e820map {
    pub nr_map: __u32,
    pub map: [e820entry; 320usize],
}
#[test]
fn bindgen_test_layout_e820map() {
    assert_eq!(::std::mem::size_of::<e820map>() , 6404usize , concat ! (
               "Size of: " , stringify ! ( e820map ) ));
    assert_eq! (::std::mem::align_of::<e820map>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( e820map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e820map ) ) . nr_map as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e820map ) , "::" ,
                stringify ! ( nr_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e820map ) ) . map as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( e820map ) , "::" ,
                stringify ! ( map ) ));
}
extern "C" {
    #[link_name = "e820"]
    pub static mut e820: e820map;
}
extern "C" {
    #[link_name = "e820_saved"]
    pub static mut e820_saved: e820map;
}
extern "C" {
    #[link_name = "pci_mem_start"]
    pub static mut pci_mem_start: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn e820_any_mapped(start: u64, end: u64,
                           type_: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn e820_all_mapped(start: u64, end: u64,
                           type_: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn e820_add_region(start: u64, size: u64,
                           type_: ::std::os::raw::c_int);
}
extern "C" {
    pub fn e820_print_map(who: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn sanitize_e820_map(biosmap: *mut e820entry,
                             max_nr_map: ::std::os::raw::c_int,
                             pnr_map: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn e820_update_range(start: u64, size: u64,
                             old_type: ::std::os::raw::c_uint,
                             new_type: ::std::os::raw::c_uint) -> u64;
}
extern "C" {
    pub fn e820_remove_range(start: u64, size: u64,
                             old_type: ::std::os::raw::c_uint,
                             checktype: ::std::os::raw::c_int) -> u64;
}
extern "C" {
    pub fn update_e820();
}
extern "C" {
    pub fn e820_setup_gap();
}
extern "C" {
    pub fn e820_search_gap(gapstart: *mut ::std::os::raw::c_ulong,
                           gapsize: *mut ::std::os::raw::c_ulong,
                           start_addr: ::std::os::raw::c_ulong,
                           end_addr: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct setup_data {
    pub next: __u64,
    pub type_: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_setup_data() {
    assert_eq!(::std::mem::size_of::<setup_data>() , 16usize , concat ! (
               "Size of: " , stringify ! ( setup_data ) ));
    assert_eq! (::std::mem::align_of::<setup_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( setup_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_data ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_data ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_data ) ) . type_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_data ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_data ) ) . len as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_data ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_data ) ) . data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_data ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for setup_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn parse_e820_ext(phys_addr: u64, data_len: u32);
}
extern "C" {
    pub fn e820_mark_nosave_regions(limit_pfn: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn e820_end_of_ram_pfn() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn e820_end_of_low_ram_pfn() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn early_reserve_e820(sizet: u64, align: u64) -> u64;
}
extern "C" {
    pub fn memblock_x86_fill();
}
extern "C" {
    pub fn memblock_find_dma_reserve();
}
extern "C" {
    pub fn finish_e820_parsing();
}
extern "C" {
    pub fn e820_reserve_resources();
}
extern "C" {
    pub fn e820_reserve_resources_late();
}
extern "C" {
    pub fn setup_memory_map();
}
extern "C" {
    pub fn default_machine_specific_memory_setup()
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy)]
pub struct resource {
    pub start: resource_size_t,
    pub end: resource_size_t,
    pub name: *const ::std::os::raw::c_char,
    pub flags: ::std::os::raw::c_ulong,
    pub parent: *mut resource,
    pub sibling: *mut resource,
    pub child: *mut resource,
}
#[test]
fn bindgen_test_layout_resource() {
    assert_eq!(::std::mem::size_of::<resource>() , 56usize , concat ! (
               "Size of: " , stringify ! ( resource ) ));
    assert_eq! (::std::mem::align_of::<resource>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( resource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource ) ) . start as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource ) , "::" ,
                stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource ) ) . end as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource ) , "::" ,
                stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource ) ) . name as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource ) ) . flags as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( resource ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource ) ) . parent as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( resource ) , "::" ,
                stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource ) ) . sibling as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( resource ) , "::" ,
                stringify ! ( sibling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource ) ) . child as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( resource ) , "::" ,
                stringify ! ( child ) ));
}
impl Clone for resource {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "ioport_resource"]
    pub static mut ioport_resource: resource;
}
extern "C" {
    #[link_name = "iomem_resource"]
    pub static mut iomem_resource: resource;
}
extern "C" {
    pub fn request_resource_conflict(root: *mut resource, new: *mut resource)
     -> *mut resource;
}
extern "C" {
    pub fn request_resource(root: *mut resource, new: *mut resource)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn release_resource(new: *mut resource) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn release_child_resources(new: *mut resource);
}
extern "C" {
    pub fn reserve_region_with_split(root: *mut resource,
                                     start: resource_size_t,
                                     end: resource_size_t,
                                     name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn insert_resource_conflict(parent: *mut resource, new: *mut resource)
     -> *mut resource;
}
extern "C" {
    pub fn insert_resource(parent: *mut resource, new: *mut resource)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn insert_resource_expand_to_fit(root: *mut resource,
                                         new: *mut resource);
}
extern "C" {
    pub fn arch_remove_reservations(avail: *mut resource);
}
extern "C" {
    pub fn allocate_resource(root: *mut resource, new: *mut resource,
                             size: resource_size_t, min: resource_size_t,
                             max: resource_size_t, align: resource_size_t,
                             alignf:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                *mut ::std::os::raw::c_void,
                                                                            arg2:
                                                                                *const resource,
                                                                            arg3:
                                                                                resource_size_t,
                                                                            arg4:
                                                                                resource_size_t)
                                                           ->
                                                               resource_size_t>,
                             alignf_data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lookup_resource(root: *mut resource, start: resource_size_t)
     -> *mut resource;
}
extern "C" {
    pub fn adjust_resource(res: *mut resource, start: resource_size_t,
                           size: resource_size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn resource_alignment(res: *mut resource) -> resource_size_t;
}
extern "C" {
    pub fn __request_region(arg1: *mut resource, start: resource_size_t,
                            n: resource_size_t,
                            name: *const ::std::os::raw::c_char,
                            flags: ::std::os::raw::c_int) -> *mut resource;
}
extern "C" {
    pub fn __release_region(arg1: *mut resource, arg2: resource_size_t,
                            arg3: resource_size_t);
}
extern "C" {
    pub fn release_mem_region_adjustable(arg1: *mut resource,
                                         arg2: resource_size_t,
                                         arg3: resource_size_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devm_request_resource(dev: *mut device, root: *mut resource,
                                 new: *mut resource) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devm_release_resource(dev: *mut device, new: *mut resource);
}
extern "C" {
    pub fn __devm_request_region(dev: *mut device, parent: *mut resource,
                                 start: resource_size_t, n: resource_size_t,
                                 name: *const ::std::os::raw::c_char)
     -> *mut resource;
}
extern "C" {
    pub fn __devm_release_region(dev: *mut device, parent: *mut resource,
                                 start: resource_size_t, n: resource_size_t);
}
extern "C" {
    pub fn iomem_map_sanity_check(addr: resource_size_t,
                                  size: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iomem_is_exclusive(addr: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn walk_system_ram_range(start_pfn: ::std::os::raw::c_ulong,
                                 nr_pages: ::std::os::raw::c_ulong,
                                 arg: *mut ::std::os::raw::c_void,
                                 func:
                                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                    ::std::os::raw::c_ulong,
                                                                                arg2:
                                                                                    ::std::os::raw::c_ulong,
                                                                                arg3:
                                                                                    *mut ::std::os::raw::c_void)
                                                               ->
                                                                   ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn walk_system_ram_res(start: u64, end: u64,
                               arg: *mut ::std::os::raw::c_void,
                               func:
                                   ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                  u64,
                                                                              arg2:
                                                                                  u64,
                                                                              arg3:
                                                                                  *mut ::std::os::raw::c_void)
                                                             ->
                                                                 ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn walk_iomem_res(name: *mut ::std::os::raw::c_char,
                          flags: ::std::os::raw::c_ulong, start: u64,
                          end: u64, arg: *mut ::std::os::raw::c_void,
                          func:
                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             u64,
                                                                         arg2:
                                                                             u64,
                                                                         arg3:
                                                                             *mut ::std::os::raw::c_void)
                                                        ->
                                                            ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct ist_info {
    pub signature: __u32,
    pub command: __u32,
    pub event: __u32,
    pub perf_level: __u32,
}
#[test]
fn bindgen_test_layout_ist_info() {
    assert_eq!(::std::mem::size_of::<ist_info>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ist_info ) ));
    assert_eq! (::std::mem::align_of::<ist_info>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ist_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ist_info ) ) . signature as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ist_info ) , "::" ,
                stringify ! ( signature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ist_info ) ) . command as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ist_info ) , "::" ,
                stringify ! ( command ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ist_info ) ) . event as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ist_info ) , "::" ,
                stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ist_info ) ) . perf_level as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ist_info ) , "::" ,
                stringify ! ( perf_level ) ));
}
impl Clone for ist_info {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "ist_info"]
    pub static mut ist_info: ist_info;
}
#[repr(C)]
pub struct edid_info {
    pub dummy: [::std::os::raw::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_edid_info() {
    assert_eq!(::std::mem::size_of::<edid_info>() , 128usize , concat ! (
               "Size of: " , stringify ! ( edid_info ) ));
    assert_eq! (::std::mem::align_of::<edid_info>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( edid_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const edid_info ) ) . dummy as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( edid_info ) , "::" ,
                stringify ! ( dummy ) ));
}
extern "C" {
    #[link_name = "edid_info"]
    pub static mut edid_info: edid_info;
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct setup_header {
    pub setup_sects: __u8,
    pub root_flags: __u16,
    pub syssize: __u32,
    pub ram_size: __u16,
    pub vid_mode: __u16,
    pub root_dev: __u16,
    pub boot_flag: __u16,
    pub jump: __u16,
    pub header: __u32,
    pub version: __u16,
    pub realmode_swtch: __u32,
    pub start_sys: __u16,
    pub kernel_version: __u16,
    pub type_of_loader: __u8,
    pub loadflags: __u8,
    pub setup_move_size: __u16,
    pub code32_start: __u32,
    pub ramdisk_image: __u32,
    pub ramdisk_size: __u32,
    pub bootsect_kludge: __u32,
    pub heap_end_ptr: __u16,
    pub ext_loader_ver: __u8,
    pub ext_loader_type: __u8,
    pub cmd_line_ptr: __u32,
    pub initrd_addr_max: __u32,
    pub kernel_alignment: __u32,
    pub relocatable_kernel: __u8,
    pub min_alignment: __u8,
    pub xloadflags: __u16,
    pub cmdline_size: __u32,
    pub hardware_subarch: __u32,
    pub hardware_subarch_data: __u64,
    pub payload_offset: __u32,
    pub payload_length: __u32,
    pub setup_data: __u64,
    pub pref_address: __u64,
    pub init_size: __u32,
    pub handover_offset: __u32,
}
#[test]
fn bindgen_test_layout_setup_header() {
    assert_eq!(::std::mem::size_of::<setup_header>() , 119usize , concat ! (
               "Size of: " , stringify ! ( setup_header ) ));
    assert_eq! (::std::mem::align_of::<setup_header>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( setup_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . setup_sects as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( setup_sects ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . root_flags as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( root_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . syssize as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( syssize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . ram_size as * const _
                as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( ram_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . vid_mode as * const _
                as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( vid_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . root_dev as * const _
                as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( root_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . boot_flag as * const _
                as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( boot_flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . jump as * const _ as
                usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( jump ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . header as * const _ as
                usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . version as * const _
                as usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . realmode_swtch as *
                const _ as usize } , 23usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( realmode_swtch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . start_sys as * const _
                as usize } , 27usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( start_sys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . kernel_version as *
                const _ as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( kernel_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . type_of_loader as *
                const _ as usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( type_of_loader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . loadflags as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( loadflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . setup_move_size as *
                const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( setup_move_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . code32_start as *
                const _ as usize } , 35usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( code32_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . ramdisk_image as *
                const _ as usize } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( ramdisk_image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . ramdisk_size as *
                const _ as usize } , 43usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( ramdisk_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . bootsect_kludge as *
                const _ as usize } , 47usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( bootsect_kludge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . heap_end_ptr as *
                const _ as usize } , 51usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( heap_end_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . ext_loader_ver as *
                const _ as usize } , 53usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( ext_loader_ver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . ext_loader_type as *
                const _ as usize } , 54usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( ext_loader_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . cmd_line_ptr as *
                const _ as usize } , 55usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( cmd_line_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . initrd_addr_max as *
                const _ as usize } , 59usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( initrd_addr_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . kernel_alignment as *
                const _ as usize } , 63usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( kernel_alignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . relocatable_kernel as
                * const _ as usize } , 67usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( relocatable_kernel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . min_alignment as *
                const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( min_alignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . xloadflags as * const
                _ as usize } , 69usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( xloadflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . cmdline_size as *
                const _ as usize } , 71usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( cmdline_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . hardware_subarch as *
                const _ as usize } , 75usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( hardware_subarch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . hardware_subarch_data
                as * const _ as usize } , 79usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( hardware_subarch_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . payload_offset as *
                const _ as usize } , 87usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( payload_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . payload_length as *
                const _ as usize } , 91usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( payload_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . setup_data as * const
                _ as usize } , 95usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( setup_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . pref_address as *
                const _ as usize } , 103usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( pref_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . init_size as * const _
                as usize } , 111usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( init_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setup_header ) ) . handover_offset as *
                const _ as usize } , 115usize , concat ! (
                "Alignment of field: " , stringify ! ( setup_header ) , "::" ,
                stringify ! ( handover_offset ) ));
}
impl Clone for setup_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sys_desc_table {
    pub length: __u16,
    pub table: [__u8; 14usize],
}
#[test]
fn bindgen_test_layout_sys_desc_table() {
    assert_eq!(::std::mem::size_of::<sys_desc_table>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sys_desc_table ) ));
    assert_eq! (::std::mem::align_of::<sys_desc_table>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( sys_desc_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sys_desc_table ) ) . length as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sys_desc_table ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sys_desc_table ) ) . table as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sys_desc_table ) , "::"
                , stringify ! ( table ) ));
}
impl Clone for sys_desc_table {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct olpc_ofw_header {
    pub ofw_magic: __u32,
    pub ofw_version: __u32,
    pub cif_handler: __u32,
    pub irq_desc_table: __u32,
}
#[test]
fn bindgen_test_layout_olpc_ofw_header() {
    assert_eq!(::std::mem::size_of::<olpc_ofw_header>() , 16usize , concat ! (
               "Size of: " , stringify ! ( olpc_ofw_header ) ));
    assert_eq! (::std::mem::align_of::<olpc_ofw_header>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( olpc_ofw_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const olpc_ofw_header ) ) . ofw_magic as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( olpc_ofw_header ) ,
                "::" , stringify ! ( ofw_magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const olpc_ofw_header ) ) . ofw_version as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( olpc_ofw_header ) ,
                "::" , stringify ! ( ofw_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const olpc_ofw_header ) ) . cif_handler as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( olpc_ofw_header ) ,
                "::" , stringify ! ( cif_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const olpc_ofw_header ) ) . irq_desc_table as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( olpc_ofw_header ) ,
                "::" , stringify ! ( irq_desc_table ) ));
}
impl Clone for olpc_ofw_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct efi_info {
    pub efi_loader_signature: __u32,
    pub efi_systab: __u32,
    pub efi_memdesc_size: __u32,
    pub efi_memdesc_version: __u32,
    pub efi_memmap: __u32,
    pub efi_memmap_size: __u32,
    pub efi_systab_hi: __u32,
    pub efi_memmap_hi: __u32,
}
#[test]
fn bindgen_test_layout_efi_info() {
    assert_eq!(::std::mem::size_of::<efi_info>() , 32usize , concat ! (
               "Size of: " , stringify ! ( efi_info ) ));
    assert_eq! (::std::mem::align_of::<efi_info>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( efi_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const efi_info ) ) . efi_loader_signature as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( efi_info ) , "::" ,
                stringify ! ( efi_loader_signature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const efi_info ) ) . efi_systab as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( efi_info ) , "::" ,
                stringify ! ( efi_systab ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const efi_info ) ) . efi_memdesc_size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( efi_info ) , "::" ,
                stringify ! ( efi_memdesc_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const efi_info ) ) . efi_memdesc_version as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( efi_info ) , "::" ,
                stringify ! ( efi_memdesc_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const efi_info ) ) . efi_memmap as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( efi_info ) , "::" ,
                stringify ! ( efi_memmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const efi_info ) ) . efi_memmap_size as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( efi_info ) , "::" ,
                stringify ! ( efi_memmap_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const efi_info ) ) . efi_systab_hi as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( efi_info ) , "::" ,
                stringify ! ( efi_systab_hi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const efi_info ) ) . efi_memmap_hi as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( efi_info ) , "::" ,
                stringify ! ( efi_memmap_hi ) ));
}
impl Clone for efi_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
pub struct boot_params {
    pub screen_info: screen_info,
    pub apm_bios_info: apm_bios_info,
    pub _pad2: [__u8; 4usize],
    pub tboot_addr: __u64,
    pub ist_info: ist_info,
    pub _pad3: [__u8; 16usize],
    pub hd0_info: [__u8; 16usize],
    pub hd1_info: [__u8; 16usize],
    pub sys_desc_table: sys_desc_table,
    pub olpc_ofw_header: olpc_ofw_header,
    pub ext_ramdisk_image: __u32,
    pub ext_ramdisk_size: __u32,
    pub ext_cmd_line_ptr: __u32,
    pub _pad4: [__u8; 116usize],
    pub edid_info: edid_info,
    pub efi_info: efi_info,
    pub alt_mem_k: __u32,
    pub scratch: __u32,
    pub e820_entries: __u8,
    pub eddbuf_entries: __u8,
    pub edd_mbr_sig_buf_entries: __u8,
    pub kbd_status: __u8,
    pub _pad5: [__u8; 3usize],
    pub sentinel: __u8,
    pub _pad6: [__u8; 1usize],
    pub hdr: setup_header,
    pub _pad7: [__u8; 40usize],
    pub edd_mbr_sig_buffer: [__u32; 16usize],
    pub e820_map: [e820entry; 128usize],
    pub _pad8: [__u8; 48usize],
    pub eddbuf: [edd_info; 6usize],
    pub _pad9: [__u8; 276usize],
}
#[test]
fn bindgen_test_layout_boot_params() {
    assert_eq!(::std::mem::size_of::<boot_params>() , 4096usize , concat ! (
               "Size of: " , stringify ! ( boot_params ) ));
    assert_eq! (::std::mem::align_of::<boot_params>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( boot_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . screen_info as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( screen_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . apm_bios_info as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( apm_bios_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . _pad2 as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( _pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . tboot_addr as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( tboot_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . ist_info as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( ist_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . _pad3 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( _pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . hd0_info as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( hd0_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . hd1_info as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( hd1_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . sys_desc_table as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( sys_desc_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . olpc_ofw_header as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( olpc_ofw_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . ext_ramdisk_image as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( ext_ramdisk_image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . ext_ramdisk_size as *
                const _ as usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( ext_ramdisk_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . ext_cmd_line_ptr as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( ext_cmd_line_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . _pad4 as * const _ as
                usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( _pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . edid_info as * const _
                as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( edid_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . efi_info as * const _
                as usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( efi_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . alt_mem_k as * const _
                as usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( alt_mem_k ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . scratch as * const _ as
                usize } , 484usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( scratch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . e820_entries as * const
                _ as usize } , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( e820_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . eddbuf_entries as *
                const _ as usize } , 489usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( eddbuf_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . edd_mbr_sig_buf_entries
                as * const _ as usize } , 490usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( edd_mbr_sig_buf_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . kbd_status as * const _
                as usize } , 491usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( kbd_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . _pad5 as * const _ as
                usize } , 492usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( _pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . sentinel as * const _
                as usize } , 495usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( sentinel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . _pad6 as * const _ as
                usize } , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( _pad6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . hdr as * const _ as
                usize } , 497usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . _pad7 as * const _ as
                usize } , 616usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( _pad7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . edd_mbr_sig_buffer as *
                const _ as usize } , 656usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( edd_mbr_sig_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . e820_map as * const _
                as usize } , 720usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( e820_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . _pad8 as * const _ as
                usize } , 3280usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( _pad8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . eddbuf as * const _ as
                usize } , 3328usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( eddbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const boot_params ) ) . _pad9 as * const _ as
                usize } , 3820usize , concat ! (
                "Alignment of field: " , stringify ! ( boot_params ) , "::" ,
                stringify ! ( _pad9 ) ));
}
pub const X86_SUBARCH_PC: _bindgen_ty_66 = _bindgen_ty_66::X86_SUBARCH_PC;
pub const X86_SUBARCH_LGUEST: _bindgen_ty_66 =
    _bindgen_ty_66::X86_SUBARCH_LGUEST;
pub const X86_SUBARCH_XEN: _bindgen_ty_66 = _bindgen_ty_66::X86_SUBARCH_XEN;
pub const X86_SUBARCH_INTEL_MID: _bindgen_ty_66 =
    _bindgen_ty_66::X86_SUBARCH_INTEL_MID;
pub const X86_SUBARCH_CE4100: _bindgen_ty_66 =
    _bindgen_ty_66::X86_SUBARCH_CE4100;
pub const X86_NR_SUBARCHS: _bindgen_ty_66 = _bindgen_ty_66::X86_NR_SUBARCHS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_66 {
    X86_SUBARCH_PC = 0,
    X86_SUBARCH_LGUEST = 1,
    X86_SUBARCH_XEN = 2,
    X86_SUBARCH_INTEL_MID = 3,
    X86_SUBARCH_CE4100 = 4,
    X86_NR_SUBARCHS = 5,
}
/// struct x86_init_mpparse - platform specific mpparse ops
/// @mpc_record:			platform specific mpc record accounting
/// @setup_ioapic_ids:		platform specific ioapic id override
/// @mpc_apic_id:		platform specific mpc apic id assignment
/// @smp_read_mpc_oem:		platform specific oem mpc table setup
/// @mpc_oem_pci_bus:		platform specific pci bus setup (default NULL)
/// @mpc_oem_bus_info:		platform specific mpc bus info
/// @find_smp_config:		find the smp configuration
/// @get_smp_config:		get the smp configuration
#[repr(C)]
#[derive(Copy)]
pub struct x86_init_mpparse {
    pub mpc_record: ::std::option::Option<unsafe extern "C" fn(mode:
                                                                   ::std::os::raw::c_uint)>,
    pub setup_ioapic_ids: ::std::option::Option<unsafe extern "C" fn()>,
    pub mpc_apic_id: ::std::option::Option<unsafe extern "C" fn(m:
                                                                    *mut mpc_cpu)
                                               -> ::std::os::raw::c_int>,
    pub smp_read_mpc_oem: ::std::option::Option<unsafe extern "C" fn(mpc:
                                                                         *mut mpc_table)>,
    pub mpc_oem_pci_bus: ::std::option::Option<unsafe extern "C" fn(m:
                                                                        *mut mpc_bus)>,
    pub mpc_oem_bus_info: ::std::option::Option<unsafe extern "C" fn(m:
                                                                         *mut mpc_bus,
                                                                     name:
                                                                         *mut ::std::os::raw::c_char)>,
    pub find_smp_config: ::std::option::Option<unsafe extern "C" fn()>,
    pub get_smp_config: ::std::option::Option<unsafe extern "C" fn(early:
                                                                       ::std::os::raw::c_uint)>,
}
#[test]
fn bindgen_test_layout_x86_init_mpparse() {
    assert_eq!(::std::mem::size_of::<x86_init_mpparse>() , 64usize , concat !
               ( "Size of: " , stringify ! ( x86_init_mpparse ) ));
    assert_eq! (::std::mem::align_of::<x86_init_mpparse>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( x86_init_mpparse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_mpparse ) ) . mpc_record as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_mpparse ) ,
                "::" , stringify ! ( mpc_record ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_mpparse ) ) . setup_ioapic_ids
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_mpparse ) ,
                "::" , stringify ! ( setup_ioapic_ids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_mpparse ) ) . mpc_apic_id as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_mpparse ) ,
                "::" , stringify ! ( mpc_apic_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_mpparse ) ) . smp_read_mpc_oem
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_mpparse ) ,
                "::" , stringify ! ( smp_read_mpc_oem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_mpparse ) ) . mpc_oem_pci_bus as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_mpparse ) ,
                "::" , stringify ! ( mpc_oem_pci_bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_mpparse ) ) . mpc_oem_bus_info
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_mpparse ) ,
                "::" , stringify ! ( mpc_oem_bus_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_mpparse ) ) . find_smp_config as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_mpparse ) ,
                "::" , stringify ! ( find_smp_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_mpparse ) ) . get_smp_config as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_mpparse ) ,
                "::" , stringify ! ( get_smp_config ) ));
}
impl Clone for x86_init_mpparse {
    fn clone(&self) -> Self { *self }
}
/// struct x86_init_resources - platform specific resource related ops
/// @probe_roms:			probe BIOS roms
/// @reserve_resources:		reserve the standard resources for the
/// platform
/// @memory_setup:		platform specific memory setup
///
#[repr(C)]
#[derive(Copy)]
pub struct x86_init_resources {
    pub probe_roms: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserve_resources: ::std::option::Option<unsafe extern "C" fn()>,
    pub memory_setup: ::std::option::Option<unsafe extern "C" fn()
                                                ->
                                                    *mut ::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_x86_init_resources() {
    assert_eq!(::std::mem::size_of::<x86_init_resources>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( x86_init_resources ) ));
    assert_eq! (::std::mem::align_of::<x86_init_resources>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( x86_init_resources ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_resources ) ) . probe_roms as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_resources ) ,
                "::" , stringify ! ( probe_roms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_resources ) ) .
                reserve_resources as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( x86_init_resources ) ,
                "::" , stringify ! ( reserve_resources ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_resources ) ) . memory_setup as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_resources ) ,
                "::" , stringify ! ( memory_setup ) ));
}
impl Clone for x86_init_resources {
    fn clone(&self) -> Self { *self }
}
/// struct x86_init_irqs - platform specific interrupt setup
/// @pre_vector_init:		init code to run before interrupt vectors
/// are set up.
/// @intr_init:			interrupt init code
/// @trap_init:			platform specific trap setup
#[repr(C)]
#[derive(Copy)]
pub struct x86_init_irqs {
    pub pre_vector_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub intr_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub trap_init: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_irqs() {
    assert_eq!(::std::mem::size_of::<x86_init_irqs>() , 24usize , concat ! (
               "Size of: " , stringify ! ( x86_init_irqs ) ));
    assert_eq! (::std::mem::align_of::<x86_init_irqs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( x86_init_irqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_irqs ) ) . pre_vector_init as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_irqs ) , "::"
                , stringify ! ( pre_vector_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_irqs ) ) . intr_init as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_irqs ) , "::"
                , stringify ! ( intr_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_irqs ) ) . trap_init as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_irqs ) , "::"
                , stringify ! ( trap_init ) ));
}
impl Clone for x86_init_irqs {
    fn clone(&self) -> Self { *self }
}
/// struct x86_init_oem - oem platform specific customizing functions
/// @arch_setup:			platform specific architecure setup
/// @banner:			print a platform specific banner
#[repr(C)]
#[derive(Copy)]
pub struct x86_init_oem {
    pub arch_setup: ::std::option::Option<unsafe extern "C" fn()>,
    pub banner: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_oem() {
    assert_eq!(::std::mem::size_of::<x86_init_oem>() , 16usize , concat ! (
               "Size of: " , stringify ! ( x86_init_oem ) ));
    assert_eq! (::std::mem::align_of::<x86_init_oem>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( x86_init_oem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_oem ) ) . arch_setup as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_oem ) , "::" ,
                stringify ! ( arch_setup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_oem ) ) . banner as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_oem ) , "::" ,
                stringify ! ( banner ) ));
}
impl Clone for x86_init_oem {
    fn clone(&self) -> Self { *self }
}
/// struct x86_init_paging - platform specific paging functions
/// @pagetable_init:	platform specific paging initialization call to setup
/// the kernel pagetables and prepare accessors functions.
/// Callback must call paging_init(). Called once after the
/// direct mapping for phys memory is available.
#[repr(C)]
#[derive(Copy)]
pub struct x86_init_paging {
    pub pagetable_init: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_paging() {
    assert_eq!(::std::mem::size_of::<x86_init_paging>() , 8usize , concat ! (
               "Size of: " , stringify ! ( x86_init_paging ) ));
    assert_eq! (::std::mem::align_of::<x86_init_paging>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( x86_init_paging ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_paging ) ) . pagetable_init as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_paging ) ,
                "::" , stringify ! ( pagetable_init ) ));
}
impl Clone for x86_init_paging {
    fn clone(&self) -> Self { *self }
}
/// struct x86_init_timers - platform specific timer setup
/// @setup_perpcu_clockev:	set up the per cpu clock event device for the
/// boot cpu
/// @tsc_pre_init:		platform function called before TSC init
/// @timer_init:			initialize the platform timer (default PIT/HPET)
/// @wallclock_init:		init the wallclock device
#[repr(C)]
#[derive(Copy)]
pub struct x86_init_timers {
    pub setup_percpu_clockev: ::std::option::Option<unsafe extern "C" fn()>,
    pub tsc_pre_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub timer_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub wallclock_init: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_timers() {
    assert_eq!(::std::mem::size_of::<x86_init_timers>() , 32usize , concat ! (
               "Size of: " , stringify ! ( x86_init_timers ) ));
    assert_eq! (::std::mem::align_of::<x86_init_timers>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( x86_init_timers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_timers ) ) .
                setup_percpu_clockev as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! ( x86_init_timers ) ,
                "::" , stringify ! ( setup_percpu_clockev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_timers ) ) . tsc_pre_init as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_timers ) ,
                "::" , stringify ! ( tsc_pre_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_timers ) ) . timer_init as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_timers ) ,
                "::" , stringify ! ( timer_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_timers ) ) . wallclock_init as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_timers ) ,
                "::" , stringify ! ( wallclock_init ) ));
}
impl Clone for x86_init_timers {
    fn clone(&self) -> Self { *self }
}
/// struct x86_init_iommu - platform specific iommu setup
/// @iommu_init:			platform specific iommu setup
#[repr(C)]
#[derive(Copy)]
pub struct x86_init_iommu {
    pub iommu_init: ::std::option::Option<unsafe extern "C" fn()
                                              -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_x86_init_iommu() {
    assert_eq!(::std::mem::size_of::<x86_init_iommu>() , 8usize , concat ! (
               "Size of: " , stringify ! ( x86_init_iommu ) ));
    assert_eq! (::std::mem::align_of::<x86_init_iommu>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( x86_init_iommu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_iommu ) ) . iommu_init as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_iommu ) , "::"
                , stringify ! ( iommu_init ) ));
}
impl Clone for x86_init_iommu {
    fn clone(&self) -> Self { *self }
}
/// struct x86_init_pci - platform specific pci init functions
/// @arch_init:			platform specific pci arch init call
/// @init:			platform specific pci subsystem init
/// @init_irq:			platform specific pci irq init
/// @fixup_irqs:			platform specific pci irq fixup
#[repr(C)]
#[derive(Copy)]
pub struct x86_init_pci {
    pub arch_init: ::std::option::Option<unsafe extern "C" fn()
                                             -> ::std::os::raw::c_int>,
    pub init: ::std::option::Option<unsafe extern "C" fn()
                                        -> ::std::os::raw::c_int>,
    pub init_irq: ::std::option::Option<unsafe extern "C" fn()>,
    pub fixup_irqs: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_pci() {
    assert_eq!(::std::mem::size_of::<x86_init_pci>() , 32usize , concat ! (
               "Size of: " , stringify ! ( x86_init_pci ) ));
    assert_eq! (::std::mem::align_of::<x86_init_pci>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( x86_init_pci ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_pci ) ) . arch_init as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_pci ) , "::" ,
                stringify ! ( arch_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_pci ) ) . init as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_pci ) , "::" ,
                stringify ! ( init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_pci ) ) . init_irq as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_pci ) , "::" ,
                stringify ! ( init_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_pci ) ) . fixup_irqs as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_pci ) , "::" ,
                stringify ! ( fixup_irqs ) ));
}
impl Clone for x86_init_pci {
    fn clone(&self) -> Self { *self }
}
/// struct x86_init_ops - functions for platform specific setup
///
#[repr(C)]
#[derive(Copy)]
pub struct x86_init_ops {
    pub resources: x86_init_resources,
    pub mpparse: x86_init_mpparse,
    pub irqs: x86_init_irqs,
    pub oem: x86_init_oem,
    pub paging: x86_init_paging,
    pub timers: x86_init_timers,
    pub iommu: x86_init_iommu,
    pub pci: x86_init_pci,
}
#[test]
fn bindgen_test_layout_x86_init_ops() {
    assert_eq!(::std::mem::size_of::<x86_init_ops>() , 208usize , concat ! (
               "Size of: " , stringify ! ( x86_init_ops ) ));
    assert_eq! (::std::mem::align_of::<x86_init_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( x86_init_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_ops ) ) . resources as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_ops ) , "::" ,
                stringify ! ( resources ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_ops ) ) . mpparse as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_ops ) , "::" ,
                stringify ! ( mpparse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_ops ) ) . irqs as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_ops ) , "::" ,
                stringify ! ( irqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_ops ) ) . oem as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_ops ) , "::" ,
                stringify ! ( oem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_ops ) ) . paging as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_ops ) , "::" ,
                stringify ! ( paging ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_ops ) ) . timers as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_ops ) , "::" ,
                stringify ! ( timers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_ops ) ) . iommu as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_ops ) , "::" ,
                stringify ! ( iommu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_init_ops ) ) . pci as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_init_ops ) , "::" ,
                stringify ! ( pci ) ));
}
impl Clone for x86_init_ops {
    fn clone(&self) -> Self { *self }
}
/// struct x86_cpuinit_ops - platform specific cpu hotplug setups
/// @setup_percpu_clockev:	set up the per cpu clock event device
/// @early_percpu_clock_init:	early init of the per cpu clock event device
#[repr(C)]
#[derive(Copy)]
pub struct x86_cpuinit_ops {
    pub setup_percpu_clockev: ::std::option::Option<unsafe extern "C" fn()>,
    pub early_percpu_clock_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub fixup_cpu_id: ::std::option::Option<unsafe extern "C" fn(c:
                                                                     *mut cpuinfo_x86,
                                                                 node:
                                                                     ::std::os::raw::c_int)>,
}
#[test]
fn bindgen_test_layout_x86_cpuinit_ops() {
    assert_eq!(::std::mem::size_of::<x86_cpuinit_ops>() , 24usize , concat ! (
               "Size of: " , stringify ! ( x86_cpuinit_ops ) ));
    assert_eq! (::std::mem::align_of::<x86_cpuinit_ops>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( x86_cpuinit_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_cpuinit_ops ) ) .
                setup_percpu_clockev as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! ( x86_cpuinit_ops ) ,
                "::" , stringify ! ( setup_percpu_clockev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_cpuinit_ops ) ) .
                early_percpu_clock_init as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( x86_cpuinit_ops ) ,
                "::" , stringify ! ( early_percpu_clock_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_cpuinit_ops ) ) . fixup_cpu_id as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_cpuinit_ops ) ,
                "::" , stringify ! ( fixup_cpu_id ) ));
}
impl Clone for x86_cpuinit_ops {
    fn clone(&self) -> Self { *self }
}
/// struct x86_platform_ops - platform specific runtime functions
/// @calibrate_tsc:		calibrate TSC
/// @get_wallclock:		get time from HW clock like RTC etc.
/// @set_wallclock:		set time back to HW clock
/// @is_untracked_pat_range	exclude from PAT logic
/// @nmi_init			enable NMI on cpus
/// @i8042_detect		pre-detect if i8042 controller exists
/// @save_sched_clock_state:	save state for sched_clock() on suspend
/// @restore_sched_clock_state:	restore state for sched_clock() on resume
/// @apic_post_init:		adjust apic if neeeded
#[repr(C)]
#[derive(Copy)]
pub struct x86_platform_ops {
    pub calibrate_tsc: ::std::option::Option<unsafe extern "C" fn()
                                                 -> ::std::os::raw::c_ulong>,
    pub get_wallclock: ::std::option::Option<unsafe extern "C" fn(ts:
                                                                      *mut timespec)>,
    pub set_wallclock: ::std::option::Option<unsafe extern "C" fn(ts:
                                                                      *const timespec)
                                                 -> ::std::os::raw::c_int>,
    pub iommu_shutdown: ::std::option::Option<unsafe extern "C" fn()>,
    pub is_untracked_pat_range: ::std::option::Option<unsafe extern "C" fn(start:
                                                                               u64,
                                                                           end:
                                                                               u64)
                                                          -> bool_>,
    pub nmi_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub get_nmi_reason: ::std::option::Option<unsafe extern "C" fn()
                                                  -> ::std::os::raw::c_uchar>,
    pub i8042_detect: ::std::option::Option<unsafe extern "C" fn()
                                                -> ::std::os::raw::c_int>,
    pub save_sched_clock_state: ::std::option::Option<unsafe extern "C" fn()>,
    pub restore_sched_clock_state: ::std::option::Option<unsafe extern "C" fn()>,
    pub apic_post_init: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_platform_ops() {
    assert_eq!(::std::mem::size_of::<x86_platform_ops>() , 88usize , concat !
               ( "Size of: " , stringify ! ( x86_platform_ops ) ));
    assert_eq! (::std::mem::align_of::<x86_platform_ops>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( x86_platform_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_platform_ops ) ) . calibrate_tsc as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_platform_ops ) ,
                "::" , stringify ! ( calibrate_tsc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_platform_ops ) ) . get_wallclock as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_platform_ops ) ,
                "::" , stringify ! ( get_wallclock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_platform_ops ) ) . set_wallclock as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_platform_ops ) ,
                "::" , stringify ! ( set_wallclock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_platform_ops ) ) . iommu_shutdown as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_platform_ops ) ,
                "::" , stringify ! ( iommu_shutdown ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_platform_ops ) ) .
                is_untracked_pat_range as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( x86_platform_ops ) ,
                "::" , stringify ! ( is_untracked_pat_range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_platform_ops ) ) . nmi_init as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_platform_ops ) ,
                "::" , stringify ! ( nmi_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_platform_ops ) ) . get_nmi_reason as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_platform_ops ) ,
                "::" , stringify ! ( get_nmi_reason ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_platform_ops ) ) . i8042_detect as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_platform_ops ) ,
                "::" , stringify ! ( i8042_detect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_platform_ops ) ) .
                save_sched_clock_state as * const _ as usize } , 64usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( x86_platform_ops ) ,
                "::" , stringify ! ( save_sched_clock_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_platform_ops ) ) .
                restore_sched_clock_state as * const _ as usize } , 72usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( x86_platform_ops ) ,
                "::" , stringify ! ( restore_sched_clock_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_platform_ops ) ) . apic_post_init as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_platform_ops ) ,
                "::" , stringify ! ( apic_post_init ) ));
}
impl Clone for x86_platform_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pci_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct x86_msi_ops {
    pub setup_msi_irqs: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                       *mut pci_dev,
                                                                   nvec:
                                                                       ::std::os::raw::c_int,
                                                                   type_:
                                                                       ::std::os::raw::c_int)
                                                  -> ::std::os::raw::c_int>,
    pub teardown_msi_irq: ::std::option::Option<unsafe extern "C" fn(irq:
                                                                         ::std::os::raw::c_uint)>,
    pub teardown_msi_irqs: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                          *mut pci_dev)>,
    pub restore_msi_irqs: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                         *mut pci_dev)>,
}
#[test]
fn bindgen_test_layout_x86_msi_ops() {
    assert_eq!(::std::mem::size_of::<x86_msi_ops>() , 32usize , concat ! (
               "Size of: " , stringify ! ( x86_msi_ops ) ));
    assert_eq! (::std::mem::align_of::<x86_msi_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( x86_msi_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_msi_ops ) ) . setup_msi_irqs as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_msi_ops ) , "::" ,
                stringify ! ( setup_msi_irqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_msi_ops ) ) . teardown_msi_irq as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_msi_ops ) , "::" ,
                stringify ! ( teardown_msi_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_msi_ops ) ) . teardown_msi_irqs as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_msi_ops ) , "::" ,
                stringify ! ( teardown_msi_irqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_msi_ops ) ) . restore_msi_irqs as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_msi_ops ) , "::" ,
                stringify ! ( restore_msi_irqs ) ));
}
impl Clone for x86_msi_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct x86_io_apic_ops {
    pub read: ::std::option::Option<unsafe extern "C" fn(apic:
                                                             ::std::os::raw::c_uint,
                                                         reg:
                                                             ::std::os::raw::c_uint)
                                        -> ::std::os::raw::c_uint>,
    pub disable: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_io_apic_ops() {
    assert_eq!(::std::mem::size_of::<x86_io_apic_ops>() , 16usize , concat ! (
               "Size of: " , stringify ! ( x86_io_apic_ops ) ));
    assert_eq! (::std::mem::align_of::<x86_io_apic_ops>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( x86_io_apic_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_io_apic_ops ) ) . read as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_io_apic_ops ) ,
                "::" , stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const x86_io_apic_ops ) ) . disable as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( x86_io_apic_ops ) ,
                "::" , stringify ! ( disable ) ));
}
impl Clone for x86_io_apic_ops {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "x86_init"]
    pub static mut x86_init: x86_init_ops;
}
extern "C" {
    #[link_name = "x86_cpuinit"]
    pub static mut x86_cpuinit: x86_cpuinit_ops;
}
extern "C" {
    #[link_name = "x86_platform"]
    pub static mut x86_platform: x86_platform_ops;
}
extern "C" {
    #[link_name = "x86_msi"]
    pub static mut x86_msi: x86_msi_ops;
}
extern "C" {
    #[link_name = "x86_io_apic_ops"]
    pub static mut x86_io_apic_ops: x86_io_apic_ops;
}
extern "C" {
    pub fn x86_init_noop();
}
extern "C" {
    pub fn x86_init_uint_noop(unused: ::std::os::raw::c_uint);
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct local_apic {
    pub __reserved_01: local_apic__bindgen_ty_1,
    pub __reserved_02: local_apic__bindgen_ty_2,
    pub id: local_apic__bindgen_ty_3,
    pub version: local_apic__bindgen_ty_4,
    pub __reserved_03: local_apic__bindgen_ty_5,
    pub __reserved_04: local_apic__bindgen_ty_6,
    pub __reserved_05: local_apic__bindgen_ty_7,
    pub __reserved_06: local_apic__bindgen_ty_8,
    pub tpr: local_apic__bindgen_ty_9,
    pub apr: local_apic__bindgen_ty_10,
    pub ppr: local_apic__bindgen_ty_11,
    pub eoi: local_apic__bindgen_ty_12,
    pub __reserved_07: local_apic__bindgen_ty_13,
    pub ldr: local_apic__bindgen_ty_14,
    pub dfr: local_apic__bindgen_ty_15,
    pub svr: local_apic__bindgen_ty_16,
    pub isr: [local_apic__bindgen_ty_17; 8usize],
    pub tmr: [local_apic__bindgen_ty_18; 8usize],
    pub irr: [local_apic__bindgen_ty_19; 8usize],
    pub esr: local_apic__bindgen_ty_20,
    pub __reserved_08: local_apic__bindgen_ty_21,
    pub __reserved_09: local_apic__bindgen_ty_22,
    pub __reserved_10: local_apic__bindgen_ty_23,
    pub __reserved_11: local_apic__bindgen_ty_24,
    pub __reserved_12: local_apic__bindgen_ty_25,
    pub __reserved_13: local_apic__bindgen_ty_26,
    pub __reserved_14: local_apic__bindgen_ty_27,
    pub icr1: local_apic__bindgen_ty_28,
    pub icr2: local_apic__bindgen_ty_29,
    pub lvt_timer: local_apic__bindgen_ty_30,
    pub lvt_thermal: local_apic__bindgen_ty_31,
    pub lvt_pc: local_apic__bindgen_ty_32,
    pub lvt_lint0: local_apic__bindgen_ty_33,
    pub lvt_lint1: local_apic__bindgen_ty_34,
    pub lvt_error: local_apic__bindgen_ty_35,
    pub timer_icr: local_apic__bindgen_ty_36,
    pub timer_ccr: local_apic__bindgen_ty_37,
    pub __reserved_16: local_apic__bindgen_ty_38,
    pub __reserved_17: local_apic__bindgen_ty_39,
    pub __reserved_18: local_apic__bindgen_ty_40,
    pub __reserved_19: local_apic__bindgen_ty_41,
    pub timer_dcr: local_apic__bindgen_ty_42,
    pub __reserved_20: local_apic__bindgen_ty_43,
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_1 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_1 ) ) . __reserved
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_1 ) , "::" , stringify ! ( __reserved )
                ));
}
impl Clone for local_apic__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_2 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_2>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_2>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_2 ) ) . __reserved
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_2 ) , "::" , stringify ! ( __reserved )
                ));
}
impl Clone for local_apic__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_3 {
    pub _bitfield_1: u32,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_3>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_3>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_3 ) ) . __reserved
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_3 ) , "::" , stringify ! ( __reserved )
                ));
}
impl Clone for local_apic__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_3 {
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16777215u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16777215u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn phys_apic_id(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 251658240u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_phys_apic_id(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 251658240u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4026531840u64 as u32;
        let val = (unit_field_val & mask) >> 28usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4026531840u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 28usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__reserved_1: ::std::os::raw::c_uint,
                          phys_apic_id: ::std::os::raw::c_uint,
                          __reserved_2: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((__reserved_1 as u32 as u32) << 0usize) &
                           (16777215u64 as u32))
              } |
                  ((phys_apic_id as u32 as u32) << 24usize) &
                      (251658240u64 as u32))
         } |
             ((__reserved_2 as u32 as u32) << 28usize) &
                 (4026531840u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_4 {
    pub _bitfield_1: [u8; 4usize],
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_4>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_4 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_4>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_4 ) ) . __reserved
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_4 ) , "::" , stringify ! ( __reserved )
                ));
}
impl Clone for local_apic__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_4 {
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn max_lvt(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16711680u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_max_lvt(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16711680u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(version: ::std::os::raw::c_uint,
                          __reserved_1: ::std::os::raw::c_uint,
                          max_lvt: ::std::os::raw::c_uint,
                          __reserved_2: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((version as u32 as u32) << 0usize) &
                                (255u64 as u32))
                   } |
                       ((__reserved_1 as u32 as u32) << 8usize) &
                           (65280u64 as u32))
              } | ((max_lvt as u32 as u32) << 16usize) & (16711680u64 as u32))
         } |
             ((__reserved_2 as u32 as u32) << 24usize) &
                 (4278190080u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_5 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_5>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_5 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_5>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_5 ) ) . __reserved
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_5 ) , "::" , stringify ! ( __reserved )
                ));
}
impl Clone for local_apic__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_6 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_6>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_6 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_6>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_6 ) ) . __reserved
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_6 ) , "::" , stringify ! ( __reserved )
                ));
}
impl Clone for local_apic__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_7 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_7>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_7 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_7>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_7 ) ) . __reserved
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_7 ) , "::" , stringify ! ( __reserved )
                ));
}
impl Clone for local_apic__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_8 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_8>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_8 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_8>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_8 ) ) . __reserved
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_8 ) , "::" , stringify ! ( __reserved )
                ));
}
impl Clone for local_apic__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_9 {
    pub _bitfield_1: u32,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_9>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_9 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_9>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_9 ) ) .
                __reserved_2 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_9 ) , "::" , stringify ! ( __reserved_2
                ) ));
}
impl Clone for local_apic__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_9 {
    #[inline]
    pub fn priority(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967040u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294967040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(priority: ::std::os::raw::c_uint,
                          __reserved_1: ::std::os::raw::c_uint) -> u32 {
        ({ ({ 0 } | ((priority as u32 as u32) << 0usize) & (255u64 as u32)) }
             |
             ((__reserved_1 as u32 as u32) << 8usize) &
                 (4294967040u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_10 {
    pub _bitfield_1: u32,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_10() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_10>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_10 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_10>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_10 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_10 ) ) .
                __reserved_2 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_10 ) , "::" , stringify ! (
                __reserved_2 ) ));
}
impl Clone for local_apic__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_10 {
    #[inline]
    pub fn priority(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967040u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294967040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(priority: ::std::os::raw::c_uint,
                          __reserved_1: ::std::os::raw::c_uint) -> u32 {
        ({ ({ 0 } | ((priority as u32 as u32) << 0usize) & (255u64 as u32)) }
             |
             ((__reserved_1 as u32 as u32) << 8usize) &
                 (4294967040u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_11 {
    pub _bitfield_1: u32,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_11() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_11>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_11 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_11>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_11 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_11 ) ) .
                __reserved_2 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_11 ) , "::" , stringify ! (
                __reserved_2 ) ));
}
impl Clone for local_apic__bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_11 {
    #[inline]
    pub fn priority(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967040u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294967040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(priority: ::std::os::raw::c_uint,
                          __reserved_1: ::std::os::raw::c_uint) -> u32 {
        ({ ({ 0 } | ((priority as u32 as u32) << 0usize) & (255u64 as u32)) }
             |
             ((__reserved_1 as u32 as u32) << 8usize) &
                 (4294967040u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_12 {
    pub eoi: ::std::os::raw::c_uint,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_12() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_12>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_12 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_12>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_12 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_12 ) ) . eoi as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_12 ) , "::" , stringify ! ( eoi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_12 ) ) .
                __reserved as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_12 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_13 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_13() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_13>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_13 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_13>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_13 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_13 ) ) .
                __reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_13 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_14 {
    pub _bitfield_1: u32,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_14() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_14>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_14 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_14>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_14 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_14 ) ) .
                __reserved_2 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_14 ) , "::" , stringify ! (
                __reserved_2 ) ));
}
impl Clone for local_apic__bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_14 {
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16777215u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16777215u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn logical_dest(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_logical_dest(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__reserved_1: ::std::os::raw::c_uint,
                          logical_dest: ::std::os::raw::c_uint) -> u32 {
        ({
             ({ 0 } |
                  ((__reserved_1 as u32 as u32) << 0usize) &
                      (16777215u64 as u32))
         } |
             ((logical_dest as u32 as u32) << 24usize) &
                 (4278190080u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_15 {
    pub _bitfield_1: u32,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_15() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_15>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_15 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_15>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_15 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_15 ) ) .
                __reserved_2 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_15 ) , "::" , stringify ! (
                __reserved_2 ) ));
}
impl Clone for local_apic__bindgen_ty_15 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_15 {
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 268435455u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 268435455u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn model(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4026531840u64 as u32;
        let val = (unit_field_val & mask) >> 28usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_model(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4026531840u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 28usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__reserved_1: ::std::os::raw::c_uint,
                          model: ::std::os::raw::c_uint) -> u32 {
        ({
             ({ 0 } |
                  ((__reserved_1 as u32 as u32) << 0usize) &
                      (268435455u64 as u32))
         } | ((model as u32 as u32) << 28usize) & (4026531840u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_16 {
    pub _bitfield_1: u32,
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_16() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_16>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_16 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_16>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_16 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_16 ) ) .
                __reserved_3 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_16 ) , "::" , stringify ! (
                __reserved_3 ) ));
}
impl Clone for local_apic__bindgen_ty_16 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_16 {
    #[inline]
    pub fn spurious_vector(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_spurious_vector(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn apic_enabled(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 256u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_apic_enabled(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 256u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn focus_cpu(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 512u64 as u32;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_focus_cpu(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 512u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294966272u64 as u32;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294966272u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(spurious_vector: ::std::os::raw::c_uint,
                          apic_enabled: ::std::os::raw::c_uint,
                          focus_cpu: ::std::os::raw::c_uint,
                          __reserved_2: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((spurious_vector as u32 as u32) << 0usize) &
                                (255u64 as u32))
                   } |
                       ((apic_enabled as u32 as u32) << 8usize) &
                           (256u64 as u32))
              } | ((focus_cpu as u32 as u32) << 9usize) & (512u64 as u32))
         } |
             ((__reserved_2 as u32 as u32) << 10usize) &
                 (4294966272u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_17 {
    pub bitfield: ::std::os::raw::c_uint,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_17() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_17>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_17 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_17>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_17 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_17 ) ) . bitfield
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_17 ) , "::" , stringify ! ( bitfield )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_17 ) ) .
                __reserved as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_17 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_17 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_18 {
    pub bitfield: ::std::os::raw::c_uint,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_18() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_18>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_18 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_18>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_18 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_18 ) ) . bitfield
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_18 ) , "::" , stringify ! ( bitfield )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_18 ) ) .
                __reserved as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_18 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_18 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_19 {
    pub bitfield: ::std::os::raw::c_uint,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_19() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_19>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_19 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_19>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_19 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_19 ) ) . bitfield
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_19 ) , "::" , stringify ! ( bitfield )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_19 ) ) .
                __reserved as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_19 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_19 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_20 {
    pub error_bits: __BindgenUnionField<local_apic__bindgen_ty_20__bindgen_ty_1>,
    pub all_errors: __BindgenUnionField<local_apic__bindgen_ty_20__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_20__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_20__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               local_apic__bindgen_ty_20__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_20__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                local_apic__bindgen_ty_20__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_20__bindgen_ty_1 )
                ) . __reserved_3 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_20__bindgen_ty_1 ) , "::" , stringify !
                ( __reserved_3 ) ));
}
impl Clone for local_apic__bindgen_ty_20__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn send_cs_error(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_send_cs_error(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn receive_cs_error(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_receive_cs_error(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn send_accept_error(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_send_accept_error(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn receive_accept_error(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 8u64 as u32;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_receive_accept_error(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16u64 as u32;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn send_illegal_vector(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32u64 as u32;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_send_illegal_vector(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn receive_illegal_vector(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 64u64 as u32;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_receive_illegal_vector(&mut self,
                                      val: ::std::os::raw::c_uint) {
        let mask = 64u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn illegal_register_address(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 128u64 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_illegal_register_address(&mut self,
                                        val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967040u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294967040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(send_cs_error: ::std::os::raw::c_uint,
                          receive_cs_error: ::std::os::raw::c_uint,
                          send_accept_error: ::std::os::raw::c_uint,
                          receive_accept_error: ::std::os::raw::c_uint,
                          __reserved_1: ::std::os::raw::c_uint,
                          send_illegal_vector: ::std::os::raw::c_uint,
                          receive_illegal_vector: ::std::os::raw::c_uint,
                          illegal_register_address: ::std::os::raw::c_uint,
                          __reserved_2: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({ 0 } |
                                                     ((send_cs_error as u32 as
                                                           u32) << 0usize) &
                                                         (1u64 as u32))
                                            } |
                                                ((receive_cs_error as u32 as
                                                      u32) << 1usize) &
                                                    (2u64 as u32))
                                       } |
                                           ((send_accept_error as u32 as u32)
                                                << 2usize) & (4u64 as u32))
                                  } |
                                      ((receive_accept_error as u32 as u32) <<
                                           3usize) & (8u64 as u32))
                             } |
                                 ((__reserved_1 as u32 as u32) << 4usize) &
                                     (16u64 as u32))
                        } |
                            ((send_illegal_vector as u32 as u32) << 5usize) &
                                (32u64 as u32))
                   } |
                       ((receive_illegal_vector as u32 as u32) << 6usize) &
                           (64u64 as u32))
              } |
                  ((illegal_register_address as u32 as u32) << 7usize) &
                      (128u64 as u32))
         } |
             ((__reserved_2 as u32 as u32) << 8usize) &
                 (4294967040u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_20__bindgen_ty_2 {
    pub errors: ::std::os::raw::c_uint,
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_20__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_20__bindgen_ty_2>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               local_apic__bindgen_ty_20__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_20__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                local_apic__bindgen_ty_20__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_20__bindgen_ty_2 )
                ) . errors as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_20__bindgen_ty_2 ) , "::" , stringify !
                ( errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_20__bindgen_ty_2 )
                ) . __reserved_3 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_20__bindgen_ty_2 ) , "::" , stringify !
                ( __reserved_3 ) ));
}
impl Clone for local_apic__bindgen_ty_20__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_20() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_20>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_20 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_20>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_20 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_20 ) ) .
                error_bits as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_20 ) , "::" , stringify ! ( error_bits
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_20 ) ) .
                all_errors as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_20 ) , "::" , stringify ! ( all_errors
                ) ));
}
impl Clone for local_apic__bindgen_ty_20 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_21 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_21() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_21>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_21 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_21>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_21 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_21 ) ) .
                __reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_21 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_21 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_22 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_22() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_22>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_22 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_22>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_22 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_22 ) ) .
                __reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_22 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_22 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_23 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_23() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_23>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_23 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_23>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_23 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_23 ) ) .
                __reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_23 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_23 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_24 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_24() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_24>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_24 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_24>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_24 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_24 ) ) .
                __reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_24 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_24 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_25 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_25() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_25>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_25 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_25>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_25 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_25 ) ) .
                __reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_25 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_25 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_26 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_26() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_26>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_26 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_26>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_26 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_26 ) ) .
                __reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_26 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_26 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_27 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_27() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_27>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_27 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_27>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_27 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_27 ) ) .
                __reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_27 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_27 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_28 {
    pub _bitfield_1: [u16; 2usize],
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_28() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_28>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_28 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_28>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_28 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_28 ) ) .
                __reserved_4 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_28 ) , "::" , stringify ! (
                __reserved_4 ) ));
}
impl Clone for local_apic__bindgen_ty_28 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_28 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1792u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1792u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn destination_mode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2048u64 as u32;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_destination_mode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2048u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4096u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4096u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 8192u64 as u32;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8192u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn level(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16384u64 as u32;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_level(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16384u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn trigger(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32768u64 as u32;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_trigger(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32768u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 196608u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 196608u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn shorthand(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 786432u64 as u32;
        let val = (unit_field_val & mask) >> 18usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_shorthand(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 786432u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 18usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4293918720u64 as u32;
        let val = (unit_field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4293918720u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 20usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(vector: ::std::os::raw::c_uint,
                          delivery_mode: ::std::os::raw::c_uint,
                          destination_mode: ::std::os::raw::c_uint,
                          delivery_status: ::std::os::raw::c_uint,
                          __reserved_1: ::std::os::raw::c_uint,
                          level: ::std::os::raw::c_uint,
                          trigger: ::std::os::raw::c_uint,
                          __reserved_2: ::std::os::raw::c_uint,
                          shorthand: ::std::os::raw::c_uint,
                          __reserved_3: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({ 0 } |
                                                          ((vector as u32 as
                                                                u32) <<
                                                               0usize) &
                                                              (255u64 as u32))
                                                 } |
                                                     ((delivery_mode as u32 as
                                                           u32) << 8usize) &
                                                         (1792u64 as u32))
                                            } |
                                                ((destination_mode as u32 as
                                                      u32) << 11usize) &
                                                    (2048u64 as u32))
                                       } |
                                           ((delivery_status as u32 as u32) <<
                                                12usize) & (4096u64 as u32))
                                  } |
                                      ((__reserved_1 as u32 as u32) <<
                                           13usize) & (8192u64 as u32))
                             } |
                                 ((level as u32 as u32) << 14usize) &
                                     (16384u64 as u32))
                        } |
                            ((trigger as u32 as u32) << 15usize) &
                                (32768u64 as u32))
                   } |
                       ((__reserved_2 as u32 as u32) << 16usize) &
                           (196608u64 as u32))
              } | ((shorthand as u32 as u32) << 18usize) & (786432u64 as u32))
         } |
             ((__reserved_3 as u32 as u32) << 20usize) &
                 (4293918720u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_29 {
    pub dest: local_apic__bindgen_ty_29__bindgen_ty_1,
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_29__bindgen_ty_1 {
    pub _bitfield_1: [u32; 2usize],
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_29__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_29__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               local_apic__bindgen_ty_29__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_29__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                local_apic__bindgen_ty_29__bindgen_ty_1 ) ));
}
impl Clone for local_apic__bindgen_ty_29__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_29__bindgen_ty_1 {
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 16777215u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16777215u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn phys_dest(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 251658240u64 as u64;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_phys_dest(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 251658240u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 4026531840u64 as u64;
        let val = (unit_field_val & mask) >> 28usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4026531840u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 28usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 72057589742960640u64 as u64;
        let val = (unit_field_val & mask) >> 32usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 72057589742960640u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 32usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn logical_dest(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 18374686479671623680u64 as u64;
        let val = (unit_field_val & mask) >> 56usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_logical_dest(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 18374686479671623680u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 56usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__reserved_1: ::std::os::raw::c_uint,
                          phys_dest: ::std::os::raw::c_uint,
                          __reserved_2: ::std::os::raw::c_uint,
                          __reserved_3: ::std::os::raw::c_uint,
                          logical_dest: ::std::os::raw::c_uint) -> u64 {
        ({
             ({
                  ({
                       ({
                            ({ 0 } |
                                 ((__reserved_1 as u32 as u64) << 0usize) &
                                     (16777215u64 as u64))
                        } |
                            ((phys_dest as u32 as u64) << 24usize) &
                                (251658240u64 as u64))
                   } |
                       ((__reserved_2 as u32 as u64) << 28usize) &
                           (4026531840u64 as u64))
              } |
                  ((__reserved_3 as u32 as u64) << 32usize) &
                      (72057589742960640u64 as u64))
         } |
             ((logical_dest as u32 as u64) << 56usize) &
                 (18374686479671623680u64 as u64))
    }
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_29() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_29>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_29 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_29>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_29 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_29 ) ) . dest as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_29 ) , "::" , stringify ! ( dest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_29 ) ) .
                __reserved_4 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_29 ) , "::" , stringify ! (
                __reserved_4 ) ));
}
impl Clone for local_apic__bindgen_ty_29 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_30 {
    pub _bitfield_1: [u16; 2usize],
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_30() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_30>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_30 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_30>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_30 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_30 ) ) .
                __reserved_4 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_30 ) , "::" , stringify ! (
                __reserved_4 ) ));
}
impl Clone for local_apic__bindgen_ty_30 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_30 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 3840u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 3840u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4096u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4096u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 57344u64 as u32;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 57344u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65536u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65536u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn timer_mode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 131072u64 as u32;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_timer_mode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 131072u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294705152u64 as u32;
        let val = (unit_field_val & mask) >> 18usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294705152u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 18usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(vector: ::std::os::raw::c_uint,
                          __reserved_1: ::std::os::raw::c_uint,
                          delivery_status: ::std::os::raw::c_uint,
                          __reserved_2: ::std::os::raw::c_uint,
                          mask: ::std::os::raw::c_uint,
                          timer_mode: ::std::os::raw::c_uint,
                          __reserved_3: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({ 0 } |
                                           ((vector as u32 as u32) << 0usize)
                                               & (255u64 as u32))
                                  } |
                                      ((__reserved_1 as u32 as u32) << 8usize)
                                          & (3840u64 as u32))
                             } |
                                 ((delivery_status as u32 as u32) << 12usize)
                                     & (4096u64 as u32))
                        } |
                            ((__reserved_2 as u32 as u32) << 13usize) &
                                (57344u64 as u32))
                   } | ((mask as u32 as u32) << 16usize) & (65536u64 as u32))
              } |
                  ((timer_mode as u32 as u32) << 17usize) &
                      (131072u64 as u32))
         } |
             ((__reserved_3 as u32 as u32) << 18usize) &
                 (4294705152u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_31 {
    pub _bitfield_1: [u16; 2usize],
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_31() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_31>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_31 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_31>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_31 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_31 ) ) .
                __reserved_4 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_31 ) , "::" , stringify ! (
                __reserved_4 ) ));
}
impl Clone for local_apic__bindgen_ty_31 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_31 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1792u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1792u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2048u64 as u32;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2048u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4096u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4096u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 57344u64 as u32;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 57344u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65536u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65536u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294836224u64 as u32;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294836224u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(vector: ::std::os::raw::c_uint,
                          delivery_mode: ::std::os::raw::c_uint,
                          __reserved_1: ::std::os::raw::c_uint,
                          delivery_status: ::std::os::raw::c_uint,
                          __reserved_2: ::std::os::raw::c_uint,
                          mask: ::std::os::raw::c_uint,
                          __reserved_3: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({ 0 } |
                                           ((vector as u32 as u32) << 0usize)
                                               & (255u64 as u32))
                                  } |
                                      ((delivery_mode as u32 as u32) <<
                                           8usize) & (1792u64 as u32))
                             } |
                                 ((__reserved_1 as u32 as u32) << 11usize) &
                                     (2048u64 as u32))
                        } |
                            ((delivery_status as u32 as u32) << 12usize) &
                                (4096u64 as u32))
                   } |
                       ((__reserved_2 as u32 as u32) << 13usize) &
                           (57344u64 as u32))
              } | ((mask as u32 as u32) << 16usize) & (65536u64 as u32))
         } |
             ((__reserved_3 as u32 as u32) << 17usize) &
                 (4294836224u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_32 {
    pub _bitfield_1: [u16; 2usize],
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_32() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_32>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_32 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_32>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_32 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_32 ) ) .
                __reserved_4 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_32 ) , "::" , stringify ! (
                __reserved_4 ) ));
}
impl Clone for local_apic__bindgen_ty_32 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_32 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1792u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1792u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2048u64 as u32;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2048u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4096u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4096u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 57344u64 as u32;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 57344u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65536u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65536u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294836224u64 as u32;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294836224u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(vector: ::std::os::raw::c_uint,
                          delivery_mode: ::std::os::raw::c_uint,
                          __reserved_1: ::std::os::raw::c_uint,
                          delivery_status: ::std::os::raw::c_uint,
                          __reserved_2: ::std::os::raw::c_uint,
                          mask: ::std::os::raw::c_uint,
                          __reserved_3: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({ 0 } |
                                           ((vector as u32 as u32) << 0usize)
                                               & (255u64 as u32))
                                  } |
                                      ((delivery_mode as u32 as u32) <<
                                           8usize) & (1792u64 as u32))
                             } |
                                 ((__reserved_1 as u32 as u32) << 11usize) &
                                     (2048u64 as u32))
                        } |
                            ((delivery_status as u32 as u32) << 12usize) &
                                (4096u64 as u32))
                   } |
                       ((__reserved_2 as u32 as u32) << 13usize) &
                           (57344u64 as u32))
              } | ((mask as u32 as u32) << 16usize) & (65536u64 as u32))
         } |
             ((__reserved_3 as u32 as u32) << 17usize) &
                 (4294836224u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_33 {
    pub _bitfield_1: [u16; 2usize],
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_33() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_33>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_33 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_33>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_33 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_33 ) ) .
                __reserved_3 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_33 ) , "::" , stringify ! (
                __reserved_3 ) ));
}
impl Clone for local_apic__bindgen_ty_33 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_33 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1792u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1792u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2048u64 as u32;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2048u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4096u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4096u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn polarity(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 8192u64 as u32;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_polarity(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8192u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn remote_irr(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16384u64 as u32;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_remote_irr(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16384u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn trigger(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32768u64 as u32;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_trigger(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32768u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65536u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65536u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294836224u64 as u32;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294836224u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(vector: ::std::os::raw::c_uint,
                          delivery_mode: ::std::os::raw::c_uint,
                          __reserved_1: ::std::os::raw::c_uint,
                          delivery_status: ::std::os::raw::c_uint,
                          polarity: ::std::os::raw::c_uint,
                          remote_irr: ::std::os::raw::c_uint,
                          trigger: ::std::os::raw::c_uint,
                          mask: ::std::os::raw::c_uint,
                          __reserved_2: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({ 0 } |
                                                     ((vector as u32 as u32)
                                                          << 0usize) &
                                                         (255u64 as u32))
                                            } |
                                                ((delivery_mode as u32 as u32)
                                                     << 8usize) &
                                                    (1792u64 as u32))
                                       } |
                                           ((__reserved_1 as u32 as u32) <<
                                                11usize) & (2048u64 as u32))
                                  } |
                                      ((delivery_status as u32 as u32) <<
                                           12usize) & (4096u64 as u32))
                             } |
                                 ((polarity as u32 as u32) << 13usize) &
                                     (8192u64 as u32))
                        } |
                            ((remote_irr as u32 as u32) << 14usize) &
                                (16384u64 as u32))
                   } |
                       ((trigger as u32 as u32) << 15usize) &
                           (32768u64 as u32))
              } | ((mask as u32 as u32) << 16usize) & (65536u64 as u32))
         } |
             ((__reserved_2 as u32 as u32) << 17usize) &
                 (4294836224u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_34 {
    pub _bitfield_1: [u16; 2usize],
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_34() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_34>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_34 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_34>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_34 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_34 ) ) .
                __reserved_3 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_34 ) , "::" , stringify ! (
                __reserved_3 ) ));
}
impl Clone for local_apic__bindgen_ty_34 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_34 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1792u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1792u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2048u64 as u32;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2048u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4096u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4096u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn polarity(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 8192u64 as u32;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_polarity(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8192u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn remote_irr(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16384u64 as u32;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_remote_irr(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16384u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn trigger(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32768u64 as u32;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_trigger(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32768u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65536u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65536u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294836224u64 as u32;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294836224u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(vector: ::std::os::raw::c_uint,
                          delivery_mode: ::std::os::raw::c_uint,
                          __reserved_1: ::std::os::raw::c_uint,
                          delivery_status: ::std::os::raw::c_uint,
                          polarity: ::std::os::raw::c_uint,
                          remote_irr: ::std::os::raw::c_uint,
                          trigger: ::std::os::raw::c_uint,
                          mask: ::std::os::raw::c_uint,
                          __reserved_2: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({ 0 } |
                                                     ((vector as u32 as u32)
                                                          << 0usize) &
                                                         (255u64 as u32))
                                            } |
                                                ((delivery_mode as u32 as u32)
                                                     << 8usize) &
                                                    (1792u64 as u32))
                                       } |
                                           ((__reserved_1 as u32 as u32) <<
                                                11usize) & (2048u64 as u32))
                                  } |
                                      ((delivery_status as u32 as u32) <<
                                           12usize) & (4096u64 as u32))
                             } |
                                 ((polarity as u32 as u32) << 13usize) &
                                     (8192u64 as u32))
                        } |
                            ((remote_irr as u32 as u32) << 14usize) &
                                (16384u64 as u32))
                   } |
                       ((trigger as u32 as u32) << 15usize) &
                           (32768u64 as u32))
              } | ((mask as u32 as u32) << 16usize) & (65536u64 as u32))
         } |
             ((__reserved_2 as u32 as u32) << 17usize) &
                 (4294836224u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_35 {
    pub _bitfield_1: [u16; 2usize],
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_35() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_35>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_35 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_35>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_35 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_35 ) ) .
                __reserved_4 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_35 ) , "::" , stringify ! (
                __reserved_4 ) ));
}
impl Clone for local_apic__bindgen_ty_35 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_35 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 3840u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 3840u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4096u64 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4096u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 57344u64 as u32;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 57344u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65536u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65536u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294836224u64 as u32;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294836224u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(vector: ::std::os::raw::c_uint,
                          __reserved_1: ::std::os::raw::c_uint,
                          delivery_status: ::std::os::raw::c_uint,
                          __reserved_2: ::std::os::raw::c_uint,
                          mask: ::std::os::raw::c_uint,
                          __reserved_3: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((vector as u32 as u32) << 0usize) &
                                          (255u64 as u32))
                             } |
                                 ((__reserved_1 as u32 as u32) << 8usize) &
                                     (3840u64 as u32))
                        } |
                            ((delivery_status as u32 as u32) << 12usize) &
                                (4096u64 as u32))
                   } |
                       ((__reserved_2 as u32 as u32) << 13usize) &
                           (57344u64 as u32))
              } | ((mask as u32 as u32) << 16usize) & (65536u64 as u32))
         } |
             ((__reserved_3 as u32 as u32) << 17usize) &
                 (4294836224u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_36 {
    pub initial_count: ::std::os::raw::c_uint,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_36() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_36>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_36 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_36>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_36 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_36 ) ) .
                initial_count as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_36 ) , "::" , stringify ! (
                initial_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_36 ) ) .
                __reserved_2 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_36 ) , "::" , stringify ! (
                __reserved_2 ) ));
}
impl Clone for local_apic__bindgen_ty_36 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_37 {
    pub curr_count: ::std::os::raw::c_uint,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_37() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_37>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_37 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_37>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_37 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_37 ) ) .
                curr_count as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_37 ) , "::" , stringify ! ( curr_count
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_37 ) ) .
                __reserved_2 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_37 ) , "::" , stringify ! (
                __reserved_2 ) ));
}
impl Clone for local_apic__bindgen_ty_37 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_38 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_38() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_38>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_38 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_38>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_38 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_38 ) ) .
                __reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_38 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_38 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_39 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_39() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_39>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_39 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_39>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_39 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_39 ) ) .
                __reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_39 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_39 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_40 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_40() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_40>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_40 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_40>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_40 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_40 ) ) .
                __reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_40 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_40 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_41 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_41() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_41>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_41 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_41>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_41 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_41 ) ) .
                __reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_41 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_41 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_42 {
    pub _bitfield_1: u32,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_42() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_42>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_42 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_42>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_42 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_42 ) ) .
                __reserved_2 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_42 ) , "::" , stringify ! (
                __reserved_2 ) ));
}
impl Clone for local_apic__bindgen_ty_42 {
    fn clone(&self) -> Self { *self }
}
impl local_apic__bindgen_ty_42 {
    #[inline]
    pub fn divisor(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 15u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_divisor(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 15u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967280u64 as u32;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294967280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(divisor: ::std::os::raw::c_uint,
                          __reserved_1: ::std::os::raw::c_uint) -> u32 {
        ({ ({ 0 } | ((divisor as u32 as u32) << 0usize) & (15u64 as u32)) } |
             ((__reserved_1 as u32 as u32) << 4usize) &
                 (4294967280u64 as u32))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct local_apic__bindgen_ty_43 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_43() {
    assert_eq!(::std::mem::size_of::<local_apic__bindgen_ty_43>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( local_apic__bindgen_ty_43 ) ));
    assert_eq! (::std::mem::align_of::<local_apic__bindgen_ty_43>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( local_apic__bindgen_ty_43 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic__bindgen_ty_43 ) ) .
                __reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                local_apic__bindgen_ty_43 ) , "::" , stringify ! ( __reserved
                ) ));
}
impl Clone for local_apic__bindgen_ty_43 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_local_apic() {
    assert_eq!(::std::mem::size_of::<local_apic>() , 1024usize , concat ! (
               "Size of: " , stringify ! ( local_apic ) ));
    assert_eq! (::std::mem::align_of::<local_apic>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( local_apic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_01 as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_01 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_02 as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_02 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . id as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . version as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_03 as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_03 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_04 as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_04 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_05 as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_05 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_06 as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_06 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . tpr as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( tpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . apr as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( apr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . ppr as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( ppr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . eoi as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( eoi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_07 as * const
                _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_07 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . ldr as * const _ as
                usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( ldr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . dfr as * const _ as
                usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( dfr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . svr as * const _ as
                usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( svr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . isr as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( isr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . tmr as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( tmr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . irr as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( irr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . esr as * const _ as
                usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( esr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_08 as * const
                _ as usize } , 656usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_08 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_09 as * const
                _ as usize } , 672usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_09 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_10 as * const
                _ as usize } , 688usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_11 as * const
                _ as usize } , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_12 as * const
                _ as usize } , 720usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_13 as * const
                _ as usize } , 736usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_14 as * const
                _ as usize } , 752usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . icr1 as * const _ as
                usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( icr1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . icr2 as * const _ as
                usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( icr2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . lvt_timer as * const _
                as usize } , 800usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( lvt_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . lvt_thermal as * const _
                as usize } , 816usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( lvt_thermal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . lvt_pc as * const _ as
                usize } , 832usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( lvt_pc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . lvt_lint0 as * const _
                as usize } , 848usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( lvt_lint0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . lvt_lint1 as * const _
                as usize } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( lvt_lint1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . lvt_error as * const _
                as usize } , 880usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( lvt_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . timer_icr as * const _
                as usize } , 896usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( timer_icr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . timer_ccr as * const _
                as usize } , 912usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( timer_ccr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_16 as * const
                _ as usize } , 928usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_17 as * const
                _ as usize } , 944usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_17 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_18 as * const
                _ as usize } , 960usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_18 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_19 as * const
                _ as usize } , 976usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_19 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . timer_dcr as * const _
                as usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( timer_dcr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const local_apic ) ) . __reserved_20 as * const
                _ as usize } , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( local_apic ) , "::" ,
                stringify ! ( __reserved_20 ) ));
}
impl Clone for local_apic {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ioapic_irq_destination_types {
    dest_Fixed = 0,
    dest_LowestPrio = 1,
    dest_SMI = 2,
    dest__reserved_1 = 3,
    dest_NMI = 4,
    dest_INIT = 5,
    dest__reserved_2 = 6,
    dest_ExtINT = 7,
}
extern "C" {
    #[link_name = "apic_version"]
    pub static mut apic_version: [::std::os::raw::c_int; 0usize];
}
extern "C" {
    #[link_name = "pic_mode"]
    pub static mut pic_mode: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "mp_bus_not_pci"]
    pub static mut mp_bus_not_pci: [::std::os::raw::c_ulong; 4usize];
}
extern "C" {
    #[link_name = "boot_cpu_physical_apicid"]
    pub static mut boot_cpu_physical_apicid: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "mp_lapic_addr"]
    pub static mut mp_lapic_addr: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "smp_found_config"]
    pub static mut smp_found_config: ::std::os::raw::c_int;
}
extern "C" {
    pub fn early_reserve_e820_mpc_new();
}
extern "C" {
    #[link_name = "enable_update_mptable"]
    pub static mut enable_update_mptable: ::std::os::raw::c_int;
}
extern "C" {
    pub fn default_mpc_apic_id(m: *mut mpc_cpu) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn default_smp_read_mpc_oem(mpc: *mut mpc_table);
}
extern "C" {
    pub fn default_mpc_oem_bus_info(m: *mut mpc_bus,
                                    str: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn default_find_smp_config();
}
extern "C" {
    pub fn default_get_smp_config(early: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn generic_processor_info(apicid: ::std::os::raw::c_int,
                                  version: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct physid_mask {
    pub mask: [::std::os::raw::c_ulong; 512usize],
}
#[test]
fn bindgen_test_layout_physid_mask() {
    assert_eq!(::std::mem::size_of::<physid_mask>() , 4096usize , concat ! (
               "Size of: " , stringify ! ( physid_mask ) ));
    assert_eq! (::std::mem::align_of::<physid_mask>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( physid_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const physid_mask ) ) . mask as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( physid_mask ) , "::" ,
                stringify ! ( mask ) ));
}
pub type physid_mask_t = physid_mask;
extern "C" {
    #[link_name = "phys_cpu_present_map"]
    pub static mut phys_cpu_present_map: physid_mask_t;
}
extern "C" {
    #[link_name = "pm_power_off"]
    pub static mut pm_power_off:
               ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    #[link_name = "pm_power_off_prepare"]
    pub static mut pm_power_off_prepare:
               ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn pm_vt_switch_required(dev: *mut device, required: bool_);
}
extern "C" {
    pub fn pm_vt_switch_unregister(dev: *mut device);
}
extern "C" {
    #[link_name = "power_group_name"]
    pub static mut power_group_name: [::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct pm_message {
    pub event: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pm_message() {
    assert_eq!(::std::mem::size_of::<pm_message>() , 4usize , concat ! (
               "Size of: " , stringify ! ( pm_message ) ));
    assert_eq! (::std::mem::align_of::<pm_message>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( pm_message ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pm_message ) ) . event as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pm_message ) , "::" ,
                stringify ! ( event ) ));
}
impl Clone for pm_message {
    fn clone(&self) -> Self { *self }
}
pub type pm_message_t = pm_message;
/// struct dev_pm_ops - device PM callbacks
///
/// Several device power state transitions are externally visible, affecting
/// the state of pending I/O queues and (for drivers that touch hardware)
/// interrupts, wakeups, DMA, and other hardware state.  There may also be
/// internal transitions to various low-power modes which are transparent
/// to the rest of the driver stack (such as a driver that's ON gating off
/// clocks which are not in active use).
///
/// The externally visible transitions are handled with the help of callbacks
/// included in this structure in such a way that two levels of callbacks are
/// involved.  First, the PM core executes callbacks provided by PM domains,
/// device types, classes and bus types.  They are the subsystem-level callbacks
/// supposed to execute callbacks provided by device drivers, although they may
/// choose not to do that.  If the driver callbacks are executed, they have to
/// collaborate with the subsystem-level callbacks to achieve the goals
/// appropriate for the given system transition, given transition phase and the
/// subsystem the device belongs to.
///
/// @prepare: The principal role of this callback is to prevent new children of
/// the device from being registered after it has returned (the driver's
/// subsystem and generally the rest of the kernel is supposed to prevent
/// new calls to the probe method from being made too once @prepare() has
/// succeeded).  If @prepare() detects a situation it cannot handle (e.g.
/// registration of a child already in progress), it may return -EAGAIN, so
/// that the PM core can execute it once again (e.g. after a new child has
/// been registered) to recover from the race condition.
/// This method is executed for all kinds of suspend transitions and is
/// followed by one of the suspend callbacks: @suspend(), @freeze(), or
/// @poweroff().  If the transition is a suspend to memory or standby (that
/// is, not related to hibernation), the return value of @prepare() may be
/// used to indicate to the PM core to leave the device in runtime suspend
/// if applicable.  Namely, if @prepare() returns a positive number, the PM
/// core will understand that as a declaration that the device appears to be
/// runtime-suspended and it may be left in that state during the entire
/// transition and during the subsequent resume if all of its descendants
/// are left in runtime suspend too.  If that happens, @complete() will be
/// executed directly after @prepare() and it must ensure the proper
/// functioning of the device after the system resume.
/// The PM core executes subsystem-level @prepare() for all devices before
/// starting to invoke suspend callbacks for any of them, so generally
/// devices may be assumed to be functional or to respond to runtime resume
/// requests while @prepare() is being executed.  However, device drivers
/// may NOT assume anything about the availability of user space at that
/// time and it is NOT valid to request firmware from within @prepare()
/// (it's too late to do that).  It also is NOT valid to allocate
/// substantial amounts of memory from @prepare() in the GFP_KERNEL mode.
/// [To work around these limitations, drivers may register suspend and
/// hibernation notifiers to be executed before the freezing of tasks.]
///
/// @complete: Undo the changes made by @prepare().  This method is executed for
/// all kinds of resume transitions, following one of the resume callbacks:
/// @resume(), @thaw(), @restore().  Also called if the state transition
/// fails before the driver's suspend callback: @suspend(), @freeze() or
/// @poweroff(), can be executed (e.g. if the suspend callback fails for one
/// of the other devices that the PM core has unsuccessfully attempted to
/// suspend earlier).
/// The PM core executes subsystem-level @complete() after it has executed
/// the appropriate resume callbacks for all devices.  If the corresponding
/// @prepare() at the beginning of the suspend transition returned a
/// positive number and the device was left in runtime suspend (without
/// executing any suspend and resume callbacks for it), @complete() will be
/// the only callback executed for the device during resume.  In that case,
/// @complete() must be prepared to do whatever is necessary to ensure the
/// proper functioning of the device after the system resume.  To this end,
/// @complete() can check the power.direct_complete flag of the device to
/// learn whether (unset) or not (set) the previous suspend and resume
/// callbacks have been executed for it.
///
/// @suspend: Executed before putting the system into a sleep state in which the
/// contents of main memory are preserved.  The exact action to perform
/// depends on the device's subsystem (PM domain, device type, class or bus
/// type), but generally the device must be quiescent after subsystem-level
/// @suspend() has returned, so that it doesn't do any I/O or DMA.
/// Subsystem-level @suspend() is executed for all devices after invoking
/// subsystem-level @prepare() for all of them.
///
/// @suspend_late: Continue operations started by @suspend().  For a number of
/// devices @suspend_late() may point to the same callback routine as the
/// runtime suspend callback.
///
/// @resume: Executed after waking the system up from a sleep state in which the
/// contents of main memory were preserved.  The exact action to perform
/// depends on the device's subsystem, but generally the driver is expected
/// to start working again, responding to hardware events and software
/// requests (the device itself may be left in a low-power state, waiting
/// for a runtime resume to occur).  The state of the device at the time its
/// driver's @resume() callback is run depends on the platform and subsystem
/// the device belongs to.  On most platforms, there are no restrictions on
/// availability of resources like clocks during @resume().
/// Subsystem-level @resume() is executed for all devices after invoking
/// subsystem-level @resume_noirq() for all of them.
///
/// @resume_early: Prepare to execute @resume().  For a number of devices
/// @resume_early() may point to the same callback routine as the runtime
/// resume callback.
///
/// @freeze: Hibernation-specific, executed before creating a hibernation image.
/// Analogous to @suspend(), but it should not enable the device to signal
/// wakeup events or change its power state.  The majority of subsystems
/// (with the notable exception of the PCI bus type) expect the driver-level
/// @freeze() to save the device settings in memory to be used by @restore()
/// during the subsequent resume from hibernation.
/// Subsystem-level @freeze() is executed for all devices after invoking
/// subsystem-level @prepare() for all of them.
///
/// @freeze_late: Continue operations started by @freeze().  Analogous to
/// @suspend_late(), but it should not enable the device to signal wakeup
/// events or change its power state.
///
/// @thaw: Hibernation-specific, executed after creating a hibernation image OR
/// if the creation of an image has failed.  Also executed after a failing
/// attempt to restore the contents of main memory from such an image.
/// Undo the changes made by the preceding @freeze(), so the device can be
/// operated in the same way as immediately before the call to @freeze().
/// Subsystem-level @thaw() is executed for all devices after invoking
/// subsystem-level @thaw_noirq() for all of them.  It also may be executed
/// directly after @freeze() in case of a transition error.
///
/// @thaw_early: Prepare to execute @thaw().  Undo the changes made by the
/// preceding @freeze_late().
///
/// @poweroff: Hibernation-specific, executed after saving a hibernation image.
/// Analogous to @suspend(), but it need not save the device's settings in
/// memory.
/// Subsystem-level @poweroff() is executed for all devices after invoking
/// subsystem-level @prepare() for all of them.
///
/// @poweroff_late: Continue operations started by @poweroff().  Analogous to
/// @suspend_late(), but it need not save the device's settings in memory.
///
/// @restore: Hibernation-specific, executed after restoring the contents of main
/// memory from a hibernation image, analogous to @resume().
///
/// @restore_early: Prepare to execute @restore(), analogous to @resume_early().
///
/// @suspend_noirq: Complete the actions started by @suspend().  Carry out any
/// additional operations required for suspending the device that might be
/// racing with its driver's interrupt handler, which is guaranteed not to
/// run while @suspend_noirq() is being executed.
/// It generally is expected that the device will be in a low-power state
/// (appropriate for the target system sleep state) after subsystem-level
/// @suspend_noirq() has returned successfully.  If the device can generate
/// system wakeup signals and is enabled to wake up the system, it should be
/// configured to do so at that time.  However, depending on the platform
/// and device's subsystem, @suspend() or @suspend_late() may be allowed to
/// put the device into the low-power state and configure it to generate
/// wakeup signals, in which case it generally is not necessary to define
/// @suspend_noirq().
///
/// @resume_noirq: Prepare for the execution of @resume() by carrying out any
/// operations required for resuming the device that might be racing with
/// its driver's interrupt handler, which is guaranteed not to run while
/// @resume_noirq() is being executed.
///
/// @freeze_noirq: Complete the actions started by @freeze().  Carry out any
/// additional operations required for freezing the device that might be
/// racing with its driver's interrupt handler, which is guaranteed not to
/// run while @freeze_noirq() is being executed.
/// The power state of the device should not be changed by either @freeze(),
/// or @freeze_late(), or @freeze_noirq() and it should not be configured to
/// signal system wakeup by any of these callbacks.
///
/// @thaw_noirq: Prepare for the execution of @thaw() by carrying out any
/// operations required for thawing the device that might be racing with its
/// driver's interrupt handler, which is guaranteed not to run while
/// @thaw_noirq() is being executed.
///
/// @poweroff_noirq: Complete the actions started by @poweroff().  Analogous to
/// @suspend_noirq(), but it need not save the device's settings in memory.
///
/// @restore_noirq: Prepare for the execution of @restore() by carrying out any
/// operations required for thawing the device that might be racing with its
/// driver's interrupt handler, which is guaranteed not to run while
/// @restore_noirq() is being executed.  Analogous to @resume_noirq().
///
/// All of the above callbacks, except for @complete(), return error codes.
/// However, the error codes returned by the resume operations, @resume(),
/// @thaw(), @restore(), @resume_noirq(), @thaw_noirq(), and @restore_noirq(), do
/// not cause the PM core to abort the resume transition during which they are
/// returned.  The error codes returned in those cases are only printed by the PM
/// core to the system logs for debugging purposes.  Still, it is recommended
/// that drivers only return error codes from their resume methods in case of an
/// unrecoverable failure (i.e. when the device being handled refuses to resume
/// and becomes unusable) to allow us to modify the PM core in the future, so
/// that it can avoid attempting to handle devices that failed to resume and
/// their children.
///
/// It is allowed to unregister devices while the above callbacks are being
/// executed.  However, a callback routine must NOT try to unregister the device
/// it was called for, although it may unregister children of that device (for
/// example, if it detects that a child was unplugged while the system was
/// asleep).
///
/// Refer to Documentation/power/devices.txt for more information about the role
/// of the above callbacks in the system suspend process.
///
/// There also are callbacks related to runtime power management of devices.
/// Again, these callbacks are executed by the PM core only for subsystems
/// (PM domains, device types, classes and bus types) and the subsystem-level
/// callbacks are supposed to invoke the driver callbacks.  Moreover, the exact
/// actions to be performed by a device driver's callbacks generally depend on
/// the platform and subsystem the device belongs to.
///
/// @runtime_suspend: Prepare the device for a condition in which it won't be
/// able to communicate with the CPU(s) and RAM due to power management.
/// This need not mean that the device should be put into a low-power state.
/// For example, if the device is behind a link which is about to be turned
/// off, the device may remain at full power.  If the device does go to low
/// power and is capable of generating runtime wakeup events, remote wakeup
/// (i.e., a hardware mechanism allowing the device to request a change of
/// its power state via an interrupt) should be enabled for it.
///
/// @runtime_resume: Put the device into the fully active state in response to a
/// wakeup event generated by hardware or at the request of software.  If
/// necessary, put the device into the full-power state and restore its
/// registers, so that it is fully operational.
///
/// @runtime_idle: Device appears to be inactive and it might be put into a
/// low-power state if all of the necessary conditions are satisfied.
/// Check these conditions, and return 0 if it's appropriate to let the PM
/// core queue a suspend request for the device.
///
/// Refer to Documentation/power/runtime_pm.txt for more information about the
/// role of the above callbacks in device runtime power management.
///
#[repr(C)]
#[derive(Copy)]
pub struct dev_pm_ops {
    pub prepare: ::std::option::Option<unsafe extern "C" fn(dev: *mut device)
                                           -> ::std::os::raw::c_int>,
    pub complete: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                 *mut device)>,
    pub suspend: ::std::option::Option<unsafe extern "C" fn(dev: *mut device)
                                           -> ::std::os::raw::c_int>,
    pub resume: ::std::option::Option<unsafe extern "C" fn(dev: *mut device)
                                          -> ::std::os::raw::c_int>,
    pub freeze: ::std::option::Option<unsafe extern "C" fn(dev: *mut device)
                                          -> ::std::os::raw::c_int>,
    pub thaw: ::std::option::Option<unsafe extern "C" fn(dev: *mut device)
                                        -> ::std::os::raw::c_int>,
    pub poweroff: ::std::option::Option<unsafe extern "C" fn(dev: *mut device)
                                            -> ::std::os::raw::c_int>,
    pub restore: ::std::option::Option<unsafe extern "C" fn(dev: *mut device)
                                           -> ::std::os::raw::c_int>,
    pub suspend_late: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                     *mut device)
                                                -> ::std::os::raw::c_int>,
    pub resume_early: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                     *mut device)
                                                -> ::std::os::raw::c_int>,
    pub freeze_late: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                    *mut device)
                                               -> ::std::os::raw::c_int>,
    pub thaw_early: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                   *mut device)
                                              -> ::std::os::raw::c_int>,
    pub poweroff_late: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                      *mut device)
                                                 -> ::std::os::raw::c_int>,
    pub restore_early: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                      *mut device)
                                                 -> ::std::os::raw::c_int>,
    pub suspend_noirq: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                      *mut device)
                                                 -> ::std::os::raw::c_int>,
    pub resume_noirq: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                     *mut device)
                                                -> ::std::os::raw::c_int>,
    pub freeze_noirq: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                     *mut device)
                                                -> ::std::os::raw::c_int>,
    pub thaw_noirq: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                   *mut device)
                                              -> ::std::os::raw::c_int>,
    pub poweroff_noirq: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                       *mut device)
                                                  -> ::std::os::raw::c_int>,
    pub restore_noirq: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                      *mut device)
                                                 -> ::std::os::raw::c_int>,
    pub runtime_suspend: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                        *mut device)
                                                   -> ::std::os::raw::c_int>,
    pub runtime_resume: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                       *mut device)
                                                  -> ::std::os::raw::c_int>,
    pub runtime_idle: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                     *mut device)
                                                -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_dev_pm_ops() {
    assert_eq!(::std::mem::size_of::<dev_pm_ops>() , 184usize , concat ! (
               "Size of: " , stringify ! ( dev_pm_ops ) ));
    assert_eq! (::std::mem::align_of::<dev_pm_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dev_pm_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . prepare as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( prepare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . complete as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( complete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . suspend as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( suspend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . resume as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( resume ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . freeze as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( freeze ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . thaw as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( thaw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . poweroff as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( poweroff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . restore as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( restore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . suspend_late as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( suspend_late ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . resume_early as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( resume_early ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . freeze_late as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( freeze_late ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . thaw_early as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( thaw_early ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . poweroff_late as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( poweroff_late ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . restore_early as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( restore_early ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . suspend_noirq as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( suspend_noirq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . resume_noirq as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( resume_noirq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . freeze_noirq as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( freeze_noirq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . thaw_noirq as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( thaw_noirq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . poweroff_noirq as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( poweroff_noirq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . restore_noirq as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( restore_noirq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . runtime_suspend as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( runtime_suspend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . runtime_resume as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( runtime_resume ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_ops ) ) . runtime_idle as * const
                _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_ops ) , "::" ,
                stringify ! ( runtime_idle ) ));
}
impl Clone for dev_pm_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Device run-time power management status.
///
/// These status labels are used internally by the PM core to indicate the
/// current status of a device with respect to the PM core operations.  They do
/// not reflect the actual power state of the device or its status as seen by the
/// driver.
///
/// RPM_ACTIVE		Device is fully operational.  Indicates that the device
/// bus type's ->runtime_resume() callback has completed
/// successfully.
///
/// RPM_SUSPENDED	Device bus type's ->runtime_suspend() callback has
/// completed successfully.  The device is regarded as
/// suspended.
///
/// RPM_RESUMING		Device bus type's ->runtime_resume() callback is being
/// executed.
///
/// RPM_SUSPENDING	Device bus type's ->runtime_suspend() callback is being
/// executed.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3,
}
#[repr(u32)]
/// Device run-time power management request types.
///
/// RPM_REQ_NONE		Do nothing.
///
/// RPM_REQ_IDLE		Run the device bus type's ->runtime_idle() callback
///
/// RPM_REQ_SUSPEND	Run the device bus type's ->runtime_suspend() callback
///
/// RPM_REQ_AUTOSUSPEND	Same as RPM_REQ_SUSPEND, but not until the device has
/// been inactive for as long as power.autosuspend_delay
///
/// RPM_REQ_RESUME	Run the device bus type's ->runtime_resume() callback
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wakeup_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wake_irq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_domain_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct pm_subsys_data {
    pub lock: spinlock_t,
    pub refcount: ::std::os::raw::c_uint,
    pub clock_list: list_head,
}
#[test]
fn bindgen_test_layout_pm_subsys_data() {
    assert_eq!(::std::mem::size_of::<pm_subsys_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( pm_subsys_data ) ));
    assert_eq! (::std::mem::align_of::<pm_subsys_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pm_subsys_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pm_subsys_data ) ) . lock as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pm_subsys_data ) , "::"
                , stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pm_subsys_data ) ) . refcount as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pm_subsys_data ) , "::"
                , stringify ! ( refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pm_subsys_data ) ) . clock_list as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pm_subsys_data ) , "::"
                , stringify ! ( clock_list ) ));
}
impl Clone for pm_subsys_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct dev_pm_info {
    pub power_state: pm_message_t,
    pub _bitfield_1: [u8; 2usize],
    pub lock: spinlock_t,
    pub entry: list_head,
    pub completion: completion,
    pub wakeup: *mut wakeup_source,
    pub _bitfield_2: u8,
    pub suspend_timer: timer_list,
    pub timer_expires: ::std::os::raw::c_ulong,
    pub work: work_struct,
    pub wait_queue: wait_queue_head_t,
    pub wakeirq: *mut wake_irq,
    pub usage_count: atomic_t,
    pub child_count: atomic_t,
    pub _bitfield_3: [u8; 2usize],
    pub request: rpm_request,
    pub runtime_status: rpm_status,
    pub runtime_error: ::std::os::raw::c_int,
    pub autosuspend_delay: ::std::os::raw::c_int,
    pub last_busy: ::std::os::raw::c_ulong,
    pub active_jiffies: ::std::os::raw::c_ulong,
    pub suspended_jiffies: ::std::os::raw::c_ulong,
    pub accounting_timestamp: ::std::os::raw::c_ulong,
    pub subsys_data: *mut pm_subsys_data,
    pub set_latency_tolerance: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                              *mut device,
                                                                          arg2:
                                                                              s32)>,
    pub qos: *mut dev_pm_qos,
}
#[test]
fn bindgen_test_layout_dev_pm_info() {
    assert_eq!(::std::mem::size_of::<dev_pm_info>() , 320usize , concat ! (
               "Size of: " , stringify ! ( dev_pm_info ) ));
    assert_eq! (::std::mem::align_of::<dev_pm_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dev_pm_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . power_state as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( power_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . lock as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . entry as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . completion as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( completion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . wakeup as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . suspend_timer as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( suspend_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . timer_expires as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( timer_expires ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . work as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( work ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . wait_queue as * const _
                as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( wait_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . wakeirq as * const _ as
                usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( wakeirq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . usage_count as * const
                _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( usage_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . child_count as * const
                _ as usize } , 236usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( child_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . request as * const _ as
                usize } , 244usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . runtime_status as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( runtime_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . runtime_error as *
                const _ as usize } , 252usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( runtime_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . autosuspend_delay as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( autosuspend_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . last_busy as * const _
                as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( last_busy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . active_jiffies as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( active_jiffies ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . suspended_jiffies as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( suspended_jiffies ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . accounting_timestamp as
                * const _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( accounting_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . subsys_data as * const
                _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( subsys_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . set_latency_tolerance
                as * const _ as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( set_latency_tolerance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_info ) ) . qos as * const _ as
                usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_info ) , "::" ,
                stringify ! ( qos ) ));
}
impl Clone for dev_pm_info {
    fn clone(&self) -> Self { *self }
}
impl dev_pm_info {
    #[inline]
    pub fn can_wakeup(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_can_wakeup(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn async_suspend(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_async_suspend(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn is_prepared(&self) -> bool_ {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_is_prepared(&mut self, val: bool_) {
        let mask = 4u64 as u16;
        let val = val as u8 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn is_suspended(&self) -> bool_ {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_is_suspended(&mut self, val: bool_) {
        let mask = 8u64 as u16;
        let val = val as u8 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn is_noirq_suspended(&self) -> bool_ {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_is_noirq_suspended(&mut self, val: bool_) {
        let mask = 16u64 as u16;
        let val = val as u8 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn is_late_suspended(&self) -> bool_ {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_is_late_suspended(&mut self, val: bool_) {
        let mask = 32u64 as u16;
        let val = val as u8 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ignore_children(&self) -> bool_ {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 64u64 as u16;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ignore_children(&mut self, val: bool_) {
        let mask = 64u64 as u16;
        let val = val as u8 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn early_init(&self) -> bool_ {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 128u64 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        let mask = 128u64 as u16;
        let val = val as u8 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn direct_complete(&self) -> bool_ {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 256u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_direct_complete(&mut self, val: bool_) {
        let mask = 256u64 as u16;
        let val = val as u8 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(can_wakeup: ::std::os::raw::c_uint,
                          async_suspend: ::std::os::raw::c_uint,
                          is_prepared: bool_, is_suspended: bool_,
                          is_noirq_suspended: bool_, is_late_suspended: bool_,
                          ignore_children: bool_, early_init: bool_,
                          direct_complete: bool_) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({ 0 } |
                                                     ((can_wakeup as u32 as
                                                           u16) << 0usize) &
                                                         (1u64 as u16))
                                            } |
                                                ((async_suspend as u32 as u16)
                                                     << 1usize) &
                                                    (2u64 as u16))
                                       } |
                                           ((is_prepared as u8 as u16) <<
                                                2usize) & (4u64 as u16))
                                  } |
                                      ((is_suspended as u8 as u16) << 3usize)
                                          & (8u64 as u16))
                             } |
                                 ((is_noirq_suspended as u8 as u16) << 4usize)
                                     & (16u64 as u16))
                        } |
                            ((is_late_suspended as u8 as u16) << 5usize) &
                                (32u64 as u16))
                   } |
                       ((ignore_children as u8 as u16) << 6usize) &
                           (64u64 as u16))
              } | ((early_init as u8 as u16) << 7usize) & (128u64 as u16))
         } | ((direct_complete as u8 as u16) << 8usize) & (256u64 as u16))
    }
    #[inline]
    pub fn wakeup_path(&self) -> bool_ {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_wakeup_path(&mut self, val: bool_) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_2 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn syscore(&self) -> bool_ {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_syscore(&mut self, val: bool_) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_2 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_2(wakeup_path: bool_, syscore: bool_) -> u8 {
        ({ ({ 0 } | ((wakeup_path as u8 as u8) << 0usize) & (1u64 as u8)) } |
             ((syscore as u8 as u8) << 1usize) & (2u64 as u8))
    }
    #[inline]
    pub fn disable_depth(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 7u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_disable_depth(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 7u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_3 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn idle_notification(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_idle_notification(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_3 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn request_pending(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_request_pending(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_3 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn deferred_resume(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_deferred_resume(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_3 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn run_wake(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 64u64 as u16;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_run_wake(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 64u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_3 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn runtime_auto(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 128u64 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_runtime_auto(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_3 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn no_callbacks(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 256u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_no_callbacks(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 256u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_3 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn irq_safe(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 512u64 as u16;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_irq_safe(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 512u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_3 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn use_autosuspend(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1024u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_use_autosuspend(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1024u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_3 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn timer_autosuspends(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2048u64 as u16;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_timer_autosuspends(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2048u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_3 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn memalloc_noio(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4096u64 as u16;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_memalloc_noio(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4096u64 as u16;
        let val = val as u32 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_3 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_3 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_3(disable_depth: ::std::os::raw::c_uint,
                          idle_notification: ::std::os::raw::c_uint,
                          request_pending: ::std::os::raw::c_uint,
                          deferred_resume: ::std::os::raw::c_uint,
                          run_wake: ::std::os::raw::c_uint,
                          runtime_auto: ::std::os::raw::c_uint,
                          no_callbacks: ::std::os::raw::c_uint,
                          irq_safe: ::std::os::raw::c_uint,
                          use_autosuspend: ::std::os::raw::c_uint,
                          timer_autosuspends: ::std::os::raw::c_uint,
                          memalloc_noio: ::std::os::raw::c_uint) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({
                                                          ({ 0 } |
                                                               ((disable_depth
                                                                     as u32 as
                                                                     u16) <<
                                                                    0usize) &
                                                                   (7u64 as
                                                                        u16))
                                                      } |
                                                          ((idle_notification
                                                                as u32 as u16)
                                                               << 3usize) &
                                                              (8u64 as u16))
                                                 } |
                                                     ((request_pending as u32
                                                           as u16) << 4usize)
                                                         & (16u64 as u16))
                                            } |
                                                ((deferred_resume as u32 as
                                                      u16) << 5usize) &
                                                    (32u64 as u16))
                                       } |
                                           ((run_wake as u32 as u16) <<
                                                6usize) & (64u64 as u16))
                                  } |
                                      ((runtime_auto as u32 as u16) << 7usize)
                                          & (128u64 as u16))
                             } |
                                 ((no_callbacks as u32 as u16) << 8usize) &
                                     (256u64 as u16))
                        } |
                            ((irq_safe as u32 as u16) << 9usize) &
                                (512u64 as u16))
                   } |
                       ((use_autosuspend as u32 as u16) << 10usize) &
                           (1024u64 as u16))
              } |
                  ((timer_autosuspends as u32 as u16) << 11usize) &
                      (2048u64 as u16))
         } | ((memalloc_noio as u32 as u16) << 12usize) & (4096u64 as u16))
    }
}
extern "C" {
    pub fn update_pm_runtime_accounting(dev: *mut device);
}
extern "C" {
    pub fn dev_pm_get_subsys_data(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dev_pm_put_subsys_data(dev: *mut device);
}
#[repr(C)]
#[derive(Copy)]
pub struct dev_pm_domain {
    pub ops: dev_pm_ops,
    pub detach: ::std::option::Option<unsafe extern "C" fn(dev: *mut device,
                                                           power_off: bool_)>,
    pub activate: ::std::option::Option<unsafe extern "C" fn(dev: *mut device)
                                            -> ::std::os::raw::c_int>,
    pub sync: ::std::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub dismiss: ::std::option::Option<unsafe extern "C" fn(dev:
                                                                *mut device)>,
}
#[test]
fn bindgen_test_layout_dev_pm_domain() {
    assert_eq!(::std::mem::size_of::<dev_pm_domain>() , 216usize , concat ! (
               "Size of: " , stringify ! ( dev_pm_domain ) ));
    assert_eq! (::std::mem::align_of::<dev_pm_domain>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dev_pm_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_domain ) ) . ops as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_domain ) , "::"
                , stringify ! ( ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_domain ) ) . detach as * const _
                as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_domain ) , "::"
                , stringify ! ( detach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_domain ) ) . activate as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_domain ) , "::"
                , stringify ! ( activate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_domain ) ) . sync as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_domain ) , "::"
                , stringify ! ( sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dev_pm_domain ) ) . dismiss as * const _
                as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( dev_pm_domain ) , "::"
                , stringify ! ( dismiss ) ));
}
impl Clone for dev_pm_domain {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn device_pm_lock();
}
extern "C" {
    pub fn dpm_resume_start(state: pm_message_t);
}
extern "C" {
    pub fn dpm_resume_end(state: pm_message_t);
}
extern "C" {
    pub fn dpm_resume_noirq(state: pm_message_t);
}
extern "C" {
    pub fn dpm_resume_early(state: pm_message_t);
}
extern "C" {
    pub fn dpm_resume(state: pm_message_t);
}
extern "C" {
    pub fn dpm_complete(state: pm_message_t);
}
extern "C" {
    pub fn device_pm_unlock();
}
extern "C" {
    pub fn dpm_suspend_end(state: pm_message_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dpm_suspend_start(state: pm_message_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dpm_suspend_noirq(state: pm_message_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dpm_suspend_late(state: pm_message_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dpm_suspend(state: pm_message_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dpm_prepare(state: pm_message_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __suspend_report_result(function: *const ::std::os::raw::c_char,
                                   fn_: *mut ::std::os::raw::c_void,
                                   ret: ::std::os::raw::c_int);
}
extern "C" {
    pub fn device_pm_wait_for_dev(sub: *mut device, dev: *mut device)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dpm_for_each_dev(data: *mut ::std::os::raw::c_void,
                            fn_:
                                ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                               *mut device,
                                                                           arg2:
                                                                               *mut ::std::os::raw::c_void)>);
}
extern "C" {
    pub fn pm_generic_prepare(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_suspend_late(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_suspend_noirq(dev: *mut device)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_suspend(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_resume_early(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_resume_noirq(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_resume(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_freeze_noirq(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_freeze_late(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_freeze(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_thaw_noirq(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_thaw_early(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_thaw(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_restore_noirq(dev: *mut device)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_restore_early(dev: *mut device)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_restore(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_poweroff_noirq(dev: *mut device)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_poweroff_late(dev: *mut device)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_poweroff(dev: *mut device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pm_generic_complete(dev: *mut device);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum dpm_order {
    DPM_ORDER_NONE = 0,
    DPM_ORDER_DEV_AFTER_PARENT = 1,
    DPM_ORDER_PARENT_BEFORE_DEV = 2,
    DPM_ORDER_DEV_LAST = 3,
}
extern "C" {
    #[link_name = "x86_cpu_to_node_map"]
    pub static mut x86_cpu_to_node_map: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "x86_cpu_to_node_map_early_ptr"]
    pub static mut x86_cpu_to_node_map_early_ptr: *mut ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "x86_cpu_to_node_map_early_map"]
    pub static mut x86_cpu_to_node_map_early_map:
               [::std::os::raw::c_int; 0usize];
}
extern "C" {
    #[link_name = "node_to_cpumask_map"]
    pub static mut node_to_cpumask_map: [cpumask_var_t; 64usize];
}
extern "C" {
    pub fn setup_node_to_cpumask_map();
}
extern "C" {
    pub fn __node_distance(arg1: ::std::os::raw::c_int,
                           arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cpu_coregroup_mask(cpu: ::std::os::raw::c_int) -> *const cpumask;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pci_bus {
    _unused: [u8; 0],
}
extern "C" {
    pub fn x86_pci_root_bus_node(bus: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn x86_pci_root_bus_resources(bus: ::std::os::raw::c_int,
                                      resources: *mut list_head);
}
extern "C" {
    #[link_name = "numa_off"]
    pub static mut numa_off: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__apicid_to_node"]
    pub static mut __apicid_to_node: [s16; 32768usize];
}
extern "C" {
    #[link_name = "numa_nodes_parsed"]
    pub static mut numa_nodes_parsed: nodemask_t;
}
extern "C" {
    pub fn numa_add_memblk(nodeid: ::std::os::raw::c_int, start: u64,
                           end: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_set_distance(from: ::std::os::raw::c_int,
                             to: ::std::os::raw::c_int,
                             distance: ::std::os::raw::c_int);
}
extern "C" {
    pub fn numa_cpu_node(cpu: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_set_node(cpu: ::std::os::raw::c_int,
                         node: ::std::os::raw::c_int);
}
extern "C" {
    pub fn numa_clear_node(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn init_cpu_to_node();
}
extern "C" {
    pub fn numa_add_cpu(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn numa_remove_cpu(cpu: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Copy)]
pub struct mm_context_t {
    pub ldt: *mut ldt_struct,
    pub ia32_compat: ::std::os::raw::c_ushort,
    pub lock: mutex,
    pub vdso: *mut ::std::os::raw::c_void,
    pub perf_rdpmc_allowed: atomic_t,
}
#[test]
fn bindgen_test_layout_mm_context_t() {
    assert_eq!(::std::mem::size_of::<mm_context_t>() , 72usize , concat ! (
               "Size of: " , stringify ! ( mm_context_t ) ));
    assert_eq! (::std::mem::align_of::<mm_context_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mm_context_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mm_context_t ) ) . ldt as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mm_context_t ) , "::" ,
                stringify ! ( ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mm_context_t ) ) . ia32_compat as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mm_context_t ) , "::" ,
                stringify ! ( ia32_compat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mm_context_t ) ) . lock as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mm_context_t ) , "::" ,
                stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mm_context_t ) ) . vdso as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( mm_context_t ) , "::" ,
                stringify ! ( vdso ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mm_context_t ) ) . perf_rdpmc_allowed as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( mm_context_t ) , "::" ,
                stringify ! ( perf_rdpmc_allowed ) ));
}
impl Clone for mm_context_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn leave_mm(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn early_ioremap(phys_addr: resource_size_t,
                         size: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_memremap(phys_addr: resource_size_t,
                          size: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_iounmap(addr: *mut ::std::os::raw::c_void,
                         size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn early_memunmap(addr: *mut ::std::os::raw::c_void,
                          size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn early_ioremap_shutdown();
}
extern "C" {
    pub fn early_ioremap_init();
}
extern "C" {
    pub fn early_ioremap_setup();
}
extern "C" {
    pub fn early_ioremap_reset();
}
extern "C" {
    /// ioremap     -   map bus memory into CPU space
/// @offset:    bus address of the memory
/// @size:      size of the resource to map
///
/// ioremap performs a platform specific sequence of operations to
/// make bus memory CPU accessible via the readb/readw/readl/writeb/
/// writew/writel functions and the other mmio helpers. The returned
/// address is not guaranteed to be usable directly as a virtual
/// address.
///
/// If the area you are trying to map is a PCI BAR you should have a
/// look at pci_iomap().
    pub fn ioremap_nocache(offset: resource_size_t,
                           size: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioremap_uc(offset: resource_size_t, size: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioremap_cache(offset: resource_size_t,
                         size: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioremap_prot(offset: resource_size_t,
                        size: ::std::os::raw::c_ulong,
                        prot_val: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn iounmap(addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn set_iounmap_nonlazy();
}
extern "C" {
    pub fn ioread8(arg1: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ioread16(arg1: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ioread16be(arg1: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ioread32(arg1: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ioread32be(arg1: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn iowrite8(arg1: u8, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite16(arg1: u16, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite16be(arg1: u16, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite32(arg1: u32, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite32be(arg1: u32, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ioread8_rep(port: *mut ::std::os::raw::c_void,
                       buf: *mut ::std::os::raw::c_void,
                       count: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ioread16_rep(port: *mut ::std::os::raw::c_void,
                        buf: *mut ::std::os::raw::c_void,
                        count: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ioread32_rep(port: *mut ::std::os::raw::c_void,
                        buf: *mut ::std::os::raw::c_void,
                        count: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn iowrite8_rep(port: *mut ::std::os::raw::c_void,
                        buf: *const ::std::os::raw::c_void,
                        count: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn iowrite16_rep(port: *mut ::std::os::raw::c_void,
                         buf: *const ::std::os::raw::c_void,
                         count: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn iowrite32_rep(port: *mut ::std::os::raw::c_void,
                         buf: *const ::std::os::raw::c_void,
                         count: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ioport_map(port: ::std::os::raw::c_ulong,
                      nr: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioport_unmap(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pci_iounmap(dev: *mut pci_dev, arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pci_iomap(dev: *mut pci_dev, bar: ::std::os::raw::c_int,
                     max: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pci_iomap_range(dev: *mut pci_dev, bar: ::std::os::raw::c_int,
                           offset: ::std::os::raw::c_ulong,
                           maxlen: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn native_io_delay();
}
extern "C" {
    #[link_name = "io_delay_type"]
    pub static mut io_delay_type: ::std::os::raw::c_int;
}
extern "C" {
    pub fn io_delay_init();
}
extern "C" {
    pub fn xlate_dev_mem_ptr(phys: phys_addr_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn unxlate_dev_mem_ptr(phys: phys_addr_t,
                               addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ioremap_change_attr(vaddr: ::std::os::raw::c_ulong,
                               size: ::std::os::raw::c_ulong,
                               pcm: page_cache_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ioremap_wc(offset: resource_size_t, size: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioremap_wt(offset: resource_size_t, size: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn is_early_ioremap_ptep(ptep: *mut pte_t) -> bool_;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xen_domain_type {
    XEN_NATIVE = 0,
    XEN_PV_DOMAIN = 1,
    XEN_HVM_DOMAIN = 2,
}
extern "C" {
    #[link_name = "xen_domain_type"]
    pub static mut xen_domain_type: xen_domain_type;
}
pub type xen_pfn_t = ::std::os::raw::c_ulong;
pub type xen_ulong_t = ::std::os::raw::c_ulong;
pub type xen_long_t = ::std::os::raw::c_long;
pub type __guest_handle_uchar = *mut ::std::os::raw::c_uchar;
pub type __guest_handle_uint = *mut ::std::os::raw::c_uint;
pub type __guest_handle_char = *mut ::std::os::raw::c_char;
pub type __guest_handle_int = *mut ::std::os::raw::c_int;
pub type __guest_handle_void = *mut ::std::os::raw::c_void;
pub type __guest_handle_uint64_t = *mut u64;
pub type __guest_handle_uint32_t = *mut u32;
pub type __guest_handle_xen_pfn_t = *mut xen_pfn_t;
pub type __guest_handle_xen_ulong_t = *mut xen_ulong_t;
#[repr(C)]
#[derive(Copy)]
pub struct trap_info {
    pub vector: u8,
    pub flags: u8,
    pub cs: u16,
    pub address: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_trap_info() {
    assert_eq!(::std::mem::size_of::<trap_info>() , 16usize , concat ! (
               "Size of: " , stringify ! ( trap_info ) ));
    assert_eq! (::std::mem::align_of::<trap_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( trap_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trap_info ) ) . vector as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( trap_info ) , "::" ,
                stringify ! ( vector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trap_info ) ) . flags as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( trap_info ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trap_info ) ) . cs as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( trap_info ) , "::" ,
                stringify ! ( cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trap_info ) ) . address as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( trap_info ) , "::" ,
                stringify ! ( address ) ));
}
impl Clone for trap_info {
    fn clone(&self) -> Self { *self }
}
pub type __guest_handle_trap_info = *mut trap_info;
#[repr(C)]
#[derive(Copy)]
pub struct arch_shared_info {
    pub max_pfn: ::std::os::raw::c_ulong,
    pub pfn_to_mfn_frame_list_list: ::std::os::raw::c_ulong,
    pub nmi_reason: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_arch_shared_info() {
    assert_eq!(::std::mem::size_of::<arch_shared_info>() , 24usize , concat !
               ( "Size of: " , stringify ! ( arch_shared_info ) ));
    assert_eq! (::std::mem::align_of::<arch_shared_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( arch_shared_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arch_shared_info ) ) . max_pfn as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( arch_shared_info ) ,
                "::" , stringify ! ( max_pfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arch_shared_info ) ) .
                pfn_to_mfn_frame_list_list as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( arch_shared_info ) ,
                "::" , stringify ! ( pfn_to_mfn_frame_list_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arch_shared_info ) ) . nmi_reason as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( arch_shared_info ) ,
                "::" , stringify ! ( nmi_reason ) ));
}
impl Clone for arch_shared_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct iret_context {
    pub rax: u64,
    pub r11: u64,
    pub rcx: u64,
    pub flags: u64,
    pub rip: u64,
    pub cs: u64,
    pub rflags: u64,
    pub rsp: u64,
    pub ss: u64,
}
#[test]
fn bindgen_test_layout_iret_context() {
    assert_eq!(::std::mem::size_of::<iret_context>() , 72usize , concat ! (
               "Size of: " , stringify ! ( iret_context ) ));
    assert_eq! (::std::mem::align_of::<iret_context>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( iret_context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iret_context ) ) . rax as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( iret_context ) , "::" ,
                stringify ! ( rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iret_context ) ) . r11 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( iret_context ) , "::" ,
                stringify ! ( r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iret_context ) ) . rcx as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( iret_context ) , "::" ,
                stringify ! ( rcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iret_context ) ) . flags as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( iret_context ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iret_context ) ) . rip as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( iret_context ) , "::" ,
                stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iret_context ) ) . cs as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( iret_context ) , "::" ,
                stringify ! ( cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iret_context ) ) . rflags as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( iret_context ) , "::" ,
                stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iret_context ) ) . rsp as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( iret_context ) , "::" ,
                stringify ! ( rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iret_context ) ) . ss as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( iret_context ) , "::" ,
                stringify ! ( ss ) ));
}
impl Clone for iret_context {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct cpu_user_regs {
    pub r15: u64,
    pub r14: u64,
    pub r13: u64,
    pub r12: u64,
    pub __bindgen_anon_1: cpu_user_regs__bindgen_ty_1,
    pub __bindgen_anon_2: cpu_user_regs__bindgen_ty_2,
    pub r11: u64,
    pub r10: u64,
    pub r9: u64,
    pub r8: u64,
    pub __bindgen_anon_3: cpu_user_regs__bindgen_ty_3,
    pub __bindgen_anon_4: cpu_user_regs__bindgen_ty_4,
    pub __bindgen_anon_5: cpu_user_regs__bindgen_ty_5,
    pub __bindgen_anon_6: cpu_user_regs__bindgen_ty_6,
    pub __bindgen_anon_7: cpu_user_regs__bindgen_ty_7,
    pub error_code: u32,
    pub entry_vector: u32,
    pub __bindgen_anon_8: cpu_user_regs__bindgen_ty_8,
    pub cs: u16,
    pub _pad0: [u16; 1usize],
    pub saved_upcall_mask: u8,
    pub _pad1: [u8; 3usize],
    pub __bindgen_anon_9: cpu_user_regs__bindgen_ty_9,
    pub __bindgen_anon_10: cpu_user_regs__bindgen_ty_10,
    pub ss: u16,
    pub _pad2: [u16; 3usize],
    pub es: u16,
    pub _pad3: [u16; 3usize],
    pub ds: u16,
    pub _pad4: [u16; 3usize],
    pub fs: u16,
    pub _pad5: [u16; 3usize],
    pub gs: u16,
    pub _pad6: [u16; 3usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct cpu_user_regs__bindgen_ty_1 {
    pub rbp: __BindgenUnionField<u64>,
    pub ebp: __BindgenUnionField<u64>,
    pub _ebp: __BindgenUnionField<u32>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<cpu_user_regs__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( cpu_user_regs__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<cpu_user_regs__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( cpu_user_regs__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_1 ) ) . rbp as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_1 ) , "::" , stringify ! ( rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_1 ) ) . ebp as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_1 ) , "::" , stringify ! ( ebp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_1 ) ) . _ebp as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_1 ) , "::" , stringify ! ( _ebp )
                ));
}
impl Clone for cpu_user_regs__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct cpu_user_regs__bindgen_ty_2 {
    pub rbx: __BindgenUnionField<u64>,
    pub ebx: __BindgenUnionField<u64>,
    pub _ebx: __BindgenUnionField<u32>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<cpu_user_regs__bindgen_ty_2>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( cpu_user_regs__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<cpu_user_regs__bindgen_ty_2>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( cpu_user_regs__bindgen_ty_2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_2 ) ) . rbx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_2 ) , "::" , stringify ! ( rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_2 ) ) . ebx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_2 ) , "::" , stringify ! ( ebx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_2 ) ) . _ebx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_2 ) , "::" , stringify ! ( _ebx )
                ));
}
impl Clone for cpu_user_regs__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct cpu_user_regs__bindgen_ty_3 {
    pub rax: __BindgenUnionField<u64>,
    pub eax: __BindgenUnionField<u64>,
    pub _eax: __BindgenUnionField<u32>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<cpu_user_regs__bindgen_ty_3>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( cpu_user_regs__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<cpu_user_regs__bindgen_ty_3>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( cpu_user_regs__bindgen_ty_3 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_3 ) ) . rax as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_3 ) , "::" , stringify ! ( rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_3 ) ) . eax as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_3 ) , "::" , stringify ! ( eax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_3 ) ) . _eax as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_3 ) , "::" , stringify ! ( _eax )
                ));
}
impl Clone for cpu_user_regs__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct cpu_user_regs__bindgen_ty_4 {
    pub rcx: __BindgenUnionField<u64>,
    pub ecx: __BindgenUnionField<u64>,
    pub _ecx: __BindgenUnionField<u32>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<cpu_user_regs__bindgen_ty_4>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( cpu_user_regs__bindgen_ty_4 ) ));
    assert_eq! (::std::mem::align_of::<cpu_user_regs__bindgen_ty_4>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( cpu_user_regs__bindgen_ty_4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_4 ) ) . rcx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_4 ) , "::" , stringify ! ( rcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_4 ) ) . ecx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_4 ) , "::" , stringify ! ( ecx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_4 ) ) . _ecx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_4 ) , "::" , stringify ! ( _ecx )
                ));
}
impl Clone for cpu_user_regs__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct cpu_user_regs__bindgen_ty_5 {
    pub rdx: __BindgenUnionField<u64>,
    pub edx: __BindgenUnionField<u64>,
    pub _edx: __BindgenUnionField<u32>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<cpu_user_regs__bindgen_ty_5>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( cpu_user_regs__bindgen_ty_5 ) ));
    assert_eq! (::std::mem::align_of::<cpu_user_regs__bindgen_ty_5>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( cpu_user_regs__bindgen_ty_5 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_5 ) ) . rdx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_5 ) , "::" , stringify ! ( rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_5 ) ) . edx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_5 ) , "::" , stringify ! ( edx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_5 ) ) . _edx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_5 ) , "::" , stringify ! ( _edx )
                ));
}
impl Clone for cpu_user_regs__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct cpu_user_regs__bindgen_ty_6 {
    pub rsi: __BindgenUnionField<u64>,
    pub esi: __BindgenUnionField<u64>,
    pub _esi: __BindgenUnionField<u32>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<cpu_user_regs__bindgen_ty_6>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( cpu_user_regs__bindgen_ty_6 ) ));
    assert_eq! (::std::mem::align_of::<cpu_user_regs__bindgen_ty_6>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( cpu_user_regs__bindgen_ty_6 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_6 ) ) . rsi as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_6 ) , "::" , stringify ! ( rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_6 ) ) . esi as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_6 ) , "::" , stringify ! ( esi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_6 ) ) . _esi as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_6 ) , "::" , stringify ! ( _esi )
                ));
}
impl Clone for cpu_user_regs__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct cpu_user_regs__bindgen_ty_7 {
    pub rdi: __BindgenUnionField<u64>,
    pub edi: __BindgenUnionField<u64>,
    pub _edi: __BindgenUnionField<u32>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<cpu_user_regs__bindgen_ty_7>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( cpu_user_regs__bindgen_ty_7 ) ));
    assert_eq! (::std::mem::align_of::<cpu_user_regs__bindgen_ty_7>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( cpu_user_regs__bindgen_ty_7 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_7 ) ) . rdi as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_7 ) , "::" , stringify ! ( rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_7 ) ) . edi as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_7 ) , "::" , stringify ! ( edi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_7 ) ) . _edi as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_7 ) , "::" , stringify ! ( _edi )
                ));
}
impl Clone for cpu_user_regs__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct cpu_user_regs__bindgen_ty_8 {
    pub rip: __BindgenUnionField<u64>,
    pub eip: __BindgenUnionField<u64>,
    pub _eip: __BindgenUnionField<u32>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<cpu_user_regs__bindgen_ty_8>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( cpu_user_regs__bindgen_ty_8 ) ));
    assert_eq! (::std::mem::align_of::<cpu_user_regs__bindgen_ty_8>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( cpu_user_regs__bindgen_ty_8 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_8 ) ) . rip as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_8 ) , "::" , stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_8 ) ) . eip as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_8 ) , "::" , stringify ! ( eip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_8 ) ) . _eip as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_8 ) , "::" , stringify ! ( _eip )
                ));
}
impl Clone for cpu_user_regs__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct cpu_user_regs__bindgen_ty_9 {
    pub rflags: __BindgenUnionField<u64>,
    pub eflags: __BindgenUnionField<u64>,
    pub _eflags: __BindgenUnionField<u32>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<cpu_user_regs__bindgen_ty_9>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( cpu_user_regs__bindgen_ty_9 ) ));
    assert_eq! (::std::mem::align_of::<cpu_user_regs__bindgen_ty_9>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( cpu_user_regs__bindgen_ty_9 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_9 ) ) . rflags
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_9 ) , "::" , stringify ! ( rflags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_9 ) ) . eflags
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_9 ) , "::" , stringify ! ( eflags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_9 ) ) . _eflags
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_9 ) , "::" , stringify ! ( _eflags )
                ));
}
impl Clone for cpu_user_regs__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct cpu_user_regs__bindgen_ty_10 {
    pub rsp: __BindgenUnionField<u64>,
    pub esp: __BindgenUnionField<u64>,
    pub _esp: __BindgenUnionField<u32>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_cpu_user_regs__bindgen_ty_10() {
    assert_eq!(::std::mem::size_of::<cpu_user_regs__bindgen_ty_10>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( cpu_user_regs__bindgen_ty_10 ) ));
    assert_eq! (::std::mem::align_of::<cpu_user_regs__bindgen_ty_10>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( cpu_user_regs__bindgen_ty_10 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_10 ) ) . rsp as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_10 ) , "::" , stringify ! ( rsp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_10 ) ) . esp as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_10 ) , "::" , stringify ! ( esp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs__bindgen_ty_10 ) ) . _esp
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cpu_user_regs__bindgen_ty_10 ) , "::" , stringify ! ( _esp )
                ));
}
impl Clone for cpu_user_regs__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_cpu_user_regs() {
    assert_eq!(::std::mem::size_of::<cpu_user_regs>() , 200usize , concat ! (
               "Size of: " , stringify ! ( cpu_user_regs ) ));
    assert_eq! (::std::mem::align_of::<cpu_user_regs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpu_user_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . r15 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . r14 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . r13 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . r12 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . r11 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . r10 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . r9 as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . r8 as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . error_code as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( error_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . entry_vector as *
                const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( entry_vector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . cs as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . _pad0 as * const _ as
                usize } , 138usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( _pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . saved_upcall_mask as
                * const _ as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( saved_upcall_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . _pad1 as * const _ as
                usize } , 141usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( _pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . ss as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . _pad2 as * const _ as
                usize } , 162usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( _pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . es as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . _pad3 as * const _ as
                usize } , 170usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( _pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . ds as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . _pad4 as * const _ as
                usize } , 178usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( _pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . fs as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . _pad5 as * const _ as
                usize } , 186usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( _pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . gs as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_user_regs ) ) . _pad6 as * const _ as
                usize } , 194usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_user_regs ) , "::"
                , stringify ! ( _pad6 ) ));
}
impl Clone for cpu_user_regs {
    fn clone(&self) -> Self { *self }
}
pub type __guest_handle_cpu_user_regs = *mut cpu_user_regs;
#[repr(C)]
#[derive(Copy)]
pub struct arch_vcpu_info {
    pub cr2: ::std::os::raw::c_ulong,
    pub pad: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_arch_vcpu_info() {
    assert_eq!(::std::mem::size_of::<arch_vcpu_info>() , 16usize , concat ! (
               "Size of: " , stringify ! ( arch_vcpu_info ) ));
    assert_eq! (::std::mem::align_of::<arch_vcpu_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( arch_vcpu_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arch_vcpu_info ) ) . cr2 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( arch_vcpu_info ) , "::"
                , stringify ! ( cr2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arch_vcpu_info ) ) . pad as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( arch_vcpu_info ) , "::"
                , stringify ! ( pad ) ));
}
impl Clone for arch_vcpu_info {
    fn clone(&self) -> Self { *self }
}
pub type xen_callback_t = ::std::os::raw::c_ulong;
#[repr(C, packed)]
#[derive(Copy)]
pub struct pvclock_vcpu_time_info {
    pub version: u32,
    pub pad0: u32,
    pub tsc_timestamp: u64,
    pub system_time: u64,
    pub tsc_to_system_mul: u32,
    pub tsc_shift: s8,
    pub flags: u8,
    pub pad: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_pvclock_vcpu_time_info() {
    assert_eq!(::std::mem::size_of::<pvclock_vcpu_time_info>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( pvclock_vcpu_time_info )
               ));
    assert_eq! (::std::mem::align_of::<pvclock_vcpu_time_info>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( pvclock_vcpu_time_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pvclock_vcpu_time_info ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pvclock_vcpu_time_info
                ) , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pvclock_vcpu_time_info ) ) . pad0 as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pvclock_vcpu_time_info
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pvclock_vcpu_time_info ) ) .
                tsc_timestamp as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pvclock_vcpu_time_info
                ) , "::" , stringify ! ( tsc_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pvclock_vcpu_time_info ) ) . system_time
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pvclock_vcpu_time_info
                ) , "::" , stringify ! ( system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pvclock_vcpu_time_info ) ) .
                tsc_to_system_mul as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! ( pvclock_vcpu_time_info
                ) , "::" , stringify ! ( tsc_to_system_mul ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pvclock_vcpu_time_info ) ) . tsc_shift as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( pvclock_vcpu_time_info
                ) , "::" , stringify ! ( tsc_shift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pvclock_vcpu_time_info ) ) . flags as *
                const _ as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( pvclock_vcpu_time_info
                ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pvclock_vcpu_time_info ) ) . pad as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( pvclock_vcpu_time_info
                ) , "::" , stringify ! ( pad ) ));
}
impl Clone for pvclock_vcpu_time_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct pvclock_wall_clock {
    pub version: u32,
    pub sec: u32,
    pub nsec: u32,
}
#[test]
fn bindgen_test_layout_pvclock_wall_clock() {
    assert_eq!(::std::mem::size_of::<pvclock_wall_clock>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( pvclock_wall_clock ) ));
    assert_eq! (::std::mem::align_of::<pvclock_wall_clock>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( pvclock_wall_clock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pvclock_wall_clock ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pvclock_wall_clock ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pvclock_wall_clock ) ) . sec as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pvclock_wall_clock ) ,
                "::" , stringify ! ( sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pvclock_wall_clock ) ) . nsec as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pvclock_wall_clock ) ,
                "::" , stringify ! ( nsec ) ));
}
impl Clone for pvclock_wall_clock {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct vcpu_guest_context {
    pub fpu_ctxt: vcpu_guest_context__bindgen_ty_1,
    pub flags: ::std::os::raw::c_ulong,
    pub user_regs: cpu_user_regs,
    pub trap_ctxt: [trap_info; 256usize],
    pub ldt_base: ::std::os::raw::c_ulong,
    pub ldt_ents: ::std::os::raw::c_ulong,
    pub gdt_frames: [::std::os::raw::c_ulong; 16usize],
    pub gdt_ents: ::std::os::raw::c_ulong,
    pub kernel_ss: ::std::os::raw::c_ulong,
    pub kernel_sp: ::std::os::raw::c_ulong,
    pub ctrlreg: [::std::os::raw::c_ulong; 8usize],
    pub debugreg: [::std::os::raw::c_ulong; 8usize],
    pub event_callback_eip: ::std::os::raw::c_ulong,
    pub failsafe_callback_eip: ::std::os::raw::c_ulong,
    pub syscall_callback_eip: ::std::os::raw::c_ulong,
    pub vm_assist: ::std::os::raw::c_ulong,
    pub fs_base: u64,
    pub gs_base_kernel: u64,
    pub gs_base_user: u64,
}
#[repr(C)]
pub struct vcpu_guest_context__bindgen_ty_1 {
    pub x: [::std::os::raw::c_char; 512usize],
}
#[test]
fn bindgen_test_layout_vcpu_guest_context__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<vcpu_guest_context__bindgen_ty_1>() ,
               512usize , concat ! (
               "Size of: " , stringify ! ( vcpu_guest_context__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<vcpu_guest_context__bindgen_ty_1>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                vcpu_guest_context__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context__bindgen_ty_1 ) ) . x
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                vcpu_guest_context__bindgen_ty_1 ) , "::" , stringify ! ( x )
                ));
}
#[test]
fn bindgen_test_layout_vcpu_guest_context() {
    assert_eq!(::std::mem::size_of::<vcpu_guest_context>() , 5168usize ,
               concat ! ( "Size of: " , stringify ! ( vcpu_guest_context ) ));
    assert_eq! (::std::mem::align_of::<vcpu_guest_context>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( vcpu_guest_context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . fpu_ctxt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( fpu_ctxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . flags as * const
                _ as usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . user_regs as *
                const _ as usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( user_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . trap_ctxt as *
                const _ as usize } , 720usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( trap_ctxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . ldt_base as *
                const _ as usize } , 4816usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( ldt_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . ldt_ents as *
                const _ as usize } , 4824usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( ldt_ents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . gdt_frames as *
                const _ as usize } , 4832usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( gdt_frames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . gdt_ents as *
                const _ as usize } , 4960usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( gdt_ents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . kernel_ss as *
                const _ as usize } , 4968usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( kernel_ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . kernel_sp as *
                const _ as usize } , 4976usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( kernel_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . ctrlreg as *
                const _ as usize } , 4984usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( ctrlreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . debugreg as *
                const _ as usize } , 5048usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( debugreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) .
                event_callback_eip as * const _ as usize } , 5112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( event_callback_eip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) .
                failsafe_callback_eip as * const _ as usize } , 5120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( failsafe_callback_eip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) .
                syscall_callback_eip as * const _ as usize } , 5128usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( syscall_callback_eip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . vm_assist as *
                const _ as usize } , 5136usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( vm_assist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . fs_base as *
                const _ as usize } , 5144usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( fs_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . gs_base_kernel
                as * const _ as usize } , 5152usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( gs_base_kernel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_guest_context ) ) . gs_base_user as
                * const _ as usize } , 5160usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_guest_context ) ,
                "::" , stringify ! ( gs_base_user ) ));
}
pub type __guest_handle_vcpu_guest_context = *mut vcpu_guest_context;
#[repr(C)]
#[derive(Copy)]
pub struct mmuext_op {
    pub cmd: ::std::os::raw::c_uint,
    pub arg1: mmuext_op__bindgen_ty_1,
    pub arg2: mmuext_op__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy)]
pub struct mmuext_op__bindgen_ty_1 {
    pub mfn: __BindgenUnionField<xen_pfn_t>,
    pub linear_addr: __BindgenUnionField<::std::os::raw::c_ulong>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_mmuext_op__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<mmuext_op__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( mmuext_op__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<mmuext_op__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mmuext_op__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmuext_op__bindgen_ty_1 ) ) . mfn as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mmuext_op__bindgen_ty_1
                ) , "::" , stringify ! ( mfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmuext_op__bindgen_ty_1 ) ) . linear_addr
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mmuext_op__bindgen_ty_1
                ) , "::" , stringify ! ( linear_addr ) ));
}
impl Clone for mmuext_op__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct mmuext_op__bindgen_ty_2 {
    pub nr_ents: __BindgenUnionField<::std::os::raw::c_uint>,
    pub vcpumask: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub src_mfn: __BindgenUnionField<xen_pfn_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_mmuext_op__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<mmuext_op__bindgen_ty_2>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( mmuext_op__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<mmuext_op__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mmuext_op__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmuext_op__bindgen_ty_2 ) ) . nr_ents as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mmuext_op__bindgen_ty_2
                ) , "::" , stringify ! ( nr_ents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmuext_op__bindgen_ty_2 ) ) . vcpumask as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mmuext_op__bindgen_ty_2
                ) , "::" , stringify ! ( vcpumask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmuext_op__bindgen_ty_2 ) ) . src_mfn as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mmuext_op__bindgen_ty_2
                ) , "::" , stringify ! ( src_mfn ) ));
}
impl Clone for mmuext_op__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_mmuext_op() {
    assert_eq!(::std::mem::size_of::<mmuext_op>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mmuext_op ) ));
    assert_eq! (::std::mem::align_of::<mmuext_op>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mmuext_op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmuext_op ) ) . cmd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mmuext_op ) , "::" ,
                stringify ! ( cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmuext_op ) ) . arg1 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mmuext_op ) , "::" ,
                stringify ! ( arg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmuext_op ) ) . arg2 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mmuext_op ) , "::" ,
                stringify ! ( arg2 ) ));
}
impl Clone for mmuext_op {
    fn clone(&self) -> Self { *self }
}
pub type __guest_handle_mmuext_op = *mut mmuext_op;
pub type domid_t = u16;
#[repr(C)]
#[derive(Copy)]
pub struct mmu_update {
    pub ptr: u64,
    pub val: u64,
}
#[test]
fn bindgen_test_layout_mmu_update() {
    assert_eq!(::std::mem::size_of::<mmu_update>() , 16usize , concat ! (
               "Size of: " , stringify ! ( mmu_update ) ));
    assert_eq! (::std::mem::align_of::<mmu_update>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mmu_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmu_update ) ) . ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mmu_update ) , "::" ,
                stringify ! ( ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmu_update ) ) . val as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mmu_update ) , "::" ,
                stringify ! ( val ) ));
}
impl Clone for mmu_update {
    fn clone(&self) -> Self { *self }
}
pub type __guest_handle_mmu_update = *mut mmu_update;
#[repr(C)]
#[derive(Copy)]
pub struct multicall_entry {
    pub op: xen_ulong_t,
    pub result: xen_long_t,
    pub args: [xen_ulong_t; 6usize],
}
#[test]
fn bindgen_test_layout_multicall_entry() {
    assert_eq!(::std::mem::size_of::<multicall_entry>() , 64usize , concat ! (
               "Size of: " , stringify ! ( multicall_entry ) ));
    assert_eq! (::std::mem::align_of::<multicall_entry>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( multicall_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multicall_entry ) ) . op as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( multicall_entry ) ,
                "::" , stringify ! ( op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multicall_entry ) ) . result as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( multicall_entry ) ,
                "::" , stringify ! ( result ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const multicall_entry ) ) . args as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( multicall_entry ) ,
                "::" , stringify ! ( args ) ));
}
impl Clone for multicall_entry {
    fn clone(&self) -> Self { *self }
}
pub type __guest_handle_multicall_entry = *mut multicall_entry;
#[repr(C)]
#[derive(Copy)]
pub struct vcpu_time_info {
    pub version: u32,
    pub pad0: u32,
    pub tsc_timestamp: u64,
    pub system_time: u64,
    pub tsc_to_system_mul: u32,
    pub tsc_shift: i8,
    pub pad1: [i8; 3usize],
}
#[test]
fn bindgen_test_layout_vcpu_time_info() {
    assert_eq!(::std::mem::size_of::<vcpu_time_info>() , 32usize , concat ! (
               "Size of: " , stringify ! ( vcpu_time_info ) ));
    assert_eq! (::std::mem::align_of::<vcpu_time_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vcpu_time_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_time_info ) ) . version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_time_info ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_time_info ) ) . pad0 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_time_info ) , "::"
                , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_time_info ) ) . tsc_timestamp as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_time_info ) , "::"
                , stringify ! ( tsc_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_time_info ) ) . system_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_time_info ) , "::"
                , stringify ! ( system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_time_info ) ) . tsc_to_system_mul as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_time_info ) , "::"
                , stringify ! ( tsc_to_system_mul ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_time_info ) ) . tsc_shift as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_time_info ) , "::"
                , stringify ! ( tsc_shift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_time_info ) ) . pad1 as * const _ as
                usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_time_info ) , "::"
                , stringify ! ( pad1 ) ));
}
impl Clone for vcpu_time_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct vcpu_info {
    pub evtchn_upcall_pending: u8,
    pub evtchn_upcall_mask: u8,
    pub evtchn_pending_sel: xen_ulong_t,
    pub arch: arch_vcpu_info,
    pub time: pvclock_vcpu_time_info,
}
#[test]
fn bindgen_test_layout_vcpu_info() {
    assert_eq!(::std::mem::size_of::<vcpu_info>() , 64usize , concat ! (
               "Size of: " , stringify ! ( vcpu_info ) ));
    assert_eq! (::std::mem::align_of::<vcpu_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vcpu_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_info ) ) . evtchn_upcall_pending as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_info ) , "::" ,
                stringify ! ( evtchn_upcall_pending ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_info ) ) . evtchn_upcall_mask as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_info ) , "::" ,
                stringify ! ( evtchn_upcall_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_info ) ) . evtchn_pending_sel as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_info ) , "::" ,
                stringify ! ( evtchn_pending_sel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_info ) ) . arch as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_info ) , "::" ,
                stringify ! ( arch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vcpu_info ) ) . time as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( vcpu_info ) , "::" ,
                stringify ! ( time ) ));
}
impl Clone for vcpu_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct shared_info {
    pub vcpu_info: [vcpu_info; 32usize],
    pub evtchn_pending: [xen_ulong_t; 64usize],
    pub evtchn_mask: [xen_ulong_t; 64usize],
    pub wc: pvclock_wall_clock,
    pub arch: arch_shared_info,
}
#[test]
fn bindgen_test_layout_shared_info() {
    assert_eq!(::std::mem::size_of::<shared_info>() , 3112usize , concat ! (
               "Size of: " , stringify ! ( shared_info ) ));
    assert_eq! (::std::mem::align_of::<shared_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( shared_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const shared_info ) ) . vcpu_info as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( shared_info ) , "::" ,
                stringify ! ( vcpu_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const shared_info ) ) . evtchn_pending as *
                const _ as usize } , 2048usize , concat ! (
                "Alignment of field: " , stringify ! ( shared_info ) , "::" ,
                stringify ! ( evtchn_pending ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const shared_info ) ) . evtchn_mask as * const
                _ as usize } , 2560usize , concat ! (
                "Alignment of field: " , stringify ! ( shared_info ) , "::" ,
                stringify ! ( evtchn_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const shared_info ) ) . wc as * const _ as
                usize } , 3072usize , concat ! (
                "Alignment of field: " , stringify ! ( shared_info ) , "::" ,
                stringify ! ( wc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const shared_info ) ) . arch as * const _ as
                usize } , 3088usize , concat ! (
                "Alignment of field: " , stringify ! ( shared_info ) , "::" ,
                stringify ! ( arch ) ));
}
#[repr(C)]
pub struct start_info {
    pub magic: [::std::os::raw::c_char; 32usize],
    pub nr_pages: ::std::os::raw::c_ulong,
    pub shared_info: ::std::os::raw::c_ulong,
    pub flags: u32,
    pub store_mfn: xen_pfn_t,
    pub store_evtchn: u32,
    pub console: start_info__bindgen_ty_1,
    pub pt_base: ::std::os::raw::c_ulong,
    pub nr_pt_frames: ::std::os::raw::c_ulong,
    pub mfn_list: ::std::os::raw::c_ulong,
    pub mod_start: ::std::os::raw::c_ulong,
    pub mod_len: ::std::os::raw::c_ulong,
    pub cmd_line: [i8; 1024usize],
    pub first_p2m_pfn: ::std::os::raw::c_ulong,
    pub nr_p2m_frames: ::std::os::raw::c_ulong,
}
#[repr(C)]
#[derive(Copy)]
pub struct start_info__bindgen_ty_1 {
    pub domU: __BindgenUnionField<start_info__bindgen_ty_1__bindgen_ty_1>,
    pub dom0: __BindgenUnionField<start_info__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct start_info__bindgen_ty_1__bindgen_ty_1 {
    pub mfn: xen_pfn_t,
    pub evtchn: u32,
}
#[test]
fn bindgen_test_layout_start_info__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<start_info__bindgen_ty_1__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               start_info__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<start_info__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                start_info__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info__bindgen_ty_1__bindgen_ty_1 )
                ) . mfn as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                start_info__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify !
                ( mfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info__bindgen_ty_1__bindgen_ty_1 )
                ) . evtchn as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                start_info__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify !
                ( evtchn ) ));
}
impl Clone for start_info__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct start_info__bindgen_ty_1__bindgen_ty_2 {
    pub info_off: u32,
    pub info_size: u32,
}
#[test]
fn bindgen_test_layout_start_info__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<start_info__bindgen_ty_1__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               start_info__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<start_info__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                start_info__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info__bindgen_ty_1__bindgen_ty_2 )
                ) . info_off as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                start_info__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify !
                ( info_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info__bindgen_ty_1__bindgen_ty_2 )
                ) . info_size as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                start_info__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify !
                ( info_size ) ));
}
impl Clone for start_info__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_start_info__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<start_info__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( start_info__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<start_info__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( start_info__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info__bindgen_ty_1 ) ) . domU as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                start_info__bindgen_ty_1 ) , "::" , stringify ! ( domU ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info__bindgen_ty_1 ) ) . dom0 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                start_info__bindgen_ty_1 ) , "::" , stringify ! ( dom0 ) ));
}
impl Clone for start_info__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_start_info() {
    assert_eq!(::std::mem::size_of::<start_info>() , 1168usize , concat ! (
               "Size of: " , stringify ! ( start_info ) ));
    assert_eq! (::std::mem::align_of::<start_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( start_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . magic as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . nr_pages as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( nr_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . shared_info as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( shared_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . flags as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . store_mfn as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( store_mfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . store_evtchn as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( store_evtchn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . console as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( console ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . pt_base as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( pt_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . nr_pt_frames as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( nr_pt_frames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . mfn_list as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( mfn_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . mod_start as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( mod_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . mod_len as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( mod_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . cmd_line as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( cmd_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . first_p2m_pfn as * const
                _ as usize } , 1152usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( first_p2m_pfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const start_info ) ) . nr_p2m_frames as * const
                _ as usize } , 1160usize , concat ! (
                "Alignment of field: " , stringify ! ( start_info ) , "::" ,
                stringify ! ( nr_p2m_frames ) ));
}
#[repr(C)]
#[derive(Copy)]
pub struct xen_multiboot_mod_list {
    pub mod_start: u32,
    pub mod_end: u32,
    pub cmdline: u32,
    pub pad: u32,
}
#[test]
fn bindgen_test_layout_xen_multiboot_mod_list() {
    assert_eq!(::std::mem::size_of::<xen_multiboot_mod_list>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xen_multiboot_mod_list )
               ));
    assert_eq! (::std::mem::align_of::<xen_multiboot_mod_list>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xen_multiboot_mod_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xen_multiboot_mod_list ) ) . mod_start as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xen_multiboot_mod_list
                ) , "::" , stringify ! ( mod_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xen_multiboot_mod_list ) ) . mod_end as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xen_multiboot_mod_list
                ) , "::" , stringify ! ( mod_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xen_multiboot_mod_list ) ) . cmdline as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xen_multiboot_mod_list
                ) , "::" , stringify ! ( cmdline ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xen_multiboot_mod_list ) ) . pad as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xen_multiboot_mod_list
                ) , "::" , stringify ! ( pad ) ));
}
impl Clone for xen_multiboot_mod_list {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct dom0_vga_console_info {
    pub video_type: u8,
    pub u: dom0_vga_console_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct dom0_vga_console_info__bindgen_ty_1 {
    pub text_mode_3: __BindgenUnionField<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1>,
    pub vesa_lfb: __BindgenUnionField<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1 {
    pub font_height: u16,
    pub cursor_x: u16,
    pub cursor_y: u16,
    pub rows: u16,
    pub columns: u16,
}
#[test]
fn bindgen_test_layout_dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1>()
               , 10usize , concat ! (
               "Size of: " , stringify ! (
               dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1
                ) ) . font_height as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( font_height ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1
                ) ) . cursor_x as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( cursor_x ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1
                ) ) . cursor_y as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( cursor_y ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1
                ) ) . rows as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( rows ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1
                ) ) . columns as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( columns ) ));
}
impl Clone for dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 {
    pub width: u16,
    pub height: u16,
    pub bytes_per_line: u16,
    pub bits_per_pixel: u16,
    pub lfb_base: u32,
    pub lfb_size: u32,
    pub red_pos: u8,
    pub red_size: u8,
    pub green_pos: u8,
    pub green_size: u8,
    pub blue_pos: u8,
    pub blue_size: u8,
    pub rsvd_pos: u8,
    pub rsvd_size: u8,
    pub gbl_caps: u32,
    pub mode_attrs: u16,
}
#[test]
fn bindgen_test_layout_dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . width as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . height as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . bytes_per_line as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( bytes_per_line ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . bits_per_pixel as * const _ as usize } , 6usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( bits_per_pixel ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . lfb_base as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( lfb_base ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . lfb_size as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( lfb_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . red_pos as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( red_pos ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . red_size as * const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( red_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . green_pos as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( green_pos ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . green_size as * const _ as usize } , 19usize , concat !
                (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( green_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . blue_pos as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( blue_pos ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . blue_size as * const _ as usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( blue_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . rsvd_pos as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( rsvd_pos ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . rsvd_size as * const _ as usize } , 23usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( rsvd_size ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . gbl_caps as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( gbl_caps ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2
                ) ) . mode_attrs as * const _ as usize } , 28usize , concat !
                (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( mode_attrs ) ));
}
impl Clone for dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_dom0_vga_console_info__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<dom0_vga_console_info__bindgen_ty_1>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( dom0_vga_console_info__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<dom0_vga_console_info__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dom0_vga_console_info__bindgen_ty_1 ) ) .
                text_mode_3 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1 ) , "::" , stringify ! (
                text_mode_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dom0_vga_console_info__bindgen_ty_1 ) ) .
                vesa_lfb as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                dom0_vga_console_info__bindgen_ty_1 ) , "::" , stringify ! (
                vesa_lfb ) ));
}
impl Clone for dom0_vga_console_info__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_dom0_vga_console_info() {
    assert_eq!(::std::mem::size_of::<dom0_vga_console_info>() , 36usize ,
               concat ! ( "Size of: " , stringify ! ( dom0_vga_console_info )
               ));
    assert_eq! (::std::mem::align_of::<dom0_vga_console_info>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( dom0_vga_console_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dom0_vga_console_info ) ) . video_type as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dom0_vga_console_info )
                , "::" , stringify ! ( video_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dom0_vga_console_info ) ) . u as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( dom0_vga_console_info )
                , "::" , stringify ! ( u ) ));
}
impl Clone for dom0_vga_console_info {
    fn clone(&self) -> Self { *self }
}
pub type cpumap_t = u64;
pub type xen_domain_handle_t = [u8; 16usize];
#[repr(C)]
#[derive(Copy)]
pub struct tmem_op {
    pub cmd: u32,
    pub pool_id: i32,
    pub u: tmem_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct tmem_op__bindgen_ty_1 {
    pub new: __BindgenUnionField<tmem_op__bindgen_ty_1__bindgen_ty_1>,
    pub gen: __BindgenUnionField<tmem_op__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct tmem_op__bindgen_ty_1__bindgen_ty_1 {
    pub uuid: [u64; 2usize],
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_tmem_op__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<tmem_op__bindgen_ty_1__bindgen_ty_1>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( tmem_op__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<tmem_op__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                tmem_op__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tmem_op__bindgen_ty_1__bindgen_ty_1 ) ) .
                uuid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tmem_op__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tmem_op__bindgen_ty_1__bindgen_ty_1 ) ) .
                flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                tmem_op__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                flags ) ));
}
impl Clone for tmem_op__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct tmem_op__bindgen_ty_1__bindgen_ty_2 {
    pub oid: [u64; 3usize],
    pub index: u32,
    pub tmem_offset: u32,
    pub pfn_offset: u32,
    pub len: u32,
    pub gmfn: __guest_handle_void,
}
#[test]
fn bindgen_test_layout_tmem_op__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<tmem_op__bindgen_ty_1__bindgen_ty_2>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( tmem_op__bindgen_ty_1__bindgen_ty_2
               ) ));
    assert_eq! (::std::mem::align_of::<tmem_op__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                tmem_op__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tmem_op__bindgen_ty_1__bindgen_ty_2 ) ) .
                oid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tmem_op__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                oid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tmem_op__bindgen_ty_1__bindgen_ty_2 ) ) .
                index as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                tmem_op__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tmem_op__bindgen_ty_1__bindgen_ty_2 ) ) .
                tmem_offset as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                tmem_op__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                tmem_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tmem_op__bindgen_ty_1__bindgen_ty_2 ) ) .
                pfn_offset as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                tmem_op__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                pfn_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tmem_op__bindgen_ty_1__bindgen_ty_2 ) ) .
                len as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                tmem_op__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tmem_op__bindgen_ty_1__bindgen_ty_2 ) ) .
                gmfn as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                tmem_op__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                gmfn ) ));
}
impl Clone for tmem_op__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_tmem_op__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<tmem_op__bindgen_ty_1>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( tmem_op__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<tmem_op__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tmem_op__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tmem_op__bindgen_ty_1 ) ) . new as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tmem_op__bindgen_ty_1 )
                , "::" , stringify ! ( new ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tmem_op__bindgen_ty_1 ) ) . gen as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tmem_op__bindgen_ty_1 )
                , "::" , stringify ! ( gen ) ));
}
impl Clone for tmem_op__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_tmem_op() {
    assert_eq!(::std::mem::size_of::<tmem_op>() , 56usize , concat ! (
               "Size of: " , stringify ! ( tmem_op ) ));
    assert_eq! (::std::mem::align_of::<tmem_op>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tmem_op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tmem_op ) ) . cmd as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tmem_op ) , "::" ,
                stringify ! ( cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tmem_op ) ) . pool_id as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tmem_op ) , "::" ,
                stringify ! ( pool_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tmem_op ) ) . u as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( tmem_op ) , "::" ,
                stringify ! ( u ) ));
}
impl Clone for tmem_op {
    fn clone(&self) -> Self { *self }
}
pub type __guest_handle_u64 = *mut u64;
extern "C" {
    #[link_name = "HYPERVISOR_shared_info"]
    pub static mut HYPERVISOR_shared_info: *mut shared_info;
}
extern "C" {
    #[link_name = "xen_start_info"]
    pub static mut xen_start_info: *mut start_info;
}
extern "C" {
    pub fn xen_hvm_need_lapic() -> bool_;
}
extern "C" {
    pub fn xen_set_iopl_mask(mask: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xen_setup_features();
}
extern "C" {
    #[link_name = "xen_features"]
    pub static mut xen_features: [u8; 32usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_vec {
    _unused: [u8; 0],
}
extern "C" {
    pub fn xen_biovec_phys_mergeable(vec1: *const bio_vec,
                                     vec2: *const bio_vec) -> bool_;
}
extern "C" {
    pub fn arch_phys_wc_index(handle: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_phys_wc_add(base: ::std::os::raw::c_ulong,
                            size: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_phys_wc_del(handle: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Copy)]
pub struct real_mode_header {
    pub text_start: u32,
    pub ro_end: u32,
    pub trampoline_start: u32,
    pub trampoline_status: u32,
    pub trampoline_header: u32,
    pub trampoline_pgd: u32,
    pub wakeup_start: u32,
    pub wakeup_header: u32,
    pub machine_real_restart_asm: u32,
    pub machine_real_restart_seg: u32,
}
#[test]
fn bindgen_test_layout_real_mode_header() {
    assert_eq!(::std::mem::size_of::<real_mode_header>() , 40usize , concat !
               ( "Size of: " , stringify ! ( real_mode_header ) ));
    assert_eq! (::std::mem::align_of::<real_mode_header>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( real_mode_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const real_mode_header ) ) . text_start as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( real_mode_header ) ,
                "::" , stringify ! ( text_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const real_mode_header ) ) . ro_end as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( real_mode_header ) ,
                "::" , stringify ! ( ro_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const real_mode_header ) ) . trampoline_start
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( real_mode_header ) ,
                "::" , stringify ! ( trampoline_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const real_mode_header ) ) . trampoline_status
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( real_mode_header ) ,
                "::" , stringify ! ( trampoline_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const real_mode_header ) ) . trampoline_header
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( real_mode_header ) ,
                "::" , stringify ! ( trampoline_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const real_mode_header ) ) . trampoline_pgd as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( real_mode_header ) ,
                "::" , stringify ! ( trampoline_pgd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const real_mode_header ) ) . wakeup_start as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( real_mode_header ) ,
                "::" , stringify ! ( wakeup_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const real_mode_header ) ) . wakeup_header as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( real_mode_header ) ,
                "::" , stringify ! ( wakeup_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const real_mode_header ) ) .
                machine_real_restart_asm as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( real_mode_header ) ,
                "::" , stringify ! ( machine_real_restart_asm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const real_mode_header ) ) .
                machine_real_restart_seg as * const _ as usize } , 36usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( real_mode_header ) ,
                "::" , stringify ! ( machine_real_restart_seg ) ));
}
impl Clone for real_mode_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct trampoline_header {
    pub start: u64,
    pub efer: u64,
    pub cr4: u32,
}
#[test]
fn bindgen_test_layout_trampoline_header() {
    assert_eq!(::std::mem::size_of::<trampoline_header>() , 24usize , concat !
               ( "Size of: " , stringify ! ( trampoline_header ) ));
    assert_eq! (::std::mem::align_of::<trampoline_header>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( trampoline_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trampoline_header ) ) . start as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( trampoline_header ) ,
                "::" , stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trampoline_header ) ) . efer as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( trampoline_header ) ,
                "::" , stringify ! ( efer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trampoline_header ) ) . cr4 as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( trampoline_header ) ,
                "::" , stringify ! ( cr4 ) ));
}
impl Clone for trampoline_header {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "real_mode_header"]
    pub static mut real_mode_header: *mut real_mode_header;
}
extern "C" {
    #[link_name = "real_mode_blob_end"]
    pub static mut real_mode_blob_end: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    #[link_name = "init_rsp"]
    pub static mut init_rsp: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "initial_code"]
    pub static mut initial_code: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "initial_gs"]
    pub static mut initial_gs: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "real_mode_blob"]
    pub static mut real_mode_blob: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    #[link_name = "real_mode_relocs"]
    pub static mut real_mode_relocs: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    #[link_name = "secondary_startup_64"]
    pub static mut secondary_startup_64: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    pub fn reserve_real_mode();
}
extern "C" {
    pub fn setup_real_mode();
}
extern "C" {
    #[link_name = "acpi_lapic"]
    pub static mut acpi_lapic: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "acpi_ioapic"]
    pub static mut acpi_ioapic: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "acpi_noirq"]
    pub static mut acpi_noirq: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "acpi_strict"]
    pub static mut acpi_strict: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "acpi_disabled"]
    pub static mut acpi_disabled: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "acpi_pci_disabled"]
    pub static mut acpi_pci_disabled: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "acpi_skip_timer_override"]
    pub static mut acpi_skip_timer_override: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "acpi_use_timer_override"]
    pub static mut acpi_use_timer_override: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "acpi_fix_pin2_polarity"]
    pub static mut acpi_fix_pin2_polarity: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "acpi_disable_cmcff"]
    pub static mut acpi_disable_cmcff: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "acpi_sci_flags"]
    pub static mut acpi_sci_flags: u8;
}
extern "C" {
    #[link_name = "acpi_sci_override_gsi"]
    pub static mut acpi_sci_override_gsi: ::std::os::raw::c_int;
}
extern "C" {
    pub fn acpi_pic_sci_set_trigger(arg1: ::std::os::raw::c_uint, arg2: u16);
}
extern "C" {
    #[link_name = "__acpi_register_gsi"]
    pub static mut __acpi_register_gsi:
               ::std::option::Option<unsafe extern "C" fn(dev: *mut device,
                                                          gsi: u32,
                                                          trigger:
                                                              ::std::os::raw::c_int,
                                                          polarity:
                                                              ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int>;
}
extern "C" {
    #[link_name = "__acpi_unregister_gsi"]
    pub static mut __acpi_unregister_gsi:
               ::std::option::Option<unsafe extern "C" fn(gsi: u32)>;
}
extern "C" {
    pub fn acpi_gsi_to_irq(gsi: u32, irq: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "acpi_suspend_lowlevel"]
    pub static mut acpi_suspend_lowlevel:
               ::std::option::Option<unsafe extern "C" fn()
                                         -> ::std::os::raw::c_int>;
}
extern "C" {
    #[link_name = "acpi_numa"]
    pub static mut acpi_numa: ::std::os::raw::c_int;
}
extern "C" {
    pub fn x86_acpi_numa_init() -> ::std::os::raw::c_int;
}
/// struct clocksource - hardware abstraction for a free running counter
/// Provides mostly state-free accessors to the underlying hardware.
/// This is the structure used for system time.
///
/// @name:		ptr to clocksource name
/// @list:		list head for registration
/// @rating:		rating value for selection (higher is better)
/// To avoid rating inflation the following
/// list should give you a guide as to how
/// to assign your clocksource a rating
/// 1-99: Unfit for real use
/// Only available for bootup and testing purposes.
/// 100-199: Base level usability.
/// Functional for real use, but not desired.
/// 200-299: Good.
/// A correct and usable clocksource.
/// 300-399: Desired.
/// A reasonably fast and accurate clocksource.
/// 400-499: Perfect
/// The ideal clocksource. A must-use where
/// available.
/// @read:		returns a cycle value, passes clocksource as argument
/// @enable:		optional function to enable the clocksource
/// @disable:		optional function to disable the clocksource
/// @mask:		bitmask for two's complement
/// subtraction of non 64 bit counters
/// @mult:		cycle to nanosecond multiplier
/// @shift:		cycle to nanosecond divisor (power of two)
/// @max_idle_ns:	max idle time permitted by the clocksource (nsecs)
/// @maxadj:		maximum adjustment value to mult (~11%)
/// @max_cycles:		maximum safe cycle value which won't overflow on multiplication
/// @flags:		flags describing special properties
/// @archdata:		arch-specific data
/// @suspend:		suspend function for the clocksource, if necessary
/// @resume:		resume function for the clocksource, if necessary
/// @owner:		module reference, must be set by clocksource in modules
#[repr(C)]
#[derive(Copy)]
pub struct clocksource {
    pub read: ::std::option::Option<unsafe extern "C" fn(cs: *mut clocksource)
                                        -> cycle_t>,
    pub mask: cycle_t,
    pub mult: u32,
    pub shift: u32,
    pub max_idle_ns: u64,
    pub maxadj: u32,
    pub archdata: arch_clocksource_data,
    pub max_cycles: u64,
    pub name: *const ::std::os::raw::c_char,
    pub list: list_head,
    pub rating: ::std::os::raw::c_int,
    pub enable: ::std::option::Option<unsafe extern "C" fn(cs:
                                                               *mut clocksource)
                                          -> ::std::os::raw::c_int>,
    pub disable: ::std::option::Option<unsafe extern "C" fn(cs:
                                                                *mut clocksource)>,
    pub flags: ::std::os::raw::c_ulong,
    pub suspend: ::std::option::Option<unsafe extern "C" fn(cs:
                                                                *mut clocksource)>,
    pub resume: ::std::option::Option<unsafe extern "C" fn(cs:
                                                               *mut clocksource)>,
    pub wd_list: list_head,
    pub cs_last: cycle_t,
    pub wd_last: cycle_t,
    pub owner: *mut module,
    pub __bindgen_padding_0: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_clocksource() {
    assert_eq!(::std::mem::size_of::<clocksource>() , 192usize , concat ! (
               "Size of: " , stringify ! ( clocksource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . read as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . mult as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( mult ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . shift as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( shift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . max_idle_ns as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( max_idle_ns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . maxadj as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( maxadj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . archdata as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( archdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . max_cycles as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( max_cycles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . name as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . list as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . rating as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( rating ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . enable as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( enable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . disable as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( disable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . flags as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . suspend as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( suspend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . resume as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( resume ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . wd_list as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( wd_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . cs_last as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( cs_last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . wd_last as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( wd_last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clocksource ) ) . owner as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( clocksource ) , "::" ,
                stringify ! ( owner ) ));
}
impl Clone for clocksource {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct arch_clocksource_data {
    pub vclock_mode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_arch_clocksource_data() {
    assert_eq!(::std::mem::size_of::<arch_clocksource_data>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( arch_clocksource_data )
               ));
    assert_eq! (::std::mem::align_of::<arch_clocksource_data>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( arch_clocksource_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arch_clocksource_data ) ) . vclock_mode
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( arch_clocksource_data )
                , "::" , stringify ! ( vclock_mode ) ));
}
impl Clone for arch_clocksource_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn clocksource_unregister(arg1: *mut clocksource)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clocksource_touch_watchdog();
}
extern "C" {
    pub fn clocksource_change_rating(cs: *mut clocksource,
                                     rating: ::std::os::raw::c_int);
}
extern "C" {
    pub fn clocksource_suspend();
}
extern "C" {
    pub fn clocksource_resume();
}
extern "C" {
    pub fn clocksource_default_clock() -> *mut clocksource;
}
extern "C" {
    pub fn clocksource_mark_unstable(cs: *mut clocksource);
}
extern "C" {
    pub fn clocks_calc_max_nsecs(mult: u32, shift: u32, maxadj: u32,
                                 mask: u64, max_cycles: *mut u64) -> u64;
}
extern "C" {
    pub fn clocks_calc_mult_shift(mult: *mut u32, shift: *mut u32, from: u32,
                                  to: u32, minsec: u32);
}
extern "C" {
    pub fn __clocksource_register_scale(cs: *mut clocksource, scale: u32,
                                        freq: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __clocksource_update_freq_scale(cs: *mut clocksource, scale: u32,
                                           freq: u32);
}
extern "C" {
    pub fn timekeeping_notify(clock: *mut clocksource)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clocksource_mmio_readl_up(arg1: *mut clocksource) -> cycle_t;
}
extern "C" {
    pub fn clocksource_mmio_readl_down(arg1: *mut clocksource) -> cycle_t;
}
extern "C" {
    pub fn clocksource_mmio_readw_up(arg1: *mut clocksource) -> cycle_t;
}
extern "C" {
    pub fn clocksource_mmio_readw_down(arg1: *mut clocksource) -> cycle_t;
}
extern "C" {
    pub fn clocksource_mmio_init(arg1: *mut ::std::os::raw::c_void,
                                 arg2: *const ::std::os::raw::c_char,
                                 arg3: ::std::os::raw::c_ulong,
                                 arg4: ::std::os::raw::c_int,
                                 arg5: ::std::os::raw::c_uint,
                                 arg6:
                                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                    *mut clocksource)
                                                               -> cycle_t>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clocksource_i8253_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acpi_generic_timer_init();
}
extern "C" {
    pub fn pvclock_clocksource_read(src: *mut pvclock_vcpu_time_info)
     -> cycle_t;
}
extern "C" {
    pub fn pvclock_read_flags(src: *mut pvclock_vcpu_time_info) -> u8;
}
extern "C" {
    pub fn pvclock_set_flags(flags: u8);
}
extern "C" {
    pub fn pvclock_tsc_khz(src: *mut pvclock_vcpu_time_info)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn pvclock_read_wallclock(wall: *mut pvclock_wall_clock,
                                  vcpu: *mut pvclock_vcpu_time_info,
                                  ts: *mut timespec);
}
extern "C" {
    pub fn pvclock_resume();
}
extern "C" {
    pub fn pvclock_touch_watchdogs();
}
#[repr(C)]
#[derive(Copy)]
pub struct pvclock_vsyscall_time_info {
    pub pvti: pvclock_vcpu_time_info,
    pub __bindgen_padding_0: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pvclock_vsyscall_time_info() {
    assert_eq!(::std::mem::size_of::<pvclock_vsyscall_time_info>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( pvclock_vsyscall_time_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pvclock_vsyscall_time_info ) ) . pvti as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pvclock_vsyscall_time_info ) , "::" , stringify ! ( pvti ) ));
}
impl Clone for pvclock_vsyscall_time_info {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn pvclock_init_vsyscall(i: *mut pvclock_vsyscall_time_info,
                                 size: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pvclock_get_vsyscall_time_info(cpu: ::std::os::raw::c_int)
     -> *mut pvclock_vcpu_time_info;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vsyscall_num {
    __NR_vgettimeofday = 0,
    __NR_vtime = 1,
    __NR_vgetcpu = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum fixed_addresses {
    VSYSCALL_PAGE = 511,
    PVCLOCK_FIXMAP_BEGIN = 512,
    PVCLOCK_FIXMAP_END = 515,
    FIX_DBGP_BASE = 516,
    FIX_EARLYCON_MEM_BASE = 517,
    FIX_APIC_BASE = 518,
    FIX_IO_APIC_BASE_0 = 519,
    FIX_IO_APIC_BASE_END = 646,
    FIX_RO_IDT = 647,
    FIX_PARAVIRT_BOOTMAP = 648,
    FIX_TEXT_POKE1 = 649,
    FIX_TEXT_POKE0 = 650,
    __end_of_permanent_fixed_addresses = 651,
    FIX_BTMAP_END = 1024,
    FIX_BTMAP_BEGIN = 1535,
    FIX_TBOOT_BASE = 1536,
    __end_of_fixed_addresses = 1537,
}
extern "C" {
    pub fn reserve_top_address(reserve: ::std::os::raw::c_ulong);
}
extern "C" {
    #[link_name = "fixmaps_set"]
    pub static mut fixmaps_set: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "kmap_pte"]
    pub static mut kmap_pte: *mut pte_t;
}
extern "C" {
    #[link_name = "kmap_prot"]
    pub static mut kmap_prot: pgprot_t;
}
extern "C" {
    #[link_name = "pkmap_page_table"]
    pub static mut pkmap_page_table: *mut pte_t;
}
extern "C" {
    pub fn __native_set_fixmap(idx: fixed_addresses, pte: pte_t);
}
extern "C" {
    pub fn native_set_fixmap(idx: fixed_addresses, phys: phys_addr_t,
                             flags: pgprot_t);
}
extern "C" {
    pub fn __early_set_fixmap(idx: fixed_addresses, phys: phys_addr_t,
                              flags: pgprot_t);
}
extern "C" {
    pub fn idle_notifier_register(n: *mut notifier_block);
}
extern "C" {
    pub fn idle_notifier_unregister(n: *mut notifier_block);
}
extern "C" {
    pub fn enter_idle();
}
extern "C" {
    pub fn exit_idle();
}
extern "C" {
    pub fn amd_e400_remove_cpu(cpu: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "apic_verbosity"]
    pub static mut apic_verbosity: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "local_apic_timer_c2_ok"]
    pub static mut local_apic_timer_c2_ok: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "disable_apic"]
    pub static mut disable_apic: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "lapic_timer_frequency"]
    pub static mut lapic_timer_frequency: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __inquire_remote_apic(apicid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setup_profiling_timer(arg1: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_apic_wait_icr_idle();
}
extern "C" {
    pub fn native_safe_apic_wait_icr_idle() -> u32;
}
extern "C" {
    pub fn native_apic_icr_write(low: u32, id: u32);
}
extern "C" {
    pub fn native_apic_icr_read() -> u64;
}
extern "C" {
    #[link_name = "x2apic_mode"]
    pub static mut x2apic_mode: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "x2apic_phys"]
    pub static mut x2apic_phys: ::std::os::raw::c_int;
}
extern "C" {
    pub fn check_x2apic();
}
extern "C" {
    pub fn x2apic_setup();
}
extern "C" {
    pub fn enable_IR_x2apic();
}
extern "C" {
    pub fn get_physical_broadcast() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lapic_get_maxlvt() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clear_local_APIC();
}
extern "C" {
    pub fn disconnect_bsp_APIC(virt_wire_setup: ::std::os::raw::c_int);
}
extern "C" {
    pub fn disable_local_APIC();
}
extern "C" {
    pub fn lapic_shutdown();
}
extern "C" {
    pub fn sync_Arb_IDs();
}
extern "C" {
    pub fn init_bsp_APIC();
}
extern "C" {
    pub fn setup_local_APIC();
}
extern "C" {
    pub fn init_apic_mappings();
}
extern "C" {
    pub fn register_lapic_address(address: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn setup_boot_APIC_clock();
}
extern "C" {
    pub fn setup_secondary_APIC_clock();
}
extern "C" {
    pub fn APIC_init_uniprocessor() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn apic_bsp_setup(upmode: bool_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn apic_ap_setup();
}
extern "C" {
    pub fn apic_is_clustered_box() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setup_APIC_eilvt(lvt_off: u8, vector: u8, msg_type: u8, mask: u8)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct apic {
    pub name: *mut ::std::os::raw::c_char,
    pub probe: ::std::option::Option<unsafe extern "C" fn()
                                         -> ::std::os::raw::c_int>,
    pub acpi_madt_oem_check: ::std::option::Option<unsafe extern "C" fn(oem_id:
                                                                            *mut ::std::os::raw::c_char,
                                                                        oem_table_id:
                                                                            *mut ::std::os::raw::c_char)
                                                       ->
                                                           ::std::os::raw::c_int>,
    pub apic_id_valid: ::std::option::Option<unsafe extern "C" fn(apicid:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
    pub apic_id_registered: ::std::option::Option<unsafe extern "C" fn()
                                                      ->
                                                          ::std::os::raw::c_int>,
    pub irq_delivery_mode: u32,
    pub irq_dest_mode: u32,
    pub target_cpus: ::std::option::Option<unsafe extern "C" fn()
                                               -> *const cpumask>,
    pub disable_esr: ::std::os::raw::c_int,
    pub dest_logical: ::std::os::raw::c_int,
    pub check_apicid_used: ::std::option::Option<unsafe extern "C" fn(map:
                                                                          *mut physid_mask_t,
                                                                      apicid:
                                                                          ::std::os::raw::c_int)
                                                     ->
                                                         ::std::os::raw::c_ulong>,
    pub vector_allocation_domain: ::std::option::Option<unsafe extern "C" fn(cpu:
                                                                                 ::std::os::raw::c_int,
                                                                             retmask:
                                                                                 *mut cpumask,
                                                                             mask:
                                                                                 *const cpumask)>,
    pub init_apic_ldr: ::std::option::Option<unsafe extern "C" fn()>,
    pub ioapic_phys_id_map: ::std::option::Option<unsafe extern "C" fn(phys_map:
                                                                           *mut physid_mask_t,
                                                                       retmap:
                                                                           *mut physid_mask_t)>,
    pub setup_apic_routing: ::std::option::Option<unsafe extern "C" fn()>,
    pub cpu_present_to_apicid: ::std::option::Option<unsafe extern "C" fn(mps_cpu:
                                                                              ::std::os::raw::c_int)
                                                         ->
                                                             ::std::os::raw::c_int>,
    pub apicid_to_cpu_present: ::std::option::Option<unsafe extern "C" fn(phys_apicid:
                                                                              ::std::os::raw::c_int,
                                                                          retmap:
                                                                              *mut physid_mask_t)>,
    pub check_phys_apicid_present: ::std::option::Option<unsafe extern "C" fn(phys_apicid:
                                                                                  ::std::os::raw::c_int)
                                                             ->
                                                                 ::std::os::raw::c_int>,
    pub phys_pkg_id: ::std::option::Option<unsafe extern "C" fn(cpuid_apic:
                                                                    ::std::os::raw::c_int,
                                                                index_msb:
                                                                    ::std::os::raw::c_int)
                                               -> ::std::os::raw::c_int>,
    pub get_apic_id: ::std::option::Option<unsafe extern "C" fn(x:
                                                                    ::std::os::raw::c_ulong)
                                               -> ::std::os::raw::c_uint>,
    pub set_apic_id: ::std::option::Option<unsafe extern "C" fn(id:
                                                                    ::std::os::raw::c_uint)
                                               -> ::std::os::raw::c_ulong>,
    pub apic_id_mask: ::std::os::raw::c_ulong,
    pub cpu_mask_to_apicid_and: ::std::option::Option<unsafe extern "C" fn(cpumask:
                                                                               *const cpumask,
                                                                           andmask:
                                                                               *const cpumask,
                                                                           apicid:
                                                                               *mut ::std::os::raw::c_uint)
                                                          ->
                                                              ::std::os::raw::c_int>,
    pub send_IPI_mask: ::std::option::Option<unsafe extern "C" fn(mask:
                                                                      *const cpumask,
                                                                  vector:
                                                                      ::std::os::raw::c_int)>,
    pub send_IPI_mask_allbutself: ::std::option::Option<unsafe extern "C" fn(mask:
                                                                                 *const cpumask,
                                                                             vector:
                                                                                 ::std::os::raw::c_int)>,
    pub send_IPI_allbutself: ::std::option::Option<unsafe extern "C" fn(vector:
                                                                            ::std::os::raw::c_int)>,
    pub send_IPI_all: ::std::option::Option<unsafe extern "C" fn(vector:
                                                                     ::std::os::raw::c_int)>,
    pub send_IPI_self: ::std::option::Option<unsafe extern "C" fn(vector:
                                                                      ::std::os::raw::c_int)>,
    pub wakeup_secondary_cpu: ::std::option::Option<unsafe extern "C" fn(apicid:
                                                                             ::std::os::raw::c_int,
                                                                         start_eip:
                                                                             ::std::os::raw::c_ulong)
                                                        ->
                                                            ::std::os::raw::c_int>,
    pub wait_for_init_deassert: bool_,
    pub inquire_remote_apic: ::std::option::Option<unsafe extern "C" fn(apicid:
                                                                            ::std::os::raw::c_int)>,
    pub read: ::std::option::Option<unsafe extern "C" fn(reg: u32) -> u32>,
    pub write: ::std::option::Option<unsafe extern "C" fn(reg: u32, v: u32)>,
    pub eoi_write: ::std::option::Option<unsafe extern "C" fn(reg: u32,
                                                              v: u32)>,
    pub icr_read: ::std::option::Option<unsafe extern "C" fn() -> u64>,
    pub icr_write: ::std::option::Option<unsafe extern "C" fn(low: u32,
                                                              high: u32)>,
    pub wait_icr_idle: ::std::option::Option<unsafe extern "C" fn()>,
    pub safe_wait_icr_idle: ::std::option::Option<unsafe extern "C" fn()
                                                      -> u32>,
}
#[test]
fn bindgen_test_layout_apic() {
    assert_eq!(::std::mem::size_of::<apic>() , 288usize , concat ! (
               "Size of: " , stringify ! ( apic ) ));
    assert_eq! (::std::mem::align_of::<apic>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( apic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . name as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . probe as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( probe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . acpi_madt_oem_check as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( acpi_madt_oem_check ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . apic_id_valid as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( apic_id_valid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . apic_id_registered as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( apic_id_registered ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . irq_delivery_mode as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( irq_delivery_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . irq_dest_mode as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( irq_dest_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . target_cpus as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( target_cpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . disable_esr as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( disable_esr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . dest_logical as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( dest_logical ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . check_apicid_used as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( check_apicid_used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . vector_allocation_domain as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( vector_allocation_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . init_apic_ldr as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( init_apic_ldr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . ioapic_phys_id_map as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( ioapic_phys_id_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . setup_apic_routing as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( setup_apic_routing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . cpu_present_to_apicid as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( cpu_present_to_apicid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . apicid_to_cpu_present as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( apicid_to_cpu_present ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . check_phys_apicid_present as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( check_phys_apicid_present ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . phys_pkg_id as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( phys_pkg_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . get_apic_id as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( get_apic_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . set_apic_id as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( set_apic_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . apic_id_mask as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( apic_id_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . cpu_mask_to_apicid_and as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( cpu_mask_to_apicid_and ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . send_IPI_mask as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( send_IPI_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . send_IPI_mask_allbutself as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( send_IPI_mask_allbutself ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . send_IPI_allbutself as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( send_IPI_allbutself ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . send_IPI_all as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( send_IPI_all ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . send_IPI_self as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( send_IPI_self ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . wakeup_secondary_cpu as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( wakeup_secondary_cpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . wait_for_init_deassert as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( wait_for_init_deassert ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . inquire_remote_apic as * const
                _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( inquire_remote_apic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . read as * const _ as usize } ,
                232usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . write as * const _ as usize }
                , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . eoi_write as * const _ as
                usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( eoi_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . icr_read as * const _ as usize
                } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( icr_read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . icr_write as * const _ as
                usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( icr_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . wait_icr_idle as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( wait_icr_idle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const apic ) ) . safe_wait_icr_idle as * const
                _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( apic ) , "::" ,
                stringify ! ( safe_wait_icr_idle ) ));
}
impl Clone for apic {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "apic"]
    pub static mut apic: *mut apic;
}
extern "C" {
    #[link_name = "__apicdrivers"]
    pub static mut __apicdrivers: [*mut apic; 0usize];
}
extern "C" {
    #[link_name = "__apicdrivers_end"]
    pub static mut __apicdrivers_end: [*mut apic; 0usize];
}
extern "C" {
    #[link_name = "init_deasserted"]
    pub static mut init_deasserted: atomic_t;
}
extern "C" {
    pub fn wakeup_secondary_cpu_via_nmi(apicid: ::std::os::raw::c_int,
                                        start_eip: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn apic_set_eoi_write(eoi_write:
                                  ::std::option::Option<unsafe extern "C" fn(reg:
                                                                                 u32,
                                                                             v:
                                                                                 u32)>);
}
extern "C" {
    pub fn apic_send_IPI_self(vector: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "x2apic_extra_bits"]
    pub static mut x2apic_extra_bits: ::std::os::raw::c_int;
}
extern "C" {
    pub fn default_cpu_present_to_apicid(mps_cpu: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn default_check_phys_apicid_present(phys_apicid:
                                                 ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_bigsmp_probe();
}
extern "C" {
    #[link_name = "x86_bios_cpu_apicid"]
    pub static mut x86_bios_cpu_apicid: ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "x86_bios_cpu_apicid_early_ptr"]
    pub static mut x86_bios_cpu_apicid_early_ptr:
               *mut ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "x86_bios_cpu_apicid_early_map"]
    pub static mut x86_bios_cpu_apicid_early_map:
               [::std::os::raw::c_ushort; 0usize];
}
extern "C" {
    pub fn default_acpi_madt_oem_check(arg1: *mut ::std::os::raw::c_char,
                                       arg2: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn default_setup_apic_routing();
}
extern "C" {
    #[link_name = "apic_noop"]
    pub static mut apic_noop: apic;
}
extern "C" {
    pub fn default_cpu_mask_to_apicid_and(cpumask: *const cpumask,
                                          andmask: *const cpumask,
                                          apicid: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn irq_enter();
}
extern "C" {
    pub fn irq_exit();
}
extern "C" {
    pub fn ioapic_zap_locks();
}
#[repr(C)]
#[derive(Copy)]
pub struct IO_APIC_reg_00 {
    pub raw: __BindgenUnionField<u32>,
    pub bits: __BindgenUnionField<IO_APIC_reg_00__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct IO_APIC_reg_00__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_00__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<IO_APIC_reg_00__bindgen_ty_1>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( IO_APIC_reg_00__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<IO_APIC_reg_00__bindgen_ty_1>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( IO_APIC_reg_00__bindgen_ty_1 )
                ));
}
impl Clone for IO_APIC_reg_00__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl IO_APIC_reg_00__bindgen_ty_1 {
    #[inline]
    pub fn __reserved_2(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16383u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: u32) {
        let mask = 16383u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn LTS(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16384u64 as u32;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_LTS(&mut self, val: u32) {
        let mask = 16384u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn delivery_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32768u64 as u32;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_type(&mut self, val: u32) {
        let mask = 32768u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16711680u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: u32) {
        let mask = 16711680u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn ID(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: u32) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__reserved_2: u32, LTS: u32, delivery_type: u32,
                          __reserved_1: u32, ID: u32) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({ 0 } |
                                 ((__reserved_2 as u32 as u32) << 0usize) &
                                     (16383u64 as u32))
                        } |
                            ((LTS as u32 as u32) << 14usize) &
                                (16384u64 as u32))
                   } |
                       ((delivery_type as u32 as u32) << 15usize) &
                           (32768u64 as u32))
              } |
                  ((__reserved_1 as u32 as u32) << 16usize) &
                      (16711680u64 as u32))
         } | ((ID as u32 as u32) << 24usize) & (4278190080u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_00() {
    assert_eq!(::std::mem::size_of::<IO_APIC_reg_00>() , 4usize , concat ! (
               "Size of: " , stringify ! ( IO_APIC_reg_00 ) ));
    assert_eq! (::std::mem::align_of::<IO_APIC_reg_00>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( IO_APIC_reg_00 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IO_APIC_reg_00 ) ) . raw as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IO_APIC_reg_00 ) , "::"
                , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IO_APIC_reg_00 ) ) . bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IO_APIC_reg_00 ) , "::"
                , stringify ! ( bits ) ));
}
impl Clone for IO_APIC_reg_00 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IO_APIC_reg_01 {
    pub raw: __BindgenUnionField<u32>,
    pub bits: __BindgenUnionField<IO_APIC_reg_01__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct IO_APIC_reg_01__bindgen_ty_1 {
    pub _bitfield_1: [u8; 4usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_01__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<IO_APIC_reg_01__bindgen_ty_1>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( IO_APIC_reg_01__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<IO_APIC_reg_01__bindgen_ty_1>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( IO_APIC_reg_01__bindgen_ty_1 )
                ));
}
impl Clone for IO_APIC_reg_01__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl IO_APIC_reg_01__bindgen_ty_1 {
    #[inline]
    pub fn version(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u32) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32512u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: u32) {
        let mask = 32512u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn PRQ(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 32768u64 as u32;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_PRQ(&mut self, val: u32) {
        let mask = 32768u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn entries(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16711680u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_entries(&mut self, val: u32) {
        let mask = 16711680u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: u32) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(version: u32, __reserved_2: u32, PRQ: u32,
                          entries: u32, __reserved_1: u32) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({ 0 } |
                                 ((version as u32 as u32) << 0usize) &
                                     (255u64 as u32))
                        } |
                            ((__reserved_2 as u32 as u32) << 8usize) &
                                (32512u64 as u32))
                   } | ((PRQ as u32 as u32) << 15usize) & (32768u64 as u32))
              } | ((entries as u32 as u32) << 16usize) & (16711680u64 as u32))
         } |
             ((__reserved_1 as u32 as u32) << 24usize) &
                 (4278190080u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_01() {
    assert_eq!(::std::mem::size_of::<IO_APIC_reg_01>() , 4usize , concat ! (
               "Size of: " , stringify ! ( IO_APIC_reg_01 ) ));
    assert_eq! (::std::mem::align_of::<IO_APIC_reg_01>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( IO_APIC_reg_01 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IO_APIC_reg_01 ) ) . raw as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IO_APIC_reg_01 ) , "::"
                , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IO_APIC_reg_01 ) ) . bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IO_APIC_reg_01 ) , "::"
                , stringify ! ( bits ) ));
}
impl Clone for IO_APIC_reg_01 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IO_APIC_reg_02 {
    pub raw: __BindgenUnionField<u32>,
    pub bits: __BindgenUnionField<IO_APIC_reg_02__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct IO_APIC_reg_02__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_02__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<IO_APIC_reg_02__bindgen_ty_1>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( IO_APIC_reg_02__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<IO_APIC_reg_02__bindgen_ty_1>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( IO_APIC_reg_02__bindgen_ty_1 )
                ));
}
impl Clone for IO_APIC_reg_02__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl IO_APIC_reg_02__bindgen_ty_1 {
    #[inline]
    pub fn __reserved_2(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 16777215u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: u32) {
        let mask = 16777215u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn arbitration(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 251658240u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_arbitration(&mut self, val: u32) {
        let mask = 251658240u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4026531840u64 as u32;
        let val = (unit_field_val & mask) >> 28usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: u32) {
        let mask = 4026531840u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 28usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__reserved_2: u32, arbitration: u32,
                          __reserved_1: u32) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((__reserved_2 as u32 as u32) << 0usize) &
                           (16777215u64 as u32))
              } |
                  ((arbitration as u32 as u32) << 24usize) &
                      (251658240u64 as u32))
         } |
             ((__reserved_1 as u32 as u32) << 28usize) &
                 (4026531840u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_02() {
    assert_eq!(::std::mem::size_of::<IO_APIC_reg_02>() , 4usize , concat ! (
               "Size of: " , stringify ! ( IO_APIC_reg_02 ) ));
    assert_eq! (::std::mem::align_of::<IO_APIC_reg_02>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( IO_APIC_reg_02 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IO_APIC_reg_02 ) ) . raw as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IO_APIC_reg_02 ) , "::"
                , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IO_APIC_reg_02 ) ) . bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IO_APIC_reg_02 ) , "::"
                , stringify ! ( bits ) ));
}
impl Clone for IO_APIC_reg_02 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct IO_APIC_reg_03 {
    pub raw: __BindgenUnionField<u32>,
    pub bits: __BindgenUnionField<IO_APIC_reg_03__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct IO_APIC_reg_03__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_03__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<IO_APIC_reg_03__bindgen_ty_1>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( IO_APIC_reg_03__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<IO_APIC_reg_03__bindgen_ty_1>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( IO_APIC_reg_03__bindgen_ty_1 )
                ));
}
impl Clone for IO_APIC_reg_03__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl IO_APIC_reg_03__bindgen_ty_1 {
    #[inline]
    pub fn boot_DT(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_boot_DT(&mut self, val: u32) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967294u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: u32) {
        let mask = 4294967294u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(boot_DT: u32, __reserved_1: u32) -> u32 {
        ({ ({ 0 } | ((boot_DT as u32 as u32) << 0usize) & (1u64 as u32)) } |
             ((__reserved_1 as u32 as u32) << 1usize) &
                 (4294967294u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_IO_APIC_reg_03() {
    assert_eq!(::std::mem::size_of::<IO_APIC_reg_03>() , 4usize , concat ! (
               "Size of: " , stringify ! ( IO_APIC_reg_03 ) ));
    assert_eq! (::std::mem::align_of::<IO_APIC_reg_03>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( IO_APIC_reg_03 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IO_APIC_reg_03 ) ) . raw as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IO_APIC_reg_03 ) , "::"
                , stringify ! ( raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IO_APIC_reg_03 ) ) . bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( IO_APIC_reg_03 ) , "::"
                , stringify ! ( bits ) ));
}
impl Clone for IO_APIC_reg_03 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct IO_APIC_route_entry {
    pub _bitfield_1: [u32; 2usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_IO_APIC_route_entry() {
    assert_eq!(::std::mem::size_of::<IO_APIC_route_entry>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( IO_APIC_route_entry ) ));
    assert_eq! (::std::mem::align_of::<IO_APIC_route_entry>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( IO_APIC_route_entry ) ));
}
impl Clone for IO_APIC_route_entry {
    fn clone(&self) -> Self { *self }
}
impl IO_APIC_route_entry {
    #[inline]
    pub fn vector(&self) -> __u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 255u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: __u32) {
        let mask = 255u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> __u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 1792u64 as u64;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: __u32) {
        let mask = 1792u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn dest_mode(&self) -> __u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 2048u64 as u64;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_dest_mode(&mut self, val: __u32) {
        let mask = 2048u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> __u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 4096u64 as u64;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: __u32) {
        let mask = 4096u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn polarity(&self) -> __u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 8192u64 as u64;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_polarity(&mut self, val: __u32) {
        let mask = 8192u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn irr(&self) -> __u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 16384u64 as u64;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_irr(&mut self, val: __u32) {
        let mask = 16384u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn trigger(&self) -> __u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 32768u64 as u64;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_trigger(&mut self, val: __u32) {
        let mask = 32768u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn mask(&self) -> __u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 65536u64 as u64;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: __u32) {
        let mask = 65536u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> __u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 4294836224u64 as u64;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: __u32) {
        let mask = 4294836224u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> __u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 72057589742960640u64 as u64;
        let val = (unit_field_val & mask) >> 32usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: __u32) {
        let mask = 72057589742960640u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 32usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn dest(&self) -> __u32 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 18374686479671623680u64 as u64;
        let val = (unit_field_val & mask) >> 56usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_dest(&mut self, val: __u32) {
        let mask = 18374686479671623680u64 as u64;
        let val = val as u32 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 56usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(vector: __u32, delivery_mode: __u32,
                          dest_mode: __u32, delivery_status: __u32,
                          polarity: __u32, irr: __u32, trigger: __u32,
                          mask: __u32, __reserved_2: __u32,
                          __reserved_3: __u32, dest: __u32) -> u64 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({
                                                          ({ 0 } |
                                                               ((vector as u32
                                                                     as u64)
                                                                    << 0usize)
                                                                   &
                                                                   (255u64 as
                                                                        u64))
                                                      } |
                                                          ((delivery_mode as
                                                                u32 as u64) <<
                                                               8usize) &
                                                              (1792u64 as
                                                                   u64))
                                                 } |
                                                     ((dest_mode as u32 as
                                                           u64) << 11usize) &
                                                         (2048u64 as u64))
                                            } |
                                                ((delivery_status as u32 as
                                                      u64) << 12usize) &
                                                    (4096u64 as u64))
                                       } |
                                           ((polarity as u32 as u64) <<
                                                13usize) & (8192u64 as u64))
                                  } |
                                      ((irr as u32 as u64) << 14usize) &
                                          (16384u64 as u64))
                             } |
                                 ((trigger as u32 as u64) << 15usize) &
                                     (32768u64 as u64))
                        } |
                            ((mask as u32 as u64) << 16usize) &
                                (65536u64 as u64))
                   } |
                       ((__reserved_2 as u32 as u64) << 17usize) &
                           (4294836224u64 as u64))
              } |
                  ((__reserved_3 as u32 as u64) << 32usize) &
                      (72057589742960640u64 as u64))
         } |
             ((dest as u32 as u64) << 56usize) &
                 (18374686479671623680u64 as u64))
    }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct IR_IO_APIC_route_entry {
    pub _bitfield_1: [u32; 2usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_IR_IO_APIC_route_entry() {
    assert_eq!(::std::mem::size_of::<IR_IO_APIC_route_entry>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( IR_IO_APIC_route_entry )
               ));
    assert_eq! (::std::mem::align_of::<IR_IO_APIC_route_entry>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( IR_IO_APIC_route_entry ) ));
}
impl Clone for IR_IO_APIC_route_entry {
    fn clone(&self) -> Self { *self }
}
impl IR_IO_APIC_route_entry {
    #[inline]
    pub fn vector(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 255u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: __u64) {
        let mask = 255u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn zero(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 1792u64 as u64;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: __u64) {
        let mask = 1792u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn index2(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 2048u64 as u64;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_index2(&mut self, val: __u64) {
        let mask = 2048u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 4096u64 as u64;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: __u64) {
        let mask = 4096u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn polarity(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 8192u64 as u64;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_polarity(&mut self, val: __u64) {
        let mask = 8192u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn irr(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 16384u64 as u64;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_irr(&mut self, val: __u64) {
        let mask = 16384u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn trigger(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 32768u64 as u64;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_trigger(&mut self, val: __u64) {
        let mask = 32768u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn mask(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 65536u64 as u64;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: __u64) {
        let mask = 65536u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 281474976579584u64 as u64;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        let mask = 281474976579584u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn format(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 281474976710656u64 as u64;
        let val = (unit_field_val & mask) >> 48usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_format(&mut self, val: __u64) {
        let mask = 281474976710656u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 48usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn index(&self) -> __u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 18446181123756130304u64 as u64;
        let val = (unit_field_val & mask) >> 49usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_index(&mut self, val: __u64) {
        let mask = 18446181123756130304u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 49usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(vector: __u64, zero: __u64, index2: __u64,
                          delivery_status: __u64, polarity: __u64, irr: __u64,
                          trigger: __u64, mask: __u64, reserved: __u64,
                          format: __u64, index: __u64) -> u64 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({
                                                          ({ 0 } |
                                                               ((vector as u64
                                                                     as u64)
                                                                    << 0usize)
                                                                   &
                                                                   (255u64 as
                                                                        u64))
                                                      } |
                                                          ((zero as u64 as
                                                                u64) <<
                                                               8usize) &
                                                              (1792u64 as
                                                                   u64))
                                                 } |
                                                     ((index2 as u64 as u64)
                                                          << 11usize) &
                                                         (2048u64 as u64))
                                            } |
                                                ((delivery_status as u64 as
                                                      u64) << 12usize) &
                                                    (4096u64 as u64))
                                       } |
                                           ((polarity as u64 as u64) <<
                                                13usize) & (8192u64 as u64))
                                  } |
                                      ((irr as u64 as u64) << 14usize) &
                                          (16384u64 as u64))
                             } |
                                 ((trigger as u64 as u64) << 15usize) &
                                     (32768u64 as u64))
                        } |
                            ((mask as u64 as u64) << 16usize) &
                                (65536u64 as u64))
                   } |
                       ((reserved as u64 as u64) << 17usize) &
                           (281474976579584u64 as u64))
              } |
                  ((format as u64 as u64) << 48usize) &
                      (281474976710656u64 as u64))
         } |
             ((index as u64 as u64) << 49usize) &
                 (18446181123756130304u64 as u64))
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_alloc_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ioapic_domain_cfg {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "nr_ioapics"]
    pub static mut nr_ioapics: ::std::os::raw::c_int;
}
extern "C" {
    pub fn mpc_ioapic_id(ioapic: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mpc_ioapic_addr(ioapic: ::std::os::raw::c_int)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "mp_irq_entries"]
    pub static mut mp_irq_entries: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "mp_irqs"]
    pub static mut mp_irqs: [mpc_intsrc; 1024usize];
}
extern "C" {
    #[link_name = "skip_ioapic_setup"]
    pub static mut skip_ioapic_setup: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "noioapicquirk"]
    pub static mut noioapicquirk: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "noioapicreroute"]
    pub static mut noioapicreroute: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "gsi_top"]
    pub static mut gsi_top: u32;
}
extern "C" {
    #[link_name = "io_apic_irqs"]
    pub static mut io_apic_irqs: ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_cfg {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ioapic_insert_resources();
}
extern "C" {
    pub fn arch_early_ioapic_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn save_ioapic_entries() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mask_ioapic_entries();
}
extern "C" {
    pub fn restore_ioapic_entries() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setup_ioapic_ids_from_mpc();
}
extern "C" {
    pub fn setup_ioapic_ids_from_mpc_nocheck();
}
extern "C" {
    pub fn mp_find_ioapic(gsi: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mp_find_ioapic_pin(ioapic: ::std::os::raw::c_int, gsi: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mp_map_gsi_to_irq(gsi: u32, flags: ::std::os::raw::c_uint,
                             info: *mut irq_alloc_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mp_unmap_irq(irq: ::std::os::raw::c_int);
}
extern "C" {
    pub fn mp_register_ioapic(id: ::std::os::raw::c_int, address: u32,
                              gsi_base: u32, cfg: *mut ioapic_domain_cfg)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mp_unregister_ioapic(gsi_base: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mp_ioapic_registered(gsi_base: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ioapic_set_alloc_attr(info: *mut irq_alloc_info,
                                 node: ::std::os::raw::c_int,
                                 trigger: ::std::os::raw::c_int,
                                 polarity: ::std::os::raw::c_int);
}
extern "C" {
    pub fn mp_save_irq(m: *mut mpc_intsrc);
}
extern "C" {
    pub fn disable_ioapic_support();
}
extern "C" {
    pub fn io_apic_init_mappings();
}
extern "C" {
    pub fn native_io_apic_read(apic: ::std::os::raw::c_uint,
                               reg: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn native_disable_io_apic();
}
extern "C" {
    pub fn setup_IO_APIC();
}
extern "C" {
    pub fn enable_IO_APIC();
}
extern "C" {
    pub fn disable_IO_APIC();
}
extern "C" {
    pub fn setup_ioapic_dest();
}
extern "C" {
    pub fn IO_APIC_get_PCI_irq_vector(bus: ::std::os::raw::c_int,
                                      devfn: ::std::os::raw::c_int,
                                      pin: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn print_IO_APICs();
}
extern "C" {
    #[link_name = "smp_num_siblings"]
    pub static mut smp_num_siblings: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "num_processors"]
    pub static mut num_processors: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "cpu_sibling_map"]
    pub static mut cpu_sibling_map: [cpumask; 1usize];
}
extern "C" {
    #[link_name = "cpu_core_map"]
    pub static mut cpu_core_map: [cpumask; 1usize];
}
extern "C" {
    #[link_name = "cpu_llc_shared_map"]
    pub static mut cpu_llc_shared_map: [cpumask; 1usize];
}
extern "C" {
    #[link_name = "cpu_llc_id"]
    pub static mut cpu_llc_id: ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "cpu_number"]
    pub static mut cpu_number: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "x86_cpu_to_apicid"]
    pub static mut x86_cpu_to_apicid: ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "x86_cpu_to_apicid_early_ptr"]
    pub static mut x86_cpu_to_apicid_early_ptr: *mut ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "x86_cpu_to_apicid_early_map"]
    pub static mut x86_cpu_to_apicid_early_map:
               [::std::os::raw::c_ushort; 0usize];
}
extern "C" {
    #[link_name = "stack_start"]
    pub static mut stack_start: ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Copy)]
pub struct smp_ops {
    pub smp_prepare_boot_cpu: ::std::option::Option<unsafe extern "C" fn()>,
    pub smp_prepare_cpus: ::std::option::Option<unsafe extern "C" fn(max_cpus:
                                                                         ::std::os::raw::c_uint)>,
    pub smp_cpus_done: ::std::option::Option<unsafe extern "C" fn(max_cpus:
                                                                      ::std::os::raw::c_uint)>,
    pub stop_other_cpus: ::std::option::Option<unsafe extern "C" fn(wait:
                                                                        ::std::os::raw::c_int)>,
    pub smp_send_reschedule: ::std::option::Option<unsafe extern "C" fn(cpu:
                                                                            ::std::os::raw::c_int)>,
    pub cpu_up: ::std::option::Option<unsafe extern "C" fn(cpu:
                                                               ::std::os::raw::c_uint,
                                                           tidle:
                                                               *mut task_struct)
                                          -> ::std::os::raw::c_int>,
    pub cpu_disable: ::std::option::Option<unsafe extern "C" fn()
                                               -> ::std::os::raw::c_int>,
    pub cpu_die: ::std::option::Option<unsafe extern "C" fn(cpu:
                                                                ::std::os::raw::c_uint)>,
    pub play_dead: ::std::option::Option<unsafe extern "C" fn()>,
    pub send_call_func_ipi: ::std::option::Option<unsafe extern "C" fn(mask:
                                                                           *const cpumask)>,
    pub send_call_func_single_ipi: ::std::option::Option<unsafe extern "C" fn(cpu:
                                                                                  ::std::os::raw::c_int)>,
}
#[test]
fn bindgen_test_layout_smp_ops() {
    assert_eq!(::std::mem::size_of::<smp_ops>() , 88usize , concat ! (
               "Size of: " , stringify ! ( smp_ops ) ));
    assert_eq! (::std::mem::align_of::<smp_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( smp_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const smp_ops ) ) . smp_prepare_boot_cpu as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( smp_ops ) , "::" ,
                stringify ! ( smp_prepare_boot_cpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const smp_ops ) ) . smp_prepare_cpus as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( smp_ops ) , "::" ,
                stringify ! ( smp_prepare_cpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const smp_ops ) ) . smp_cpus_done as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( smp_ops ) , "::" ,
                stringify ! ( smp_cpus_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const smp_ops ) ) . stop_other_cpus as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( smp_ops ) , "::" ,
                stringify ! ( stop_other_cpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const smp_ops ) ) . smp_send_reschedule as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( smp_ops ) , "::" ,
                stringify ! ( smp_send_reschedule ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const smp_ops ) ) . cpu_up as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( smp_ops ) , "::" ,
                stringify ! ( cpu_up ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const smp_ops ) ) . cpu_disable as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( smp_ops ) , "::" ,
                stringify ! ( cpu_disable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const smp_ops ) ) . cpu_die as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( smp_ops ) , "::" ,
                stringify ! ( cpu_die ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const smp_ops ) ) . play_dead as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( smp_ops ) , "::" ,
                stringify ! ( play_dead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const smp_ops ) ) . send_call_func_ipi as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( smp_ops ) , "::" ,
                stringify ! ( send_call_func_ipi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const smp_ops ) ) . send_call_func_single_ipi
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( smp_ops ) , "::" ,
                stringify ! ( send_call_func_single_ipi ) ));
}
impl Clone for smp_ops {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn set_cpu_sibling_map(cpu: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "smp_ops"]
    pub static mut smp_ops: smp_ops;
}
extern "C" {
    pub fn cpu_disable_common();
}
extern "C" {
    pub fn native_smp_prepare_boot_cpu();
}
extern "C" {
    pub fn native_smp_prepare_cpus(max_cpus: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn native_smp_cpus_done(max_cpus: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn common_cpu_up(cpunum: ::std::os::raw::c_uint,
                         tidle: *mut task_struct);
}
extern "C" {
    pub fn native_cpu_up(cpunum: ::std::os::raw::c_uint,
                         tidle: *mut task_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_cpu_disable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn common_cpu_die(cpu: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_cpu_die(cpu: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn native_play_dead();
}
extern "C" {
    pub fn play_dead_common();
}
extern "C" {
    pub fn wbinvd_on_cpu(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn wbinvd_on_all_cpus() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_send_call_func_ipi(mask: *const cpumask);
}
extern "C" {
    pub fn native_send_call_func_single_ipi(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn x86_idle_thread_init(cpu: ::std::os::raw::c_uint,
                                idle: *mut task_struct);
}
extern "C" {
    pub fn smp_store_boot_cpu_info();
}
extern "C" {
    pub fn smp_store_cpu_info(id: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "disabled_cpus"]
    pub static mut disabled_cpus: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hard_smp_processor_id() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn first_online_pgdat() -> *mut pglist_data;
}
extern "C" {
    pub fn next_online_pgdat(pgdat: *mut pglist_data) -> *mut pglist_data;
}
extern "C" {
    pub fn next_zone(zone: *mut zone) -> *mut zone;
}
extern "C" {
    /// next_zones_zonelist - Returns the next zone at or below highest_zoneidx within the allowed nodemask using a cursor within a zonelist as a starting point
/// @z - The cursor used as a starting point for the search
/// @highest_zoneidx - The zone index of the highest zone to return
/// @nodes - An optional nodemask to filter the zonelist with
///
/// This function returns the next zone at or below a given zone index that is
/// within the allowed nodemask using a cursor as the starting point for the
/// search. The zoneref returned is a cursor that represents the current zone
/// being examined. It should be advanced by one before calling
/// next_zones_zonelist again.
    pub fn next_zones_zonelist(z: *mut zoneref, highest_zoneidx: zone_type,
                               nodes: *mut nodemask_t) -> *mut zoneref;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_ext {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "mem_section"]
    pub static mut mem_section: [*mut mem_section; 2048usize];
}
extern "C" {
    pub fn __section_nr(ms: *mut mem_section) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn usemap_size() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn sparse_init();
}
#[repr(C)]
#[derive(Copy)]
pub struct mminit_pfnnid_cache {
    pub last_start: ::std::os::raw::c_ulong,
    pub last_end: ::std::os::raw::c_ulong,
    pub last_nid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mminit_pfnnid_cache() {
    assert_eq!(::std::mem::size_of::<mminit_pfnnid_cache>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( mminit_pfnnid_cache ) ));
    assert_eq! (::std::mem::align_of::<mminit_pfnnid_cache>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mminit_pfnnid_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mminit_pfnnid_cache ) ) . last_start as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mminit_pfnnid_cache ) ,
                "::" , stringify ! ( last_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mminit_pfnnid_cache ) ) . last_end as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mminit_pfnnid_cache ) ,
                "::" , stringify ! ( last_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mminit_pfnnid_cache ) ) . last_nid as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mminit_pfnnid_cache ) ,
                "::" , stringify ! ( last_nid ) ));
}
impl Clone for mminit_pfnnid_cache {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn node_memmap_size_bytes(arg1: ::std::os::raw::c_int,
                                  arg2: ::std::os::raw::c_ulong,
                                  arg3: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Copy)]
pub struct llist_head {
    pub first: *mut llist_node,
}
#[test]
fn bindgen_test_layout_llist_head() {
    assert_eq!(::std::mem::size_of::<llist_head>() , 8usize , concat ! (
               "Size of: " , stringify ! ( llist_head ) ));
    assert_eq! (::std::mem::align_of::<llist_head>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( llist_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const llist_head ) ) . first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( llist_head ) , "::" ,
                stringify ! ( first ) ));
}
impl Clone for llist_head {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct llist_node {
    pub next: *mut llist_node,
}
#[test]
fn bindgen_test_layout_llist_node() {
    assert_eq!(::std::mem::size_of::<llist_node>() , 8usize , concat ! (
               "Size of: " , stringify ! ( llist_node ) ));
    assert_eq! (::std::mem::align_of::<llist_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( llist_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const llist_node ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( llist_node ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for llist_node {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn llist_add_batch(new_first: *mut llist_node,
                           new_last: *mut llist_node, head: *mut llist_head)
     -> bool_;
}
extern "C" {
    pub fn llist_del_first(head: *mut llist_head) -> *mut llist_node;
}
extern "C" {
    pub fn llist_reverse_order(head: *mut llist_node) -> *mut llist_node;
}
pub type smp_call_func_t =
    ::std::option::Option<unsafe extern "C" fn(info:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Copy)]
pub struct call_single_data {
    pub llist: llist_node,
    pub func: smp_call_func_t,
    pub info: *mut ::std::os::raw::c_void,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_call_single_data() {
    assert_eq!(::std::mem::size_of::<call_single_data>() , 32usize , concat !
               ( "Size of: " , stringify ! ( call_single_data ) ));
    assert_eq! (::std::mem::align_of::<call_single_data>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( call_single_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const call_single_data ) ) . llist as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( call_single_data ) ,
                "::" , stringify ! ( llist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const call_single_data ) ) . func as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( call_single_data ) ,
                "::" , stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const call_single_data ) ) . info as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( call_single_data ) ,
                "::" , stringify ! ( info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const call_single_data ) ) . flags as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( call_single_data ) ,
                "::" , stringify ! ( flags ) ));
}
impl Clone for call_single_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "total_cpus"]
    pub static mut total_cpus: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn smp_call_function_single(cpuid: ::std::os::raw::c_int,
                                    func: smp_call_func_t,
                                    info: *mut ::std::os::raw::c_void,
                                    wait: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_each_cpu(func: smp_call_func_t,
                       info: *mut ::std::os::raw::c_void,
                       wait: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_each_cpu_mask(mask: *const cpumask, func: smp_call_func_t,
                            info: *mut ::std::os::raw::c_void, wait: bool_);
}
extern "C" {
    pub fn on_each_cpu_cond(cond_func:
                                ::std::option::Option<unsafe extern "C" fn(cpu:
                                                                               ::std::os::raw::c_int,
                                                                           info:
                                                                               *mut ::std::os::raw::c_void)
                                                          -> bool_>,
                            func: smp_call_func_t,
                            info: *mut ::std::os::raw::c_void, wait: bool_,
                            gfp_flags: gfp_t);
}
extern "C" {
    pub fn smp_call_function_single_async(cpu: ::std::os::raw::c_int,
                                          csd: *mut call_single_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smp_call_function(func: smp_call_func_t,
                             info: *mut ::std::os::raw::c_void,
                             wait: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smp_call_function_many(mask: *const cpumask, func: smp_call_func_t,
                                  info: *mut ::std::os::raw::c_void,
                                  wait: bool_);
}
extern "C" {
    pub fn smp_call_function_any(mask: *const cpumask, func: smp_call_func_t,
                                 info: *mut ::std::os::raw::c_void,
                                 wait: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kick_all_cpus_sync();
}
extern "C" {
    pub fn wake_up_all_idle_cpus();
}
extern "C" {
    pub fn call_function_init();
}
extern "C" {
    pub fn generic_smp_call_function_single_interrupt();
}
extern "C" {
    #[link_name = "setup_max_cpus"]
    pub static mut setup_max_cpus: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn setup_nr_cpu_ids();
}
extern "C" {
    pub fn smp_init();
}
extern "C" {
    pub fn arch_disable_smp_support();
}
extern "C" {
    pub fn arch_enable_nonboot_cpus_begin();
}
extern "C" {
    pub fn arch_enable_nonboot_cpus_end();
}
extern "C" {
    pub fn smp_setup_processor_id();
}
extern "C" {
    #[link_name = "pcpu_base_addr"]
    pub static mut pcpu_base_addr: *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "pcpu_unit_offsets"]
    pub static mut pcpu_unit_offsets: *const ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Copy)]
pub struct pcpu_group_info {
    pub nr_units: ::std::os::raw::c_int,
    pub base_offset: ::std::os::raw::c_ulong,
    pub cpu_map: *mut ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pcpu_group_info() {
    assert_eq!(::std::mem::size_of::<pcpu_group_info>() , 24usize , concat ! (
               "Size of: " , stringify ! ( pcpu_group_info ) ));
    assert_eq! (::std::mem::align_of::<pcpu_group_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pcpu_group_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu_group_info ) ) . nr_units as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu_group_info ) ,
                "::" , stringify ! ( nr_units ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu_group_info ) ) . base_offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu_group_info ) ,
                "::" , stringify ! ( base_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu_group_info ) ) . cpu_map as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu_group_info ) ,
                "::" , stringify ! ( cpu_map ) ));
}
impl Clone for pcpu_group_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pcpu_alloc_info {
    pub static_size: usize,
    pub reserved_size: usize,
    pub dyn_size: usize,
    pub unit_size: usize,
    pub atom_size: usize,
    pub alloc_size: usize,
    pub __ai_size: usize,
    pub nr_groups: ::std::os::raw::c_int,
    pub groups: __IncompleteArrayField<pcpu_group_info>,
}
#[test]
fn bindgen_test_layout_pcpu_alloc_info() {
    assert_eq!(::std::mem::size_of::<pcpu_alloc_info>() , 64usize , concat ! (
               "Size of: " , stringify ! ( pcpu_alloc_info ) ));
    assert_eq! (::std::mem::align_of::<pcpu_alloc_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pcpu_alloc_info ) ));
}
impl Clone for pcpu_alloc_info {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pcpu_fc {
    PCPU_FC_AUTO = 0,
    PCPU_FC_EMBED = 1,
    PCPU_FC_PAGE = 2,
    PCPU_FC_NR = 3,
}
extern "C" {
    #[link_name = "pcpu_fc_names"]
    pub static mut pcpu_fc_names: [*const ::std::os::raw::c_char; 3usize];
}
extern "C" {
    #[link_name = "pcpu_chosen_fc"]
    pub static mut pcpu_chosen_fc: pcpu_fc;
}
pub type pcpu_fc_alloc_fn_t =
    ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_uint,
                                               size: usize, align: usize)
                              -> *mut ::std::os::raw::c_void>;
pub type pcpu_fc_free_fn_t =
    ::std::option::Option<unsafe extern "C" fn(ptr:
                                                   *mut ::std::os::raw::c_void,
                                               size: usize)>;
pub type pcpu_fc_populate_pte_fn_t =
    ::std::option::Option<unsafe extern "C" fn(addr:
                                                   ::std::os::raw::c_ulong)>;
pub type pcpu_fc_cpu_distance_fn_t =
    ::std::option::Option<unsafe extern "C" fn(from: ::std::os::raw::c_uint,
                                               to: ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn pcpu_alloc_alloc_info(nr_groups: ::std::os::raw::c_int,
                                 nr_units: ::std::os::raw::c_int)
     -> *mut pcpu_alloc_info;
}
extern "C" {
    pub fn pcpu_free_alloc_info(ai: *mut pcpu_alloc_info);
}
extern "C" {
    pub fn pcpu_setup_first_chunk(ai: *const pcpu_alloc_info,
                                  base_addr: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcpu_embed_first_chunk(reserved_size: usize, dyn_size: usize,
                                  atom_size: usize,
                                  cpu_distance_fn: pcpu_fc_cpu_distance_fn_t,
                                  alloc_fn: pcpu_fc_alloc_fn_t,
                                  free_fn: pcpu_fc_free_fn_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcpu_page_first_chunk(reserved_size: usize,
                                 alloc_fn: pcpu_fc_alloc_fn_t,
                                 free_fn: pcpu_fc_free_fn_t,
                                 populate_pte_fn: pcpu_fc_populate_pte_fn_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __alloc_reserved_percpu(size: usize, align: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn is_kernel_percpu_address(addr: ::std::os::raw::c_ulong) -> bool_;
}
extern "C" {
    pub fn percpu_init_late();
}
extern "C" {
    pub fn __alloc_percpu_gfp(size: usize, align: usize, gfp: gfp_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __alloc_percpu(size: usize, align: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free_percpu(__pdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn per_cpu_ptr_to_phys(addr: *mut ::std::os::raw::c_void)
     -> phys_addr_t;
}
extern "C" {
    #[link_name = "printk_func"]
    pub static mut printk_func:
               ::std::option::Option<unsafe extern "C" fn()
                                         -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn arch_update_cpu_topology() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "numa_node"]
    pub static mut numa_node: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __alloc_pages_nodemask(gfp_mask: gfp_t,
                                  order: ::std::os::raw::c_uint,
                                  zonelist: *mut zonelist,
                                  nodemask: *mut nodemask_t) -> *mut page;
}
extern "C" {
    pub fn alloc_pages_current(gfp_mask: gfp_t, order: ::std::os::raw::c_uint)
     -> *mut page;
}
extern "C" {
    pub fn alloc_pages_vma(gfp_mask: gfp_t, order: ::std::os::raw::c_int,
                           vma: *mut vm_area_struct,
                           addr: ::std::os::raw::c_ulong,
                           node: ::std::os::raw::c_int, hugepage: bool_)
     -> *mut page;
}
extern "C" {
    pub fn alloc_kmem_pages(gfp_mask: gfp_t, order: ::std::os::raw::c_uint)
     -> *mut page;
}
extern "C" {
    pub fn alloc_kmem_pages_node(nid: ::std::os::raw::c_int, gfp_mask: gfp_t,
                                 order: ::std::os::raw::c_uint) -> *mut page;
}
extern "C" {
    pub fn __get_free_pages(gfp_mask: gfp_t, order: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn get_zeroed_page(gfp_mask: gfp_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn alloc_pages_exact(size: usize, gfp_mask: gfp_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free_pages_exact(virt: *mut ::std::os::raw::c_void, size: usize);
}
extern "C" {
    pub fn alloc_pages_exact_nid(nid: ::std::os::raw::c_int, size: usize,
                                 gfp_mask: gfp_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __free_pages(page: *mut page, order: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn free_pages(addr: ::std::os::raw::c_ulong,
                      order: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn free_hot_cold_page(page: *mut page, cold: bool_);
}
extern "C" {
    pub fn free_hot_cold_page_list(list: *mut list_head, cold: bool_);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_frag_cache {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __alloc_page_frag(nc: *mut page_frag_cache,
                             fragsz: ::std::os::raw::c_uint, gfp_mask: gfp_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __free_page_frag(addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __free_kmem_pages(page: *mut page, order: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn free_kmem_pages(addr: ::std::os::raw::c_ulong,
                           order: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn page_alloc_init();
}
extern "C" {
    pub fn drain_zone_pages(zone: *mut zone, pcp: *mut per_cpu_pages);
}
extern "C" {
    pub fn drain_all_pages(zone: *mut zone);
}
extern "C" {
    pub fn drain_local_pages(zone: *mut zone);
}
extern "C" {
    #[link_name = "gfp_allowed_mask"]
    pub static mut gfp_allowed_mask: gfp_t;
}
extern "C" {
    pub fn gfp_pfmemalloc_allowed(gfp_mask: gfp_t) -> bool_;
}
extern "C" {
    pub fn pm_restrict_gfp_mask();
}
extern "C" {
    pub fn pm_restore_gfp_mask();
}
extern "C" {
    pub fn pm_suspended_storage() -> bool_;
}
extern "C" {
    pub fn alloc_contig_range(start: ::std::os::raw::c_ulong,
                              end: ::std::os::raw::c_ulong,
                              migratetype: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn free_contig_range(pfn: ::std::os::raw::c_ulong,
                             nr_pages: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn init_cma_reserved_pageblock(page: *mut page);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmem_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup {
    _unused: [u8; 0],
}
extern "C" {
    pub fn kmem_cache_init();
}
extern "C" {
    pub fn slab_is_available() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kmem_cache_create(arg1: *const ::std::os::raw::c_char, arg2: usize,
                             arg3: usize, arg4: ::std::os::raw::c_ulong,
                             arg5:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                *mut ::std::os::raw::c_void)>)
     -> *mut kmem_cache;
}
extern "C" {
    pub fn kmem_cache_destroy(arg1: *mut kmem_cache);
}
extern "C" {
    pub fn kmem_cache_shrink(arg1: *mut kmem_cache) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcg_create_kmem_cache(arg1: *mut mem_cgroup,
                                   arg2: *mut kmem_cache);
}
extern "C" {
    pub fn memcg_deactivate_kmem_caches(arg1: *mut mem_cgroup);
}
extern "C" {
    pub fn memcg_destroy_kmem_caches(arg1: *mut mem_cgroup);
}
extern "C" {
    pub fn __krealloc(arg1: *const ::std::os::raw::c_void, arg2: usize,
                      arg3: gfp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn krealloc(arg1: *const ::std::os::raw::c_void, arg2: usize,
                    arg3: gfp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kfree(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn kzfree(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn ksize(arg1: *const ::std::os::raw::c_void) -> usize;
}
extern "C" {
    #[link_name = "kmalloc_caches"]
    pub static mut kmalloc_caches: [*mut kmem_cache; 14usize];
}
extern "C" {
    #[link_name = "kmalloc_dma_caches"]
    pub static mut kmalloc_dma_caches: [*mut kmem_cache; 14usize];
}
extern "C" {
    pub fn __kmalloc(size: usize, flags: gfp_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc(arg1: *mut kmem_cache, flags: gfp_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_free(arg1: *mut kmem_cache,
                           arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __kmalloc_node(size: usize, flags: gfp_t,
                          node: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc_node(arg1: *mut kmem_cache, flags: gfp_t,
                                 node: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc_trace(arg1: *mut kmem_cache, arg2: gfp_t,
                                  arg3: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc_node_trace(s: *mut kmem_cache, gfpflags: gfp_t,
                                       node: ::std::os::raw::c_int,
                                       size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmalloc_order(size: usize, flags: gfp_t,
                         order: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmalloc_order_trace(size: usize, flags: gfp_t,
                               order: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Copy)]
pub struct memcg_cache_array {
    pub rcu: callback_head,
    pub entries: __IncompleteArrayField<*mut kmem_cache>,
}
#[test]
fn bindgen_test_layout_memcg_cache_array() {
    assert_eq!(::std::mem::size_of::<memcg_cache_array>() , 16usize , concat !
               ( "Size of: " , stringify ! ( memcg_cache_array ) ));
    assert_eq! (::std::mem::align_of::<memcg_cache_array>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( memcg_cache_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memcg_cache_array ) ) . rcu as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( memcg_cache_array ) ,
                "::" , stringify ! ( rcu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memcg_cache_array ) ) . entries as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( memcg_cache_array ) ,
                "::" , stringify ! ( entries ) ));
}
impl Clone for memcg_cache_array {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct memcg_cache_params {
    pub is_root_cache: bool_,
    pub list: list_head,
    pub __bindgen_anon_1: memcg_cache_params__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct memcg_cache_params__bindgen_ty_1 {
    pub memcg_caches: __BindgenUnionField<*mut memcg_cache_array>,
    pub __bindgen_anon_1: __BindgenUnionField<memcg_cache_params__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct memcg_cache_params__bindgen_ty_1__bindgen_ty_1 {
    pub memcg: *mut mem_cgroup,
    pub root_cache: *mut kmem_cache,
}
#[test]
fn bindgen_test_layout_memcg_cache_params__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<memcg_cache_params__bindgen_ty_1__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               memcg_cache_params__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<memcg_cache_params__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                memcg_cache_params__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const memcg_cache_params__bindgen_ty_1__bindgen_ty_1 )
                ) . memcg as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                memcg_cache_params__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( memcg ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const memcg_cache_params__bindgen_ty_1__bindgen_ty_1 )
                ) . root_cache as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                memcg_cache_params__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( root_cache ) ));
}
impl Clone for memcg_cache_params__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_memcg_cache_params__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<memcg_cache_params__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( memcg_cache_params__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<memcg_cache_params__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                memcg_cache_params__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memcg_cache_params__bindgen_ty_1 ) ) .
                memcg_caches as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                memcg_cache_params__bindgen_ty_1 ) , "::" , stringify ! (
                memcg_caches ) ));
}
impl Clone for memcg_cache_params__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_memcg_cache_params() {
    assert_eq!(::std::mem::size_of::<memcg_cache_params>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( memcg_cache_params ) ));
    assert_eq! (::std::mem::align_of::<memcg_cache_params>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( memcg_cache_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memcg_cache_params ) ) . is_root_cache as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( memcg_cache_params ) ,
                "::" , stringify ! ( is_root_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const memcg_cache_params ) ) . list as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( memcg_cache_params ) ,
                "::" , stringify ! ( list ) ));
}
impl Clone for memcg_cache_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn memcg_update_all_caches(num_memcgs: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __kmalloc_track_caller(arg1: usize, arg2: gfp_t,
                                  arg3: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __kmalloc_node_track_caller(arg1: usize, arg2: gfp_t,
                                       arg3: ::std::os::raw::c_int,
                                       arg4: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_size(s: *mut kmem_cache) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn kmem_cache_init_late();
}
#[repr(C)]
#[derive(Copy)]
pub struct timerqueue_node {
    pub node: rb_node,
    pub expires: ktime_t,
}
#[test]
fn bindgen_test_layout_timerqueue_node() {
    assert_eq!(::std::mem::size_of::<timerqueue_node>() , 32usize , concat ! (
               "Size of: " , stringify ! ( timerqueue_node ) ));
    assert_eq! (::std::mem::align_of::<timerqueue_node>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( timerqueue_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timerqueue_node ) ) . node as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timerqueue_node ) ,
                "::" , stringify ! ( node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timerqueue_node ) ) . expires as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( timerqueue_node ) ,
                "::" , stringify ! ( expires ) ));
}
impl Clone for timerqueue_node {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct timerqueue_head {
    pub head: rb_root,
    pub next: *mut timerqueue_node,
}
#[test]
fn bindgen_test_layout_timerqueue_head() {
    assert_eq!(::std::mem::size_of::<timerqueue_head>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timerqueue_head ) ));
    assert_eq! (::std::mem::align_of::<timerqueue_head>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( timerqueue_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timerqueue_head ) ) . head as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timerqueue_head ) ,
                "::" , stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timerqueue_head ) ) . next as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timerqueue_head ) ,
                "::" , stringify ! ( next ) ));
}
impl Clone for timerqueue_head {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn timerqueue_add(head: *mut timerqueue_head,
                          node: *mut timerqueue_node) -> bool_;
}
extern "C" {
    pub fn timerqueue_del(head: *mut timerqueue_head,
                          node: *mut timerqueue_node) -> bool_;
}
extern "C" {
    pub fn timerqueue_iterate_next(node: *mut timerqueue_node)
     -> *mut timerqueue_node;
}
/// struct hrtimer_clock_base - the timer base for a specific clock
/// @cpu_base:		per cpu clock base
/// @index:		clock type index for per_cpu support when moving a
/// timer to a base on another cpu.
/// @clockid:		clock id for per_cpu support
/// @active:		red black tree root node for the active timers
/// @get_time:		function to retrieve the current time of the clock
/// @offset:		offset of this clock to the monotonic base
#[repr(C)]
#[derive(Copy)]
pub struct hrtimer_clock_base {
    pub cpu_base: *mut hrtimer_cpu_base,
    pub index: ::std::os::raw::c_int,
    pub clockid: clockid_t,
    pub active: timerqueue_head,
    pub get_time: ::std::option::Option<unsafe extern "C" fn() -> ktime_t>,
    pub offset: ktime_t,
    pub __bindgen_padding_0: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_hrtimer_clock_base() {
    assert_eq!(::std::mem::size_of::<hrtimer_clock_base>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( hrtimer_clock_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_clock_base ) ) . cpu_base as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_clock_base ) ,
                "::" , stringify ! ( cpu_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_clock_base ) ) . index as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_clock_base ) ,
                "::" , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_clock_base ) ) . clockid as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_clock_base ) ,
                "::" , stringify ! ( clockid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_clock_base ) ) . active as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_clock_base ) ,
                "::" , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_clock_base ) ) . get_time as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_clock_base ) ,
                "::" , stringify ! ( get_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_clock_base ) ) . offset as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_clock_base ) ,
                "::" , stringify ! ( offset ) ));
}
impl Clone for hrtimer_clock_base {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct hrtimer_cpu_base {
    pub lock: raw_spinlock_t,
    pub seq: seqcount_t,
    pub running: *mut hrtimer,
    pub cpu: ::std::os::raw::c_uint,
    pub active_bases: ::std::os::raw::c_uint,
    pub clock_was_set_seq: ::std::os::raw::c_uint,
    pub migration_enabled: bool_,
    pub nohz_active: bool_,
    pub _bitfield_1: u8,
    pub expires_next: ktime_t,
    pub next_timer: *mut hrtimer,
    pub nr_events: ::std::os::raw::c_uint,
    pub nr_retries: ::std::os::raw::c_uint,
    pub nr_hangs: ::std::os::raw::c_uint,
    pub max_hang_time: ::std::os::raw::c_uint,
    pub clock_base: [hrtimer_clock_base; 4usize],
}
#[test]
fn bindgen_test_layout_hrtimer_cpu_base() {
    assert_eq!(::std::mem::size_of::<hrtimer_cpu_base>() , 320usize , concat !
               ( "Size of: " , stringify ! ( hrtimer_cpu_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . lock as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . seq as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . running as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( running ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . cpu as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( cpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . active_bases as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( active_bases ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . clock_was_set_seq
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( clock_was_set_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . migration_enabled
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( migration_enabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . nohz_active as *
                const _ as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( nohz_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . expires_next as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( expires_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . next_timer as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( next_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . nr_events as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( nr_events ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . nr_retries as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( nr_retries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . nr_hangs as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( nr_hangs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . max_hang_time as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( max_hang_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_cpu_base ) ) . clock_base as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_cpu_base ) ,
                "::" , stringify ! ( clock_base ) ));
}
impl Clone for hrtimer_cpu_base {
    fn clone(&self) -> Self { *self }
}
impl hrtimer_cpu_base {
    #[inline]
    pub fn in_hrtirq(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_in_hrtirq(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn hres_active(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_hres_active(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn hang_detected(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_hang_detected(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(in_hrtirq: ::std::os::raw::c_uint,
                          hres_active: ::std::os::raw::c_uint,
                          hang_detected: ::std::os::raw::c_uint) -> u8 {
        ({
             ({
                  ({ 0 } |
                       ((in_hrtirq as u32 as u8) << 0usize) & (1u64 as u8))
              } | ((hres_active as u32 as u8) << 1usize) & (2u64 as u8))
         } | ((hang_detected as u32 as u8) << 2usize) & (4u64 as u8))
    }
}
pub const hrtimer_mode_HRTIMER_MODE_ABS_PINNED: hrtimer_mode =
    hrtimer_mode::HRTIMER_MODE_PINNED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hrtimer_mode {
    HRTIMER_MODE_ABS = 0,
    HRTIMER_MODE_REL = 1,
    HRTIMER_MODE_PINNED = 2,
    HRTIMER_MODE_REL_PINNED = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hrtimer_restart { HRTIMER_NORESTART = 0, HRTIMER_RESTART = 1, }
/// struct hrtimer_sleeper - simple sleeper structure
/// @timer:	embedded timer structure
/// @task:	task to wake up
///
/// task is set to NULL, when the timer expires.
#[repr(C)]
#[derive(Copy)]
pub struct hrtimer_sleeper {
    pub timer: hrtimer,
    pub task: *mut task_struct,
}
#[test]
fn bindgen_test_layout_hrtimer_sleeper() {
    assert_eq!(::std::mem::size_of::<hrtimer_sleeper>() , 96usize , concat ! (
               "Size of: " , stringify ! ( hrtimer_sleeper ) ));
    assert_eq! (::std::mem::align_of::<hrtimer_sleeper>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( hrtimer_sleeper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_sleeper ) ) . timer as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_sleeper ) ,
                "::" , stringify ! ( timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hrtimer_sleeper ) ) . task as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( hrtimer_sleeper ) ,
                "::" , stringify ! ( task ) ));
}
impl Clone for hrtimer_sleeper {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hrtimer_base_type {
    HRTIMER_BASE_MONOTONIC = 0,
    HRTIMER_BASE_REALTIME = 1,
    HRTIMER_BASE_BOOTTIME = 2,
    HRTIMER_BASE_TAI = 3,
    HRTIMER_MAX_CLOCK_BASES = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clock_event_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hrtimer_interrupt(dev: *mut clock_event_device);
}
extern "C" {
    pub fn hrtimer_peek_ahead_timers();
}
extern "C" {
    pub fn clock_was_set_delayed();
}
extern "C" {
    #[link_name = "hrtimer_resolution"]
    pub static mut hrtimer_resolution: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clock_was_set();
}
extern "C" {
    pub fn timerfd_clock_was_set();
}
extern "C" {
    pub fn hrtimers_resume();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tick_device {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "tick_cpu_device"]
    pub static mut tick_cpu_device: tick_device;
}
extern "C" {
    pub fn hrtimer_init(timer: *mut hrtimer, which_clock: clockid_t,
                        mode: hrtimer_mode);
}
extern "C" {
    pub fn hrtimer_start_range_ns(timer: *mut hrtimer, tim: ktime_t,
                                  range_ns: ::std::os::raw::c_ulong,
                                  mode: hrtimer_mode);
}
extern "C" {
    pub fn hrtimer_cancel(timer: *mut hrtimer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hrtimer_try_to_cancel(timer: *mut hrtimer)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __hrtimer_get_remaining(timer: *const hrtimer, adjust: bool_)
     -> ktime_t;
}
extern "C" {
    pub fn hrtimer_get_next_event() -> u64;
}
extern "C" {
    pub fn hrtimer_active(timer: *const hrtimer) -> bool_;
}
extern "C" {
    pub fn hrtimer_forward(timer: *mut hrtimer, now: ktime_t,
                           interval: ktime_t) -> u64;
}
extern "C" {
    pub fn hrtimer_nanosleep(rqtp: *mut timespec, rmtp: *mut timespec,
                             mode: hrtimer_mode, clockid: clockid_t)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn hrtimer_nanosleep_restart(restart_block: *mut restart_block)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn hrtimer_init_sleeper(sl: *mut hrtimer_sleeper,
                                tsk: *mut task_struct);
}
extern "C" {
    pub fn schedule_hrtimeout_range(expires: *mut ktime_t,
                                    delta: ::std::os::raw::c_ulong,
                                    mode: hrtimer_mode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn schedule_hrtimeout_range_clock(expires: *mut ktime_t,
                                          delta: ::std::os::raw::c_ulong,
                                          mode: hrtimer_mode,
                                          clock: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn schedule_hrtimeout(expires: *mut ktime_t, mode: hrtimer_mode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hrtimer_run_queues();
}
extern "C" {
    pub fn hrtimers_init();
}
extern "C" {
    pub fn sysrq_timer_list_show();
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pollfd {
    pub _address: u8,
}
impl Clone for pollfd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct dev_pm_qos {
    pub _address: u8,
}
impl Clone for dev_pm_qos {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ldt_struct {
    pub _address: u8,
}
impl Clone for ldt_struct {
    fn clone(&self) -> Self { *self }
}
